/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! This module is as straightforward a translation as possible of
//! https://github.com/cedar-policy/cedar-spec/blob/main/cedar-lean/Cedar/SymCC.lean.

mod authorizer;
mod bitvec;
mod compiler;
mod concretize;
mod decoder;
mod encoder;
mod enforcer;
mod entity_tag;
mod env;
mod ext;
mod extension_types;
mod extfun;
mod factory;
mod function;
mod interpretation;
mod op;
pub mod result;
mod smtlib_script;
pub mod solver;
mod tags;
mod term;
mod term_type;
mod type_abbrevs;
mod verifier;

use cedar_policy::{Entities, Request, Schema};
use decoder::{parse_sexpr, DecodeError, IdMaps};
use env::to_validator_request_env;
// public exports
pub use env::{Environment, SymEnv};
pub use interpretation::Interpretation;
pub use smtlib_script::SmtLibScript;

use cedar_policy_core::ast::{ExprBuilder, Policy, PolicySet};
use cedar_policy_core::validator::{
    typecheck::Typechecker, types::RequestEnv, ValidationError, ValidationMode,
};
use solver::{Decision, Solver};
use thiserror::Error;
use verifier::Asserts;

use encoder::Encoder;
pub use verifier::verify_sat;
use verifier::{
    verify_always_allows, verify_always_denies, verify_disjoint, verify_equivalent, verify_implies,
    verify_never_errors,
};

use crate::symcc::concretize::ConcretizeError;

#[derive(Debug, Error)]
pub enum Error {
    #[error("Action not found in Schema: {action}")]
    ActionNotInSchema { action: String },
    #[error(transparent)]
    SymCC(#[from] result::Error),
    #[error("Failed to construct encoder: {err}")]
    EncoderConstruction { err: anyhow::Error },
    #[error("Failed to encode terms: {err}")]
    Encoding { err: anyhow::Error },
    #[error(transparent)]
    Solver(#[from] solver::Error),
    #[error("Solver returned unknown")]
    SolverUnknown,
    /// Policy is not well-typed.
    #[error("Policy is not well typed.")]
    PolicyNotWellTyped { errs: Vec<ValidationError> },
    #[error("Failed to decode model: {0}")]
    DecodeModel(#[from] DecodeError),
    #[error("Failed to concretize interpretation: {0}")]
    ConcretizeError(#[from] ConcretizeError),
}
pub type Result<T> = std::result::Result<T, Error>;

/// Corresponds to the `SolverM` monad in Lean
#[derive(Debug, Clone)]
pub struct SymCompiler<S> {
    solver: S,
}

impl<S> SymCompiler<S> {
    pub fn new(solver: S) -> Self {
        Self { solver }
    }

    pub fn solver(&self) -> &S {
        &self.solver
    }

    pub fn solver_mut(&mut self) -> &mut S {
        &mut self.solver
    }
}

impl<S: Solver> SymCompiler<S> {
    /// Given a verification condition generator `vc`,
    /// calls the SMT solver on an SMTLib encoding of the conditions generated by `vc`
    /// and returns `true` if the result is unsatisfiable. The function `vc` is
    /// expected to produce a list of terms type `Bool` that are well-formed
    /// with respect to the `symenv`.
    async fn check_unsat(
        &mut self,
        vc: impl FnOnce(&SymEnv) -> std::result::Result<Asserts, result::Error>,
        symenv: &SymEnv,
    ) -> Result<bool> {
        let asserts = vc(symenv)?;
        if asserts.iter().any(|assert| *assert == false.into()) {
            // some assert has been compiled to constant-false by symcc.
            // skip encoding and calling the solver.
            Ok(true)
        } else if asserts.iter().all(|assert| *assert == true.into()) {
            // all asserts have been compiled to constant-true by symcc.
            // skip encoding and calling the solver.
            Ok(false)
        } else {
            self.solver
                .smtlib_input()
                .reset()
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            self.solver
                .smtlib_input()
                .set_logic("ALL")
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            let mut encoder = Encoder::new(symenv, self.solver.smtlib_input())
                .map_err(|err| Error::EncoderConstruction { err })?;
            encoder
                .encode(asserts)
                .await
                .map_err(|err| Error::Encoding { err })?;
            match self.solver.check_sat().await? {
                Decision::Unsat => Ok(true),
                Decision::Sat => Ok(false),
                Decision::Unknown => Err(Error::SolverUnknown),
            }
        }
    }

    /// Checks satisfiability, and then returns the model (as a pair of [`Request`] and [`Entities`])
    pub async fn check_sat(
        &mut self,
        vc: impl FnOnce(&SymEnv) -> std::result::Result<Asserts, result::Error>,
        symenv: &SymEnv,
        policy_set: &PolicySet,
    ) -> Result<Option<(Request, Entities)>> {
        let asserts = vc(symenv)?;
        if asserts.iter().any(|assert| *assert == false.into()) {
            // some assert has been reduced to constant-false by the symcc process.
            // skip encoding and calling the solver.
            Ok(None)
        } else if asserts.iter().all(|assert| *assert == true.into()) {
            let interp = Interpretation::default();
            Ok(Some(symenv.interpret(&interp).concretize()?))
        } else {
            self.solver
                .smtlib_input()
                .reset()
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            self.solver
                .smtlib_input()
                .set_logic("ALL")
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            self.solver
                .smtlib_input()
                .set_option("produce-models", "true")
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            let mut encoder = Encoder::new(symenv, self.solver.smtlib_input())
                .map_err(|err| Error::EncoderConstruction { err })?;
            encoder
                .encode(asserts)
                .await
                .map_err(|err| Error::Encoding { err })?;
            let id_maps = IdMaps::from_encoder(&encoder);
            match self.solver.check_sat().await? {
                Decision::Unsat => Ok(None),
                Decision::Sat => {
                    let Some(model_str) = self.solver.get_model().await? else {
                        return Ok(None);
                    };

                    let model = parse_sexpr(model_str.as_bytes())?;
                    let interp = model.decode_model(&id_maps)?;
                    let interp = interp.repair_as_counterexample(
                        policy_set
                            .policies()
                            .map(|p| p.condition())
                            .collect::<Vec<_>>()
                            .iter(),
                        symenv,
                    );

                    Ok(Some(symenv.interpret(&interp).concretize()?))
                }
                Decision::Unknown => Err(Error::SolverUnknown),
            }
        }
    }

    /// Returns true iff `policy` does not error on any well-formed input in the `symenv`.
    pub async fn check_never_errors(&mut self, policy: &Policy, symenv: &SymEnv) -> Result<bool> {
        self.check_unsat(|symenv| verify_never_errors(policy, symenv), symenv)
            .await
    }

    /// Returns true iff the authorization decision of `policies1` implies that
    /// of `policies2` for every well-formed input in the `symenv`. That is,
    /// every input allowed by `policies1` is allowed by `policies2`;
    /// `policies2` is either more permissive than, or equivalent to, `policies1`.
    pub async fn check_implies(
        &mut self,
        policies1: &PolicySet,
        policies2: &PolicySet,
        symenv: &SymEnv,
    ) -> Result<bool> {
        self.check_unsat(
            |symenv| verify_implies(policies1, policies2, symenv),
            symenv,
        )
        .await
    }

    /// Returns true iff `policies` allows all well-formed inputs in the `symenv`.
    pub async fn check_always_allows(
        &mut self,
        policies: &PolicySet,
        symenv: &SymEnv,
    ) -> Result<bool> {
        self.check_unsat(|symenv| verify_always_allows(policies, symenv), symenv)
            .await
    }

    /// Returns true iff `policies` denies all well-formed inputs in the `symenv`.
    pub async fn check_always_denies(
        &mut self,
        policies: &PolicySet,
        symenv: &SymEnv,
    ) -> Result<bool> {
        self.check_unsat(|symenv| verify_always_denies(policies, symenv), symenv)
            .await
    }

    /// Returns true iff `policies1` and `policies2` produce the same
    /// authorization decision on all well-formed inputs in the `symenv`.
    pub async fn check_equivalent(
        &mut self,
        policies1: &PolicySet,
        policies2: &PolicySet,
        symenv: &SymEnv,
    ) -> Result<bool> {
        self.check_unsat(
            |symenv| verify_equivalent(policies1, policies2, symenv),
            symenv,
        )
        .await
    }

    /// Returns true iff there is no well-formed input in the `symenv` that is allowed by both
    /// `policies1` and `policies2`. If this returns `false`, then there is at least one well-formed
    /// input that is allowed by both `policies1` and `policies2`.
    pub async fn check_disjoint(
        &mut self,
        policies1: &PolicySet,
        policies2: &PolicySet,
        symenv: &SymEnv,
    ) -> Result<bool> {
        self.check_unsat(
            |symenv| verify_disjoint(policies1, policies2, symenv),
            symenv,
        )
        .await
    }
}

/// The Cedar symbolic compiler assumes that it receives well-typed policies.  This
/// function enforces this requirement by calling Cedar's typechecker. Specifically,
/// given a policy `p` and type environment `Γ`, this function calls the Cedar
/// typechecker to obtain a policy `p'` that is semantically equivalent to `p` and
/// well-typed with respect to `Γ`.
///
/// All `check` functions defined in this file _must_ be called on the _output_ of
/// this function (or `well_typed_policies`) to ensure that symbolic compilation
/// succeeds. Applying the symbolic compiler directly to a policy `p` may result in
/// type errors---that is, the compiler rejecting the policy because it does not
/// satisfy the `WellTyped` constraints that are assumed by the compiler, and
/// enforced by the typechecker through policy transformation.
///
/// Note that unlike the corresponding Lean implementation which returns `Option` instead of `Result`.
/// We return a `Result` here to surface any type checking errors. In theory it should be impossible
/// to get an error since the policies are validated before calling SymCC.
pub fn well_typed_policy(
    policy: &Policy,
    env: &cedar_policy::RequestEnv,
    schema: &Schema,
) -> Result<Policy> {
    let env =
        to_validator_request_env(env, schema.as_ref()).ok_or_else(|| Error::ActionNotInSchema {
            action: env.action().to_string(),
        })?;
    well_typed_policy_inner(policy, &env, schema)
}

fn well_typed_policy_inner(policy: &Policy, env: &RequestEnv<'_>, schema: &Schema) -> Result<Policy> {
    let validator_schema = schema.as_ref();
    let type_checker = Typechecker::new(validator_schema, ValidationMode::Strict);
    let policy_check = type_checker.typecheck_by_single_request_env(policy.template(), env);

    match policy_check {
        cedar_policy_core::validator::typecheck::PolicyCheck::Success(expr) => {
            Ok(Policy::from_when_clause(
                policy.effect(),
                expr.into_expr::<ExprBuilder<()>>(),
                policy.id().clone(),
                policy.loc().cloned(),
            ))
        }
        cedar_policy_core::validator::typecheck::PolicyCheck::Irrelevant(errs, expr) =>
        // A policy could be irrelevant just for this environment, so unless there were errors we don't want to fail.
        // Note that if the policy was irrelevant for all environments schema validation would have caught this
        // before SymCC. The Lean implementation needs to be updated to match this behavior.
        {
            if errs.is_empty() {
                Ok(Policy::from_when_clause(
                    policy.effect(),
                    expr.into_expr::<ExprBuilder<()>>(),
                    policy.id().clone(),
                    policy.loc().cloned(),
                ))
            } else {
                Err(Error::PolicyNotWellTyped { errs })
            }
        }
        cedar_policy_core::validator::typecheck::PolicyCheck::Fail(errs) => {
            Err(Error::PolicyNotWellTyped { errs })
        }
    }
}

pub fn well_typed_policies(
    policies: &PolicySet,
    env: &cedar_policy::RequestEnv,
    schema: &Schema,
) -> Result<PolicySet> {
    let env =
        to_validator_request_env(env, schema.as_ref()).ok_or_else(|| Error::ActionNotInSchema {
            action: env.action().to_string(),
        })?;
    let typed_policies: Result<Vec<Policy>> = policies
        .static_policies()
        .map(|p| well_typed_policy_inner(p, &env, schema))
        .collect();
    match typed_policies {
        Ok(ps) => {
            let mut res = PolicySet::new();
            ps.into_iter().for_each(|p| res.add(p).unwrap());
            Ok(res)
        }
        Err(err) => Err(err),
    }
}
