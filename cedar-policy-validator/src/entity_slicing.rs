//! Entity Slicing

use std::collections::{BTreeMap, HashMap, HashSet};
use std::fmt::{Display, Formatter};
use std::hash::RandomState;
use std::sync::Arc;

use cedar_policy_core::entities::err::EntitiesError;
use cedar_policy_core::entities::{Dereference, NoEntitiesSchema, TCComputation};
use cedar_policy_core::extensions::Extensions;
use cedar_policy_core::{
    ast::{
        BinaryOp, Entity, EntityUID, Expr, ExprKind, Literal, PartialValue, PolicySet, Request,
        RequestType, UnaryOp, Value, ValueKind, Var,
    },
    entities::Entities,
};
use miette::Diagnostic;
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use smol_str::SmolStr;
use thiserror::Error;

use crate::ValidationError;
use crate::{
    typecheck::{PolicyCheck, Typechecker},
    types::{EntityRecordKind, Type},
    ValidationMode, ValidatorSchema,
};

type PerAction<T> = HashMap<RequestType, PrimarySlice<T>>;
type FlatPerAction = HashMap<RequestType, FlatPrimarySlice>;

/// Data structure that tells the user what data is needed
/// based on the action's ID
#[serde_as]
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct EntityManifest<T = ()>
where
    T: Clone,
{
    /// A map from actions to primary slice
    #[serde_as(as = "Vec<(_, _)>")]
    #[serde(bound(deserialize = "T: Default"))]
    pub per_action: PerAction<T>,
}

/// A flattened version of an [`EntityManifest`]
#[derive(Debug)]
pub struct FlatEntityManifest {
    /// For each action, all the data paths required
    pub per_action: FlatPerAction,
}

/// A map of data fields to entity slices
pub type Fields<T> = HashMap<SmolStr, Box<EntitySlice<T>>>;

/// The root of an entity slice.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
pub enum EntityRoot {
    /// Literal entity ids
    Literal(EntityUID),
    /// A Cedar variable
    Var(Var),
}

impl Display for EntityRoot {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            EntityRoot::Literal(l) => write!(f, "{l}"),
            EntityRoot::Var(v) => write!(f, "{v}"),
        }
    }
}

/// a [`PrimarySlice`] is a tree that tells you what data to load
#[serde_as]
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct PrimarySlice<T = ()>
where
    T: Clone,
{
    #[serde_as(as = "Vec<(_, _)>")]
    #[serde(bound(deserialize = "T: Default"))]
    /// The data that needs to be loaded, organized by root
    pub trie: HashMap<EntityRoot, EntitySlice<T>>,
}

/// A flattened version of a [`PrimarySlice`]
#[derive(Debug)]
pub struct FlatPrimarySlice {
    /// All the paths of data required, each starting with a root [`Var`]
    pub data: Vec<FlatEntitySlice>,
}

/// An entity slice- tells users a tree of data to load
#[serde_as]
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct EntitySlice<T = ()> {
    /// Child data of this entity slice.
    #[serde_as(as = "Vec<(_, _)>")]
    pub children: Fields<T>,
    /// For entity types, this boolean may be `true`
    /// to signal that all the parents in the entity hierarchy
    /// are required (transitively).
    pub parents_required: bool,
    /// Optional data annotation, usually used for type information.
    #[serde(skip_serializing, skip_deserializing)]
    #[serde(bound(deserialize = "T: Default"))]
    pub data: T,
}

/// A data path that may end with requesting the parents of
/// an entity.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FlatEntitySlice {
    /// The root variable that begins the data path
    pub root: EntityRoot,
    /// The path of fields of entities or structs
    pub path: Vec<SmolStr>,
    /// Request all the parents in the entity hierarchy of this entity.
    pub parents_required: bool,
}

/// An error generated by entity slicing.
#[derive(Debug, Error, Diagnostic)]
#[non_exhaustive]
pub enum EntitySliceError {
    /// A validation error was encountered
    #[error(transparent)]
    #[diagnostic(transparent)]
    ValidationError(#[from] ValidationError),
    /// A entities error was encountered
    #[error(transparent)]
    #[diagnostic(transparent)]
    EntitiesError(#[from] EntitiesError),

    /// The request was partial
    #[error("Entity slicing requires a fully concrete request. Got a partial request.")]
    PartialRequestError,
    /// A policy was partial
    #[error(
        "Entity slicing requires fully concrete policies. Got a policy with an unknown expression."
    )]
    PartialExpressionError,

    /// A policy was not analyzable because it used operators
    /// before a [`ExprKind::GetAttr`]
    /// TODO make a more specific error that includes the expression
    #[error("Failed to analyze policy: mixed getting attributes with other operators")]
    FailedAnalysis,

    /// During entity loading, failed to find an entity.
    #[error("Missing entity `{0}` during entity loading.")]
    MissingEntity(EntityUID),

    /// During entity loading, attempted to load from
    /// a type without fields.
    #[error("Expected entity or record during entity loading. Got value: {0}")]
    IncompatibleEntityManifest(Value),

    /// Found a partial entity during entity loading.
    #[error("Found partial entity while doing entity slicing.")]
    PartialEntity,

    /// During entity loading using the simplified API,
    /// the entity loader returned the wrong number of entities.
    #[error("Wrong number of entities returned ({0}). Expected {1}.")]
    WrongNumberOfEntities(usize, usize),
}

fn union_fields<T: Clone>(first: &Fields<T>, second: &Fields<T>) -> Fields<T> {
    let mut res = first.clone();
    for (key, value) in second {
        if let Some(existing) = res.get(key) {
            res.insert(key.clone(), Box::new((*existing).union(value)));
        } else {
            res.insert(key.clone(), value.clone());
        }
    }
    res
}

impl EntityManifest {
    /// Use this entity manifest to
    /// find an entity slice using an existing [`Entities`] store.
    pub fn slice_entities(
        &self,
        entities: &Entities,
        request: &Request,
    ) -> Result<Entities, EntitySliceError> {
        let request_type = request
            .to_concrete_env()
            .ok_or(EntitySliceError::PartialRequestError)?;
        self.per_action
            .get(&request_type)
            .map(|primary| primary.slice_entities(entities, request))
            .unwrap_or(Ok(Entities::default()))
    }

    /// Flatten this manifest into a [`FlatEntityManifest`]
    pub fn to_flat_entity_manifest(&self) -> FlatEntityManifest {
        let mut per_action: FlatPerAction = Default::default();

        for (action, primary) in &self.per_action {
            per_action.insert(action.clone(), primary.to_flat_primary_slice());
        }
        FlatEntityManifest { per_action }
    }

    /// Convert this manifest into a human-readable format.
    /// The format specifies the request types, then
    /// prints all the flattened paths as cedar expressions.
    pub fn to_str_natural(&self) -> String {
        let flattened = self.to_flat_entity_manifest();
        let exprs = flattened.to_exprs();
        let mut res = String::new();
        for (types, exprs) in exprs {
            res.push_str(&format!("{} {{\n", types.to_str_natural()));
            for expr in exprs {
                res.push_str(&format!("  {}\n", expr));
            }
            res.push_str("}\n");
        }
        res
    }
}

impl FlatEntityManifest {
    /// Convert this flattened manifest into a list of cedar expressions.
    /// The expressions only use the constructors [`ExprKind::GetAttr`] and [`Var`].
    /// They may also have the shape `principal in expr` to denote that
    /// the parents of `expr` are needed.
    pub fn to_exprs(&self) -> HashMap<RequestType, Vec<Expr>> {
        let mut res: HashMap<RequestType, Vec<Expr>> = Default::default();
        for (types, path) in &self.per_action {
            let exprs = path.to_exprs();
            res.insert(types.clone(), exprs);
        }
        res
    }
}

impl FlatPrimarySlice {
    fn to_exprs(&self) -> Vec<Expr> {
        let mut res = vec![];
        for slice in &self.data {
            let expr = slice.to_expr();
            res.push(expr);
        }
        res
    }
}

impl FlatEntitySlice {
    /// Given a path of fields to access, convert to a tree
    /// (the [`Fields`] data structure.
    /// Also, when we need to pull all the data for the final field
    /// do so.
    fn to_primary_slice(&self) -> PrimarySlice {
        self.to_primary_slice_with_leaf(EntitySlice {
            parents_required: true,
            children: Default::default(),
            data: (),
        })
    }

    fn to_primary_slice_with_leaf(&self, leaf_entity: EntitySlice) -> PrimarySlice {
        let mut current = leaf_entity;
        // reverse the path, visiting the last access first
        for field in self.path.iter().rev() {
            let mut fields = HashMap::new();
            fields.insert(field.clone(), Box::new(current));
            current = EntitySlice {
                parents_required: false,
                children: fields,
                data: (),
            };
        }

        let mut primary_map = HashMap::new();
        primary_map.insert(self.root.clone(), current);
        PrimarySlice { trie: primary_map }
    }

    fn to_expr(&self) -> Expr {
        let mut expr = self.root.to_expr();

        for field in &self.path {
            expr = Expr::get_attr(expr, field.clone());
        }

        if self.parents_required {
            expr = Expr::binary_app(BinaryOp::In, Expr::var(Var::Principal), expr);
        }
        expr
    }

    /// Converts compatible expressions to a [`FlatEntitySlice`]
    /// Compatible expressions start with a variable, with
    /// any number of [`ExprKin::GetAttr`], and optionally are wrapped with
    /// `principal in <expr>`
    fn from_expr(expr: &Expr) -> Option<FlatEntitySlice> {
        let (mut current_expr, parents_required) = match expr.expr_kind() {
            ExprKind::BinaryApp {
                op: BinaryOp::In,
                arg1,
                arg2,
            } => {
                if **arg1 != Expr::var(Var::Principal) {
                    return None;
                }
                (arg2.clone(), true)
            }
            _ => (Arc::new(expr.clone()), false),
        };

        let mut path = vec![];
        loop {
            match current_expr.expr_kind() {
                ExprKind::GetAttr { expr, attr } => {
                    path.push(attr.clone());
                    current_expr = expr.clone();
                }
                ExprKind::Var(var) => {
                    path.reverse();

                    return Some(FlatEntitySlice {
                        root: EntityRoot::Var(*var),
                        path,
                        parents_required,
                    });
                }
                ExprKind::Lit(Literal::EntityUID(literal)) => {
                    path.reverse();

                    return Some(FlatEntitySlice {
                        root: EntityRoot::Literal((**literal).clone()),
                        path,
                        parents_required,
                    });
                }
                _ => return None,
            }
        }
    }
}

impl EntityRoot {
    /// Convert this root to a cedar expression.
    /// This will either be a variable or a literal.
    pub fn to_expr(&self) -> Expr {
        match self {
            Self::Literal(lit) => Expr::val(Literal::EntityUID(Arc::new(lit.clone()))),
            Self::Var(var) => Expr::var(*var),
        }
    }
}

impl PrimarySlice {
    /// Given entities and a request, return a new entitity store
    /// which is a slice of the old one.
    fn slice_entities(
        &self,
        entities: &Entities,
        request: &Request,
    ) -> Result<Entities, EntitySliceError> {
        let mut res = HashMap::<EntityUID, Entity>::new();
        for (root, slice) in &self.trie {
            match root {
                EntityRoot::Literal(lit) => {
                    slice.slice_entity(entities, lit, &mut res)?;
                }
                EntityRoot::Var(Var::Action) => {
                    let entity_id = request
                        .action()
                        .uid()
                        .ok_or(EntitySliceError::PartialRequestError)?;
                    slice.slice_entity(entities, entity_id, &mut res)?;
                }
                EntityRoot::Var(Var::Principal) => {
                    let entity_id = request
                        .principal()
                        .uid()
                        .ok_or(EntitySliceError::PartialRequestError)?;
                    slice.slice_entity(entities, entity_id, &mut res)?;
                }
                EntityRoot::Var(Var::Resource) => {
                    let resource_id = request
                        .resource()
                        .uid()
                        .ok_or(EntitySliceError::PartialRequestError)?;
                    slice.slice_entity(entities, resource_id, &mut res)?;
                }
                EntityRoot::Var(Var::Context) => {
                    if slice.children.is_empty() {
                        // no data loading needed
                    } else {
                        let partial_val: PartialValue = PartialValue::from(
                            request
                                .context()
                                .ok_or(EntitySliceError::PartialRequestError)?
                                .clone(),
                        );
                        let PartialValue::Value(val) = partial_val else {
                            return Err(EntitySliceError::PartialRequestError);
                        };
                        slice.slice_val(entities, &val, &mut res);
                    }
                }
            }
        }
        Ok(Entities::from_entities(
            res.into_values(),
            None::<&NoEntitiesSchema>,
            TCComputation::AssumeAlreadyComputed,
            Extensions::all_available(),
        )?)
    }

    fn to_flat_primary_slice(&self) -> FlatPrimarySlice {
        let mut data: Vec<FlatEntitySlice> = vec![];

        for (root, slice) in &self.trie {
            for flattened in slice.to_flat_entity_slice(root) {
                data.push(flattened);
            }
        }

        FlatPrimarySlice { data }
    }

    /// Create an empty [`PrimarySlice`] that requires no data
    pub fn new() -> Self {
        Self {
            trie: Default::default(),
        }
    }
}

impl<T: Clone> PrimarySlice<T> {
    /// Union two [`PrimarySlice`]s together, requiring
    /// the data that both of them require
    fn union(&self, other: &Self) -> Self {
        let mut res = self.clone();
        for (key, value) in &other.trie {
            if let Some(existing) = res.trie.get(key) {
                res.trie.insert(key.clone(), (*existing).union(value));
            } else {
                res.trie.insert(key.clone(), value.clone());
            }
        }
        res
    }
}

impl Default for PrimarySlice {
    fn default() -> Self {
        Self::new()
    }
}

impl<T: Clone> EntitySlice<T> {
    /// Union two [`EntitySlice`]s together, requiring
    /// the data that both of them require
    fn union(&self, other: &Self) -> Self {
        Self {
            children: union_fields(&self.children, &other.children),
            parents_required: self.parents_required || other.parents_required,
            data: self.data.clone(),
        }
    }
}

impl EntitySlice {
    /// Given an entities store, an entity id, and a resulting store
    /// Slice the entities and put them in the resulting store.
    fn slice_entity(
        &self,
        entities: &Entities,
        lit: &EntityUID,
        res: &mut HashMap<EntityUID, Entity>,
    ) -> Result<(), EntitySliceError> {
        // If the entity is not present, no need to slice
        let Dereference::Data(entity) = entities.entity(lit) else {
            return Ok(());
        };
        let mut new_entity = HashMap::<SmolStr, PartialValue>::new();
        for (field, slice) in &self.children {
            // only slice when field is available
            if let Some(pval) = entity.get(field).cloned() {
                let PartialValue::Value(val) = pval else {
                    return Err(EntitySliceError::PartialEntity);
                };
                let sliced = slice.slice_val(entities, &val, res)?;

                new_entity.insert(field.clone(), PartialValue::Value(sliced));
            }
        }

        let new_ancestors = if self.parents_required {
            entity.ancestors().cloned().collect()
        } else {
            HashSet::new()
        };

        let new_entity =
            Entity::new_with_attr_partial_value(lit.clone(), new_entity, new_ancestors);

        #[allow(clippy::expect_used)]
        if let Some(existing) = res.get_mut(lit) {
            // Here we union the new entity with any existing one
            // PANIC SAFETY: Entities in the entity store with the same ID should be compatible to union together.
            *existing = existing
                .union(&new_entity)
                .expect("Incompatible values found in entity store");
        } else {
            res.insert(lit.clone(), new_entity);
        }
        Ok(())
    }

    fn slice_val(
        &self,
        entities: &Entities,
        val: &Value,
        res: &mut HashMap<EntityUID, Entity>,
    ) -> Result<Value, EntitySliceError> {
        // unless this is an entity id, parents should not be required
        assert!(
            !self.parents_required
                || matches!(val.value_kind(), ValueKind::Lit(Literal::EntityUID(_)))
        );

        Ok(match val.value_kind() {
            ValueKind::Lit(Literal::EntityUID(id)) => {
                self.slice_entity(entities, id, res)?;
                val.clone()
            }
            ValueKind::Set(_) | ValueKind::ExtensionValue(_) | ValueKind::Lit(_) => {
                if !self.children.is_empty() {
                    return Err(EntitySliceError::IncompatibleEntityManifest(val.clone()));
                }

                val.clone()
            }
            ValueKind::Record(record) => {
                let mut new_map = BTreeMap::<SmolStr, Value>::new();
                for (field, slice) in &self.children {
                    // only slice when field is available
                    if let Some(v) = record.get(field) {
                        new_map.insert(field.clone(), slice.slice_val(entities, v, res)?);
                    }
                }

                Value::new(ValueKind::record(new_map), None)
            }
        })
    }

    fn new() -> Self {
        Self {
            children: Default::default(),
            parents_required: false,
            data: (),
        }
    }

    fn to_flat_entity_slice(&self, root: &EntityRoot) -> Vec<FlatEntitySlice> {
        let mut flattened_reversed = self.flatten_reversed(root);
        for flattened in flattened_reversed.iter_mut() {
            flattened.path.reverse();
        }
        flattened_reversed
    }

    /// Builds a [`FlatEntitySlice`] in reversed order for efficient
    /// `push` operation.
    fn flatten_reversed(&self, root: &EntityRoot) -> Vec<FlatEntitySlice> {
        if self.children.is_empty() {
            vec![FlatEntitySlice {
                root: root.clone(),
                path: vec![],
                parents_required: false,
            }]
        } else {
            let mut res = vec![];
            for (key, value) in &self.children {
                for mut flattened in value.flatten_reversed(root) {
                    if flattened.parents_required {
                        res.push(flattened.clone());
                    }
                    flattened.path.push(key.clone());
                    flattened.parents_required = self.parents_required;
                    res.push(flattened);
                }
            }
            res
        }
    }
}

/// Computes an [`EntitySliceManifest`] from the schema and policies
pub fn compute_entity_slice_manifest(
    schema: &ValidatorSchema,
    policies: &PolicySet,
) -> Result<EntityManifest, EntitySliceError> {
    let mut manifest: HashMap<RequestType, PrimarySlice> = HashMap::new();

    // now, for each policy we add the data it requires to the manifest
    for policy in policies.policies() {
        // typecheck the policy and get all the request environments
        let typechecker = Typechecker::new(schema, ValidationMode::Strict, policy.id().clone());
        let request_envs = typechecker.typecheck_by_request_env(policy.template());
        for (request_env, policy_check) in request_envs {
            // match on the typechecking answer
            let new_primary_slice = match policy_check {
                PolicyCheck::Success(typechecked_expr) => compute_primary_slice(&typechecked_expr),
                PolicyCheck::Irrelevant(_) => {
                    // always results in false,
                    // so we need no data

                    Ok(PrimarySlice::new())
                }
                // TODO is returning the first error correct?
                // Also, should we run full validation instead of just
                // typechecking?
                PolicyCheck::Fail(errors) => {
                    // PANIC SAFETY policy check fail
                    // should be a non-empty vector.
                    #[allow(clippy::expect_used)]
                    Err(errors
                        .first()
                        .expect("Policy check failed without an error")
                        .clone()
                        .into())
                }
            }?;

            let request_types = request_env
                .to_request_types()
                .ok_or(EntitySliceError::PartialRequestError)?;
            if let Some(existing) = manifest.get_mut(&request_types) {
                *existing = existing.union(&new_primary_slice);
            } else {
                manifest.insert(request_types, new_primary_slice);
            }
        }
    }

    Ok(EntityManifest {
        per_action: manifest,
    })
}

fn compute_primary_slice(expr: &Expr<Option<Type>>) -> Result<PrimarySlice, EntitySliceError> {
    let mut primary_slice = PrimarySlice::new();
    add_to_primary_slice(&mut primary_slice, expr, false)?;
    Ok(primary_slice)
}

fn add_to_primary_slice(
    primary_slice: &mut PrimarySlice,
    expr: &Expr<Option<Type>>,
    should_load_all: bool,
) -> Result<(), EntitySliceError> {
    match expr.expr_kind() {
        // Literals, variables, and unkonwns without any GetAttr operations
        // on them are okay, since no fields need to be loaded.
        ExprKind::Lit(_) => (),
        ExprKind::Var(_) => (),
        ExprKind::Slot(_) => (),
        ExprKind::Unknown(_) => return Err(EntitySliceError::PartialExpressionError),
        ExprKind::If {
            test_expr,
            then_expr,
            else_expr,
        } => {
            add_to_primary_slice(primary_slice, test_expr, should_load_all)?;
            add_to_primary_slice(primary_slice, then_expr, should_load_all)?;
            add_to_primary_slice(primary_slice, else_expr, should_load_all)?;
        }
        ExprKind::And { left, right } => {
            add_to_primary_slice(primary_slice, left, should_load_all)?;
            add_to_primary_slice(primary_slice, right, should_load_all)?;
        }
        ExprKind::Or { left, right } => {
            add_to_primary_slice(primary_slice, left, should_load_all)?;
            add_to_primary_slice(primary_slice, right, should_load_all)?;
        }
        // For unary and binary operations, we need to be careful
        // to remain sound.
        // For example, equality requires that we pull all data
        ExprKind::UnaryApp { op, arg } => match op {
            UnaryOp::Not => add_to_primary_slice(primary_slice, arg, should_load_all)?,
            UnaryOp::Neg => add_to_primary_slice(primary_slice, arg, should_load_all)?,
        },
        ExprKind::BinaryApp { op, arg1, arg2 } => match op {
            BinaryOp::Eq => {
                add_to_primary_slice(primary_slice, arg1, true)?;
                add_to_primary_slice(primary_slice, arg1, true)?;
            }
            BinaryOp::In => {
                // add arg2 to primary slice
                add_to_primary_slice(primary_slice, arg2, should_load_all)?;

                // get the path for arg1
                let mut flat_slice = get_expr_path(arg1)?;
                flat_slice.parents_required = true;
                *primary_slice = primary_slice.union(&flat_slice.to_primary_slice());
            }
            BinaryOp::Contains | BinaryOp::ContainsAll | BinaryOp::ContainsAny => {
                add_to_primary_slice(primary_slice, arg1, true)?;
                add_to_primary_slice(primary_slice, arg2, true)?;
            }
            BinaryOp::Less | BinaryOp::LessEq | BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul => {
                add_to_primary_slice(primary_slice, arg1, should_load_all)?;
                add_to_primary_slice(primary_slice, arg2, should_load_all)?;
            }
        },
        ExprKind::ExtensionFunctionApp { fn_name: _, args } => {
            // WARNING: this code assumes that extension functions
            // don't take full structs as inputs.
            // If they did, we would need to use logic similar to the Eq binary operator.
            for arg in args.iter() {
                add_to_primary_slice(primary_slice, arg, should_load_all)?;
            }
        }
        ExprKind::Like { expr, pattern: _ } => {
            add_to_primary_slice(primary_slice, expr, should_load_all)?;
        }
        ExprKind::Is {
            expr,
            entity_type: _,
        } => {
            add_to_primary_slice(primary_slice, expr, should_load_all)?;
        }
        ExprKind::Set(contents) => {
            for expr in &**contents {
                add_to_primary_slice(primary_slice, expr, should_load_all)?;
            }
        }
        ExprKind::Record(content) => {
            for expr in content.values() {
                add_to_primary_slice(primary_slice, expr, should_load_all)?;
            }
        }
        ExprKind::HasAttr { expr, attr } => {
            let mut flat_slice = get_expr_path(expr)?;
            flat_slice.path.push(attr.clone());
            *primary_slice = primary_slice.union(&flat_slice.to_primary_slice());
        }
        ExprKind::GetAttr { .. } => {
            let flat_slice = get_expr_path(expr)?;

            #[allow(clippy::expect_used)]
            let leaf_field = if should_load_all {
                entity_slice_from_type(
                    expr.data()
                        .as_ref()
                        .expect("Typechecked expression missing type"),
                )
            } else {
                EntitySlice::new()
            };

            *primary_slice = flat_slice.to_primary_slice_with_leaf(leaf_field);
        }
    };

    Ok(())
}

fn full_tree_for_entity_or_record(ty: &EntityRecordKind) -> Fields<()> {
    match ty {
        EntityRecordKind::ActionEntity { name: _, attrs }
        | EntityRecordKind::Record {
            attrs,
            open_attributes: _,
        } => {
            let mut fields = HashMap::new();
            for (attr_name, attr_type) in attrs.iter() {
                fields.insert(
                    attr_name.clone(),
                    Box::new(entity_slice_from_type(&attr_type.attr_type)),
                );
            }
            fields
        }

        EntityRecordKind::Entity(_) | EntityRecordKind::AnyEntity => {
            // no need to load data for entities, which are compared
            // using ids
            Default::default()
        }
    }
}

fn entity_slice_from_type(ty: &Type) -> EntitySlice {
    match ty {
        // if it's not an entity or record, slice ends here
        Type::ExtensionType { .. }
        | Type::Never
        | Type::True
        | Type::False
        | Type::Primitive { .. }
        | Type::Set { .. } => EntitySlice::new(),
        Type::EntityOrRecord(record_type) => EntitySlice {
            children: full_tree_for_entity_or_record(record_type),
            parents_required: false,
            data: (),
        },
    }
}

/// Given an expression, get the corresponding data path
/// starting with a variable.
fn get_expr_path(expr: &Expr<Option<Type>>) -> Result<FlatEntitySlice, EntitySliceError> {
    Ok(match expr.expr_kind() {
        ExprKind::Slot(slot_id) => {
            if slot_id.is_principal() {
                FlatEntitySlice {
                    root: EntityRoot::Var(Var::Principal),
                    path: vec![],
                    parents_required: false,
                }
            } else {
                assert!(slot_id.is_resource());
                FlatEntitySlice {
                    root: EntityRoot::Var(Var::Resource),
                    path: vec![],
                    parents_required: false,
                }
            }
        }
        ExprKind::Var(var) => FlatEntitySlice {
            root: EntityRoot::Var(*var),
            path: vec![],
            parents_required: false,
        },
        ExprKind::GetAttr { expr, attr } => {
            let mut slice = get_expr_path(expr)?;
            slice.path.push(attr.clone());
            slice
        }
        ExprKind::Lit(Literal::EntityUID(literal)) => FlatEntitySlice {
            root: EntityRoot::Literal((**literal).clone()),
            path: vec![],
            parents_required: false,
        },
        _ => Err(EntitySliceError::FailedAnalysis)?,
    })
}

/// Loads all the entities needed for a request given a function
/// that loads an entire entity by id.
/// Assumes that the entire context will be loaded separately.
/// TODO make not public
pub fn load_entities_simplified(
    //schema: &ValidatorSchema,
    manifest: &EntityManifest,
    request: &Request,
    loader: &mut impl FnMut(&[&EntityUID]) -> Vec<Entity>,
) -> Result<Entities, EntitySliceError> {
    let Some(primary_slice) = manifest.per_action.get(
        &request
            .to_concrete_env()
            .ok_or(EntitySliceError::PartialRequestError)?,
    ) else {
        // if the request type isn't in the manifest, we need no data
        return Entities::from_entities(
            vec![],
            None::<&NoEntitiesSchema>,
            TCComputation::AssumeAlreadyComputed,
            Extensions::all_available(),
        )
        .map_err(|err| err.into());
    };

    let mut entities: HashMap<EntityUID, Entity, RandomState> = Default::default();

    for (key, value) in &primary_slice.trie {
        match key {
            EntityRoot::Var(Var::Principal) => {
                load_entity_slice(
                    loader,
                    &mut entities,
                    request
                        .principal()
                        .uid()
                        .ok_or(EntitySliceError::PartialRequestError)?,
                    value,
                )?;
            }
            EntityRoot::Var(Var::Action) => {
                load_entity_slice(
                    loader,
                    &mut entities,
                    request
                        .action()
                        .uid()
                        .ok_or(EntitySliceError::PartialRequestError)?,
                    value,
                )?;
            }
            EntityRoot::Var(Var::Resource) => {
                load_entity_slice(
                    loader,
                    &mut entities,
                    request
                        .resource()
                        .uid()
                        .ok_or(EntitySliceError::PartialRequestError)?,
                    value,
                )?;
            }
            EntityRoot::Literal(lit) => {
                load_entity_slice(loader, &mut entities, lit, value)?;
            }
            EntityRoot::Var(Var::Context) => {
                // skip context, since the simplified loader assumes the entire context is loaded
            }
        }
    }

    Entities::from_entities(
        entities.values().cloned(),
        None::<&NoEntitiesSchema>,
        TCComputation::AssumeAlreadyComputed,
        Extensions::all_available(),
    )
    .map_err(|err| err.into())
}

fn load_entity_slice(
    loader: &mut impl FnMut(&[&EntityUID]) -> Vec<Entity>,
    entities: &mut HashMap<EntityUID, Entity, RandomState>,
    entity: &EntityUID,
    slice: &EntitySlice,
) -> Result<(), EntitySliceError> {
    // special case: no need to load anything for empty fields with no parents required
    if slice.children.is_empty() && !slice.parents_required {
        return Ok(());
    }

    let new_entities = loader(&[entity]);
    if new_entities.len() != 1 {
        return Err(EntitySliceError::WrongNumberOfEntities(
            1,
            new_entities.len(),
        ));
    }
    #[allow(clippy::expect_used)]
    let new_entity = new_entities
        .into_iter()
        .next()
        .expect("Vector has length 1 as shown by if statement above.");

    // now we need to load any entity references
    let remaining_entities = find_remaining_entities(&new_entity, &slice.children);

    for (id, slice) in remaining_entities? {
        load_entity_slice(loader, entities, &id, &slice)?;
    }

    // TODO also need to load parents of some entities

    entities.insert(new_entity.uid().clone(), new_entity);
    Ok(())
}

/// This helper function finds all entity references that need to be
/// loaded given an already-loaded [`Entity`] and corresponding [`Fields`].
/// Returns pairs of entity and slices that need to be loaded.
pub fn find_remaining_entities(
    entity: &Entity,
    fields: &Fields<()>,
) -> Result<HashMap<EntityUID, EntitySlice>, EntitySliceError> {
    let mut remaining = HashMap::new();
    for (field, slice) in fields {
        if let Some(pvalue) = entity.get(field) {
            let PartialValue::Value(value) = pvalue else {
                return Err(EntitySliceError::PartialEntity);
            };
            find_remaining_entities_value(&mut remaining, value, slice)?;
        }
    }

    Ok(remaining)
}

fn find_remaining_entities_value(
    remaining: &mut HashMap<EntityUID, EntitySlice>,
    value: &Value,
    slice: &EntitySlice,
) -> Result<(), EntitySliceError> {
    match value.value_kind() {
        ValueKind::Lit(literal) => match literal {
            Literal::EntityUID(entity_id) => {
                if let Some(existing) = remaining.get_mut(entity_id) {
                    *existing = existing.union(slice);
                } else {
                    remaining.insert((**entity_id).clone(), slice.clone());
                }
            }
            _ => assert!(slice.children.is_empty()),
        },
        ValueKind::Set(_) => {
            assert!(slice.children.is_empty());
        }
        ValueKind::ExtensionValue(_) => {
            assert!(slice.children.is_empty());
        }
        ValueKind::Record(record) => {
            for (field, child_slice) in &slice.children {
                // only need to slice if field is present
                if let Some(value) = record.get(field) {
                    find_remaining_entities_value(remaining, value, child_slice)?;
                }
            }
        }
    };
    Ok(())
}

#[cfg(test)]
mod entity_slice_tests {
    use cedar_policy_core::{ast::{Context, PolicyID}, entities::EntityJsonParser, parser::parse_policy};

    use crate::CoreSchema;

    use super::*;

    fn expect_entity_slice_to(
        original: serde_json::Value,
        expected: serde_json::Value,
        schema: &ValidatorSchema,
        manifest: &EntityManifest,
    ) {
        let request = Request::new(
            (
                EntityUID::with_eid_and_type("User", "oliver").unwrap(),
                None,
            ),
            (
                EntityUID::with_eid_and_type("Action", "Read").unwrap(),
                None,
            ),
            (
                EntityUID::with_eid_and_type("Document", "dummy").unwrap(),
                None,
            ),
            Context::empty(),
            Some(schema),
            Extensions::all_available(),
        )
        .unwrap();

        let schema = CoreSchema::new(schema);
        let parser: EntityJsonParser<'_, '_, CoreSchema<'_>> = EntityJsonParser::new(
            Some(&schema),
            Extensions::all_available(),
            TCComputation::AssumeAlreadyComputed,
        );
        let original_entities = parser.from_json_value(original).unwrap();

        // Entity slicing results in invalid entity stores
        // since attributes may be missing.
        let parser_without_validation: EntityJsonParser<'_, '_> = EntityJsonParser::new(
            None,
            Extensions::all_available(),
            TCComputation::AssumeAlreadyComputed,
        );
        let expected_entities = parser_without_validation.from_json_value(expected).unwrap();

        let sliced_entities = manifest
            .slice_entities(&original_entities, &request)
            .unwrap();

        #[allow(clippy::panic)]
        if !sliced_entities.deep_equal(&expected_entities) {
            panic!(
                "Sliced entities differed from expected. Expected:\n{}\nGot:\n{}",
                expected_entities.to_json_value().unwrap(),
                sliced_entities.to_json_value().unwrap()
            );
        }
    }

    #[test]
    fn test_simple_entity_manifest() {
        let mut pset = PolicySet::new();
        let policy = parse_policy(
            None,
            "permit(principal, action, resource)
when {
    principal.name == \"John\"
};",
        )
        .expect("should succeed");
        pset.add(policy.into()).expect("should succeed");

        let schema = ValidatorSchema::from_str_natural(
            "
entity User = {
  name: String,
};

entity Document;

action Read appliesTo {
  principal: [User],
  resource: [Document]
};
        ",
            Extensions::all_available(),
        )
        .unwrap()
        .0;

        let entity_manifest =
            compute_entity_slice_manifest(&schema, &pset).expect("Should succeed");
        let expected = r#"
{
  "per_action": [
    [
      {
        "principal": "User",
        "action": {
          "ty": "Action",
          "eid": "Read"
        },
        "resource": "Document"
      },
      {
        "trie": [
          [
            {
              "Var": "principal"
            },
            {
              "children": [
                [
                  "name",
                  {
                    "children": [],
                    "parents_required": false
                  }
                ]
              ],
              "parents_required": false
            }
          ]
        ]
      }
    ]
  ]
}"#;
        let expected_manifest = serde_json::from_str(expected).unwrap();
        assert_eq!(entity_manifest, expected_manifest);

        let entities_json = serde_json::json!(
            [
                {
                    "uid" : { "type" : "User", "id" : "oliver"},
                    "attrs" : {
                        "name" : "Oliver"
                    },
                    "parents" : []
                },
                {
                    "uid" : { "type" : "User", "id" : "oliver2"},
                    "attrs" : {
                        "name" : "Oliver2"
                    },
                    "parents" : []
                },
            ]
        );

        let expected_entities_json = serde_json::json!(
            [
                {
                    "uid" : { "type" : "User", "id" : "oliver"},
                    "attrs" : {
                        "name" : "Oliver"
                    },
                    "parents" : []
                },
            ]
        );

        expect_entity_slice_to(
            entities_json,
            expected_entities_json,
            &schema,
            &expected_manifest,
        );
    }

    #[test]
    #[should_panic]
    fn sanity_test_empty_entity_manifest() {
        let mut pset = PolicySet::new();
        let policy =
            parse_policy(None, "permit(principal, action, resource);").expect("should succeed");
        pset.add(policy.into()).expect("should succeed");

        let schema = ValidatorSchema::from_str_natural(
            "
entity User = {
  name: String,
};

entity Document;

action Read appliesTo {
  principal: [User],
  resource: [Document]
};
        ",
            Extensions::all_available(),
        )
        .unwrap()
        .0;

        let entity_manifest =
            compute_entity_slice_manifest(&schema, &pset).expect("Should succeed");
        let expected = r#"
{
  "per_action": [
    [
      {
        "principal": "User",
        "action": {
          "ty": "Action",
          "eid": "Read"
        },
        "resource": "Document"
      },
      {
        "trie": [
        ]
      }
    ]
  ]
}"#;
        let expected_manifest = serde_json::from_str(expected).unwrap();
        assert_eq!(entity_manifest, expected_manifest);

        let entities_json = serde_json::json!(
            [
                {
                    "uid" : { "type" : "User", "id" : "oliver"},
                    "attrs" : {
                        "name" : "Oliver"
                    },
                    "parents" : []
                },
                {
                    "uid" : { "type" : "User", "id" : "oliver2"},
                    "attrs" : {
                        "name" : "Oliver2"
                    },
                    "parents" : []
                },
            ]
        );

        let expected_entities_json = serde_json::json!([
            {
                "uid" : { "type" : "User", "id" : "oliver"},
                "attrs" : {
                    "name" : "Oliver"
                },
                "parents" : []
            },
            {
                "uid" : { "type" : "User", "id" : "oliver2"},
                "attrs" : {
                    "name" : "Oliver2"
                },
                "parents" : []
            },
        ]);

        expect_entity_slice_to(
            entities_json,
            expected_entities_json,
            &schema,
            &expected_manifest,
        );
    }

    #[test]
    fn test_empty_entity_manifest() {
        let mut pset = PolicySet::new();
        let policy =
            parse_policy(None, "permit(principal, action, resource);").expect("should succeed");
        pset.add(policy.into()).expect("should succeed");

        let schema = ValidatorSchema::from_str_natural(
            "
entity User = {
  name: String,
};

entity Document;

action Read appliesTo {
  principal: [User],
  resource: [Document]
};
        ",
            Extensions::all_available(),
        )
        .unwrap()
        .0;

        let entity_manifest =
            compute_entity_slice_manifest(&schema, &pset).expect("Should succeed");
        let expected = r#"
{
  "per_action": [
    [
      {
        "principal": "User",
        "action": {
          "ty": "Action",
          "eid": "Read"
        },
        "resource": "Document"
      },
      {
        "trie": [
        ]
      }
    ]
  ]
}"#;
        let expected_manifest = serde_json::from_str(expected).unwrap();
        assert_eq!(entity_manifest, expected_manifest);

        let entities_json = serde_json::json!(
            [
                {
                    "uid" : { "type" : "User", "id" : "oliver"},
                    "attrs" : {
                        "name" : "Oliver"
                    },
                    "parents" : []
                },
                {
                    "uid" : { "type" : "User", "id" : "oliver2"},
                    "attrs" : {
                        "name" : "Oliver2"
                    },
                    "parents" : []
                },
            ]
        );

        let expected_entities_json = serde_json::json!([]);

        expect_entity_slice_to(
            entities_json,
            expected_entities_json,
            &schema,
            &expected_manifest,
        );
    }

    #[test]
    fn test_entity_manifest_parents_required() {
        let mut pset = PolicySet::new();
        let policy = parse_policy(
            None,
            "permit(principal, action, resource)
when {
    principal in resource || principal.manager in resource
};",
        )
        .expect("should succeed");
        pset.add(policy.into()).expect("should succeed");

        let schema = ValidatorSchema::from_str_natural(
            "
entity User in [Document] = {
  name: String,
  manager: User
};

entity Document;

action Read appliesTo {
  principal: [User],
  resource: [Document]
};
        ",
            Extensions::all_available(),
        )
        .unwrap()
        .0;

        let entity_manifest =
            compute_entity_slice_manifest(&schema, &pset).expect("Should succeed");
        let expected = r#"
{
  "per_action": [
    [
      {
        "principal": "User",
        "action": {
          "ty": "Action",
          "eid": "Read"
        },
        "resource": "Document"
      },
      {
        "trie": [
          [
            {
              "Var": "principal"
            },
            {
              "children": [
                [
                  "manager",
                  {
                    "children": [],
                    "parents_required": true
                  }
                ]
              ],
              "parents_required": true
            }
          ]
        ]
      }
    ]
  ]
}"#;
        let expected_manifest = serde_json::from_str(expected).unwrap();
        assert_eq!(entity_manifest, expected_manifest);

        let entities_json = serde_json::json!(
            [
                {
                    "uid" : { "type" : "User", "id" : "oliver"},
                    "attrs" : {
                        "name" : "Oliver",
                        "manager": { "type" : "User", "id" : "george"}
                    },
                    "parents" : [
                        { "type" : "Document", "id" : "oliverdocument"}
                    ]
                },
                {
                    "uid" : { "type" : "User", "id" : "george"},
                    "attrs" : {
                        "name" : "George",
                        "manager": { "type" : "User", "id" : "george"}
                    },
                    "parents" : [
                        { "type" : "Document", "id" : "georgedocument"}
                    ]
                },
            ]
        );

        let expected_entities_json = serde_json::json!(
            [
                {
                    "uid" : { "type" : "User", "id" : "oliver"},
                    "attrs" : {
                        "manager": { "__entity": { "type" : "User", "id" : "george"} }
                    },
                    "parents" : [
                        { "type" : "Document", "id" : "oliverdocument"}
                    ]
                },
                {
                    "uid" : { "type" : "User", "id" : "george"},
                    "attrs" : {
                    },
                    "parents" : [
                        { "type" : "Document", "id" : "georgedocument"}
                    ]
                },
            ]
        );

        expect_entity_slice_to(
            entities_json,
            expected_entities_json,
            &schema,
            &expected_manifest,
        );
    }

    #[test]
    fn test_entity_manifest_multiple_types() {
        let mut pset = PolicySet::new();
        let policy = parse_policy(
            None,
            "permit(principal, action, resource)
when {
    principal.name == \"John\"
};",
        )
        .expect("should succeed");
        pset.add(policy.into()).expect("should succeed");

        let schema = ValidatorSchema::from_str_natural(
            "
entity User = {
  name: String,
};

entity OtherUserType = {
  name: String,
  irrelevant: String,
};

entity Document;

action Read appliesTo {
  principal: [User, OtherUserType],
  resource: [Document]
};
        ",
            Extensions::all_available(),
        )
        .unwrap()
        .0;

        let entity_manifest =
            compute_entity_slice_manifest(&schema, &pset).expect("Should succeed");
        let expected = r#"
{
  "per_action": [
    [
      {
        "principal": "User",
        "action": {
          "ty": "Action",
          "eid": "Read"
        },
        "resource": "Document"
      },
      {
        "trie": [
          [
            {
              "Var": "principal"
            },
            {
              "children": [
                [
                  "name",
                  {
                    "children": [],
                    "parents_required": false
                  }
                ]
              ],
              "parents_required": false
            }
          ]
        ]
      }
    ],
    [
      {
        "principal": "OtherUserType",
        "action": {
          "ty": "Action",
          "eid": "Read"
        },
        "resource": "Document"
      },
      {
        "trie": [
          [
            {
              "Var": "principal"
            },
            {
              "children": [
                [
                  "name",
                  {
                    "children": [],
                    "parents_required": false
                  }
                ]
              ],
              "parents_required": false
            }
          ]
        ]
      }
    ]
  ]
}"#;
        let expected_manifest = serde_json::from_str(expected).unwrap();
        assert_eq!(entity_manifest, expected_manifest);
    }

    #[test]
    fn test_entity_manifest_multiple_branches() {
        let mut pset = PolicySet::new();
        let policy1 = parse_policy(
            None,
            r#"
permit(
  principal,
  action == Action::"Read",
  resource
)
when
{
  resource.readers.contains(principal)
};"#,
        )
        .unwrap();
        let policy2 = parse_policy(
            Some(PolicyID::from_string("Policy2")),
            r#"permit(
  principal,
  action == Action::"Read",
  resource
)
when
{
  resource.metadata.owner == principal
};"#,
        )
        .unwrap();
        pset.add(policy1.into()).expect("should succeed");
        pset.add(policy2.into()).expect("should succeed");

        let schema = ValidatorSchema::from_str_natural(
            "
entity User;

entity Metadata = {
   owner: User,
   time: String,
};

entity Document = {
  metadata: Metadata,
  readers: Set<User>,
};

action Read appliesTo {
  principal: [User],
  resource: [Document]
};
        ",
            Extensions::all_available(),
        )
        .unwrap()
        .0;

        let entity_manifest =
            compute_entity_slice_manifest(&schema, &pset).expect("Should succeed");
        let expected = r#"
{
  "per_action": [
    [
      {
        "principal": "User",
        "action": {
          "ty": "Action",
          "eid": "Read"
        },
        "resource": "Document"
      },
      {
        "trie": [
          [
            {
              "Var": "resource"
            },
            {
              "children": [
                [
                  "metadata",
                  {
                    "children": [
                      [
                        "owner",
                        {
                          "children": [],
                          "parents_required": false
                        }
                      ]
                    ],
                    "parents_required": false
                  }
                ],
                [
                  "readers",
                  {
                    "children": [],
                    "parents_required": false
                  }
                ]
              ],
              "parents_required": false
            }
          ]
        ]
      }
    ]
  ]
}"#;
        let expected_manifest = serde_json::from_str(expected).unwrap();
        assert_eq!(entity_manifest, expected_manifest);

        let entities_json = serde_json::json!(
            [
                {
                    "uid" : { "type" : "User", "id" : "oliver"},
                    "attrs" : {
                    },
                    "parents" : [
                    ]
                },
                {
                    "uid": { "type": "Document", "id": "dummy"},
                    "attrs": {
                        "metadata": { "type": "Metadata", "id": "olivermetadata"},
                        "readers": [{"type": "User", "id": "oliver"}]
                    },
                    "parents": [],
                },
                {
                    "uid": { "type": "Metadata", "id": "olivermetadata"},
                    "attrs": {
                        "owner": { "type": "User", "id": "oliver"},
                        "time": "now"
                    },
                    "parents": [],
                },
            ]
        );

        let expected_entities_json = serde_json::json!(
            [
                {
                    "uid": { "type": "Document", "id": "dummy"},
                    "attrs": {
                        "metadata": {"__entity": { "type": "Metadata", "id": "olivermetadata"}},
                        "readers": [{ "__entity": {"type": "User", "id": "oliver"}}]
                    },
                    "parents": [],
                },
                {
                    "uid": { "type": "Metadata", "id": "olivermetadata"},
                    "attrs": {
                        "owner": {"__entity": { "type": "User", "id": "oliver"}},
                    },
                    "parents": [],
                },
                {
                    "uid" : { "type" : "User", "id" : "oliver"},
                    "attrs" : {
                    },
                    "parents" : [
                    ]
                },
            ]
        );

        expect_entity_slice_to(
            entities_json,
            expected_entities_json,
            &schema,
            &expected_manifest,
        );
    }

    #[test]
    fn test_entity_manifest_struct_equality() {
        let mut pset = PolicySet::new();
        // we need to load all of the metadata, not just nickname
        // no need to load actual name
        let policy = parse_policy(
            None,
            r#"permit(principal, action, resource)
when {
    principal.metadata.nickname == "timmy" && principal.metadata == {
        "friends": [ "oliver" ],
        "nickname": "timmy"
    }
};"#,
        )
        .expect("should succeed");
        pset.add(policy.into()).expect("should succeed");

        let schema = ValidatorSchema::from_str_natural(
            "
entity User = {
  name: String,
  metadata: {
    friends: Set<String>,
    nickname: String,
  },
};

entity Document;

action BeSad appliesTo {
  principal: [User],
  resource: [Document]
};
        ",
            Extensions::all_available(),
        )
        .unwrap()
        .0;

        let entity_manifest =
            compute_entity_slice_manifest(&schema, &pset).expect("Should succeed");
        let expected = r#"
{
  "per_action": [
    [
      {
        "principal": "User",
        "action": {
          "ty": "Action",
          "eid": "BeSad"
        },
        "resource": "Document"
      },
      {
        "trie": [
          [
            {
              "Var": "principal"
            },
            {
              "children": [
                [
                  "metadata",
                  {
                    "children": [
                      [
                        "nickname",
                        {
                          "children": [],
                          "parents_required": false
                        }
                      ],
                      [
                        "friends",
                        {
                          "children": [],
                          "parents_required": false
                        }
                      ]
                    ],
                    "parents_required": false
                  }
                ]
              ],
              "parents_required": false
            }
          ]
        ]
      }
    ]
  ]
}"#;
        let expected_manifest = serde_json::from_str(expected).unwrap();
        assert_eq!(entity_manifest, expected_manifest);
    }
}
