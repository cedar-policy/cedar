/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! Conversions from CST to AST
//!
//! This module contains functions to convert Nodes containing CST items into
//! AST items. It works with the parser CST output, where all nodes are optional.
//!
//! An important aspect of the transformation is to provide as many errors as
//! possible to expedite development cycles. To the purpose, an error parameter
//! must be passed to each function, to collect the potentially multiple errors.
//! `Option::None` is used to signify that errors were present, and any new
//! messages will be appended to the error parameter. Messages are not added when
//! they are assumed to have already been added, like when a sub-conversion fails
//! or the CST node was `None`, signifying a parse failure with associated message.

// Throughout this module parameters to functions are references to CSTs or
// owned AST items. This allows the most flexibility and least copying of data.
// CSTs are almost entirely rewritten to ASTs, so we keep those values intact
// and only clone the identifiers inside. ASTs here are temporary values until
// the data passes out of the module, so we deconstruct them freely in the few
// cases where there is a secondary conversion. This prevents any further
// cloning.

use super::cst;
use super::err::{
    self, ParseError, ParseErrors, Ref, RefCreationError, ToASTError, ToASTErrorKind,
};
use super::loc::Loc;
use super::node::Node;
use super::unescape::{to_pattern, to_unescaped_string};
use crate::ast::{
    self, ActionConstraint, CallStyle, EntityReference, EntityType, EntityUID, Integer,
    PatternElem, PolicySetError, PrincipalConstraint, PrincipalOrResourceConstraint,
    ResourceConstraint,
};
use crate::est::extract_single_argument;
use itertools::{Either, Itertools};
use smol_str::SmolStr;
use std::cmp::Ordering;
use std::collections::{BTreeMap, HashSet};
use std::mem;
use std::sync::Arc;

// Local re-definition for convenience
type ToASTErrors = Vec<ToASTError>;

// for storing extension function names per callstyle
struct ExtStyles<'a> {
    functions: HashSet<&'a ast::Name>,
    methods: HashSet<&'a str>,
}

// Store extension function call styles
lazy_static::lazy_static! {
    static ref EXTENSION_STYLES: ExtStyles<'static> = load_styles();
}
fn load_styles() -> ExtStyles<'static> {
    let mut functions = HashSet::new();
    let mut methods = HashSet::new();
    for func in crate::extensions::Extensions::all_available().all_funcs() {
        match func.style() {
            CallStyle::FunctionStyle => functions.insert(func.name()),
            CallStyle::MethodStyle => methods.insert(func.name().basename().as_ref()),
        };
    }
    ExtStyles { functions, methods }
}

impl Node<Option<cst::Policies>> {
    /// Iterate over the `Policy` nodes in this `cst::Policies`, with
    /// corresponding generated `PolicyID`s
    pub fn with_generated_policyids(
        &self,
    ) -> Result<impl Iterator<Item = (ast::PolicyID, &Node<Option<cst::Policy>>)>, ParseErrors>
    {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let policies = self.ok_or_missing()?;

        Ok(policies
            .0
            .iter()
            .enumerate()
            .map(|(count, node)| (ast::PolicyID::from_string(format!("policy{count}")), node)))
    }

    /// convert `cst::Policies` to `ast::PolicySet`
    pub fn to_policyset(&self) -> Result<ast::PolicySet, ParseErrors> {
        let mut pset = ast::PolicySet::new();
        let mut all_errs: Vec<ParseErrors> = vec![];
        // Caution: `parser::parse_policyset_and_also_return_policy_text()`
        // depends on this function returning a policy set with `PolicyID`s as
        // generated by `with_generated_policyids()` to maintain an invariant.
        for (policy_id, policy) in self.with_generated_policyids()? {
            // policy may have convert error
            match policy.to_policy_or_template(policy_id) {
                Ok(Either::Right(template)) => {
                    if let Err(e) = pset.add_template(template) {
                        match e {
                            PolicySetError::Occupied { id } => {
                                all_errs.push(ParseErrors::singleton(
                                    self.to_ast_err(ToASTErrorKind::DuplicateTemplateId(id)),
                                ))
                            }
                        };
                    }
                }
                Ok(Either::Left(inline_policy)) => {
                    if let Err(e) = pset.add_static(inline_policy) {
                        match e {
                            PolicySetError::Occupied { id } => {
                                all_errs.push(ParseErrors::singleton(
                                    self.to_ast_err(ToASTErrorKind::DuplicatePolicyId(id)),
                                ))
                            }
                        };
                    }
                }
                Err(errs) => {
                    all_errs.push(errs);
                }
            };
        }

        // fail on any error
        match all_errs.split_first() {
            None => Ok(pset),
            Some((first, rest)) => {
                let mut first = first.clone();
                rest.iter()
                    .for_each(|errs| first.extend(errs.iter().cloned()));
                Err(first)
            }
        }
    }
}

impl Node<Option<cst::Policy>> {
    /// Convert `cst::Policy` to an AST `InlinePolicy` or `Template`
    pub fn to_policy_or_template(
        &self,
        id: ast::PolicyID,
    ) -> Result<Either<ast::StaticPolicy, ast::Template>, ParseErrors> {
        let t = self.to_policy_template(id)?;
        if t.slots().count() == 0 {
            // PANIC SAFETY: A `Template` with no slots will successfully convert to a `StaticPolicy`
            #[allow(clippy::expect_used)]
            let p = ast::StaticPolicy::try_from(t).expect("internal invariant violation: a template with no slots should be a valid static policy");
            Ok(Either::Left(p))
        } else {
            Ok(Either::Right(t))
        }
    }

    /// Convert `cst::Policy` to an AST `InlinePolicy`. (Will fail if the CST is for a template)
    pub fn to_policy(&self, id: ast::PolicyID) -> Result<ast::StaticPolicy, ParseErrors> {
        let maybe_template = self.to_policy_template(id);
        let maybe_policy = maybe_template.map(ast::StaticPolicy::try_from);
        match maybe_policy {
            // Successfully parsed a static policy
            Ok(Ok(p)) => Ok(p),
            // The source parsed as a template, but not a static policy
            Ok(Err(ast::UnexpectedSlotError::FoundSlot(slot))) => {
                Err(ParseErrors::singleton(ToASTError::new(
                    ToASTErrorKind::UnexpectedTemplate {
                        slot: slot.id.into(),
                    },
                    slot.loc.unwrap_or_else(|| self.loc.clone()),
                )))
            }
            // The source failed to parse completely. If the parse errors include
            // `SlotsInConditionClause` also add an `UnexpectedTemplate` error.
            Err(mut errs) => {
                let new_errs = errs
                    .iter()
                    .filter_map(|err| match err {
                        ParseError::ToAST(err) => match err.kind() {
                            ToASTErrorKind::SlotsInConditionClause { slot, .. } => {
                                Some(ToASTError::new(
                                    ToASTErrorKind::UnexpectedTemplate { slot: slot.clone() },
                                    err.source_loc().clone(),
                                ))
                            }
                            _ => None,
                        },
                        _ => None,
                    })
                    .collect::<Vec<_>>();
                errs.extend(new_errs);
                Err(errs)
            }
        }
    }

    /// Convert `cst::Policy` to `ast::Template`. Works for inline policies as
    /// well, which will become templates with 0 slots
    pub fn to_policy_template(&self, id: ast::PolicyID) -> Result<ast::Template, ParseErrors> {
        let policy = self.ok_or_missing()?;
        let mut errs = vec![];

        // convert effect
        let maybe_effect = policy.effect.to_effect(&mut errs);

        // convert annotations
        let (annot_success, annotations) = policy.get_ast_annotations(&mut errs);
        let mut failure = !annot_success;

        // convert scope
        let (maybe_principal, maybe_action, maybe_resource) = policy.extract_scope(&mut errs);

        // convert conditions
        let conds: Vec<_> = policy
            .conds
            .iter()
            .filter_map(|c| {
                let (e, is_when) = c.to_expr(&mut errs)?;
                for slot in e.slots() {
                    errs.push(ToASTError::new(
                        ToASTErrorKind::SlotsInConditionClause {
                            slot: slot.id.into(),
                            clausetype: if is_when { "when" } else { "unless" },
                        },
                        slot.loc.unwrap_or_else(|| c.loc.clone()),
                    ));
                }
                Some(e)
            })
            .collect();

        if conds.len() != policy.conds.len() {
            failure = true
        }

        // all data and errors are generated, so fail or construct result
        match (maybe_effect, maybe_principal, maybe_action, maybe_resource) {
            (Some(effect), Some(principal), Some(action), Some(resource))
                if !failure && errs.is_empty() =>
            {
                Ok(construct_template_policy(
                    id,
                    annotations,
                    effect,
                    principal,
                    action,
                    resource,
                    conds,
                    &self.loc,
                ))
            }
            _ => Err(errs.into()),
        }
    }
}

impl cst::Policy {
    /// get the scope constraints from the `cst::Policy`
    pub fn extract_scope(
        &self,
        errs: &mut ToASTErrors,
    ) -> (
        Option<PrincipalConstraint>,
        Option<ActionConstraint>,
        Option<ResourceConstraint>,
    ) {
        // Tracks where the last variable in the scope ended. We'll point to
        // this position to indicate where to fill in vars if we're missing one.
        let mut end_of_last_var = self.effect.loc.end();

        let mut vars = self.variables.iter().peekable();
        let principal = if let Some(scope1) = vars.next() {
            end_of_last_var = scope1.loc.end();
            scope1.to_principal_constraint(errs)
        } else {
            errs.push(ToASTError::new(
                ToASTErrorKind::MissingScopeConstraint(ast::Var::Principal),
                self.effect.loc.span(end_of_last_var),
            ));
            None
        };
        let action = if let Some(scope2) = vars.next() {
            end_of_last_var = scope2.loc.end();
            scope2.to_action_constraint(errs)
        } else {
            errs.push(ToASTError::new(
                ToASTErrorKind::MissingScopeConstraint(ast::Var::Action),
                self.effect.loc.span(end_of_last_var),
            ));
            None
        };
        let resource = if let Some(scope3) = vars.next() {
            scope3.to_resource_constraint(errs)
        } else {
            errs.push(ToASTError::new(
                ToASTErrorKind::MissingScopeConstraint(ast::Var::Resource),
                self.effect.loc.span(end_of_last_var),
            ));
            None
        };
        if vars.peek().is_some() {
            // Add each of the extra constraints to the error list
            // If the extra constraint is `None`, we've already added it to the error list
            for extra_var in vars {
                if let Some(def) = extra_var.as_inner() {
                    errs.push(
                        extra_var.to_ast_err(ToASTErrorKind::ExtraScopeConstraints(def.clone())),
                    )
                }
            }
        }
        (principal, action, resource)
    }

    /// Get the annotations on the `cst::Policy` as an `ast::Annotations`.
    /// This returns a `bool` indicating whether conversion was successful for
    /// all encountered annotations (`true`) or not (`false`), and also the
    /// `ast::Annotations` object. Note that a partial `ast::Annotations`
    /// object, containing only the valid annotations, may be returned even in
    /// failure cases.  In all failure cases, `false` will be returned and
    /// errors will be added to `errs`.
    pub fn get_ast_annotations(&self, errs: &mut ToASTErrors) -> (bool, ast::Annotations) {
        let mut failure = false;
        let mut annotations = BTreeMap::new();
        for node in self.annotations.iter() {
            match node.to_kv_pair(errs) {
                Some((k, v)) => {
                    use std::collections::btree_map::Entry;
                    match annotations.entry(k) {
                        Entry::Occupied(oentry) => {
                            failure = true;
                            errs.push(ToASTError::new(
                                ToASTErrorKind::DuplicateAnnotation(oentry.key().clone()),
                                node.loc.clone(),
                            ));
                        }
                        Entry::Vacant(ventry) => {
                            ventry.insert(v);
                        }
                    }
                }
                None => {
                    failure = true;
                    // don't need to add anything to `errs` because `.to_kv_pair()` will already have done so
                }
            }
        }
        (!failure, annotations.into())
    }
}

impl Node<Option<cst::Annotation>> {
    /// Get the (k, v) pair for the annotation. Critically, this checks validity
    /// for the strings and does unescaping
    pub fn to_kv_pair(&self, errs: &mut ToASTErrors) -> Option<(ast::AnyId, ast::Annotation)> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let anno = self.as_inner()?;

        let maybe_key = anno.key.to_any_ident(errs);
        let maybe_value = anno.value.as_valid_string(errs);
        let maybe_value = match maybe_value.map(|s| to_unescaped_string(s)).transpose() {
            Ok(maybe_value) => maybe_value,
            Err(unescape_errs) => {
                errs.extend(unescape_errs.into_iter().map(|e| self.to_ast_err(e)));
                None
            }
        };

        match (maybe_key, maybe_value) {
            (Some(k), Some(v)) => Some((
                k,
                ast::Annotation {
                    val: v,
                    loc: Some(self.loc.clone()), // self's loc, not the loc of the value alone; see comments on ast::Annotation
                },
            )),
            _ => None,
        }
    }
}

impl Node<Option<cst::Ident>> {
    /// Convert `cst::Ident` to `ast::Id`. Fails for reserved or invalid identifiers
    pub fn to_valid_ident(&self, errs: &mut ToASTErrors) -> Option<ast::Id> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let ident = self.as_inner()?;

        match ident {
            cst::Ident::If
            | cst::Ident::True
            | cst::Ident::False
            | cst::Ident::Then
            | cst::Ident::Else
            | cst::Ident::In
            | cst::Ident::Is
            | cst::Ident::Has
            | cst::Ident::Like => {
                errs.push(self.to_ast_err(ToASTErrorKind::ReservedIdentifier(ident.clone())));
                None
            }
            cst::Ident::Invalid(i) => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidIdentifier(i.clone())));
                None
            }
            _ => Some(ast::Id::new_unchecked(format!("{ident}"))),
        }
    }

    /// Convert [`cst::Ident`] to [`ast::AnyId`]. This method does not fail for
    /// reserved identifiers; see notes on [`ast::AnyId`].
    /// (It does fail for invalid identifiers, but there are no invalid
    /// identifiers at the time of this writing; see notes on
    /// [`cst::Ident::Invalid`])
    pub fn to_any_ident(&self, errs: &mut ToASTErrors) -> Option<ast::AnyId> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let ident = self.as_inner()?;

        match ident {
            cst::Ident::Invalid(i) => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidIdentifier(i.clone())));
                None
            }
            _ => Some(ast::AnyId::new_unchecked(format!("{ident}"))),
        }
    }

    /// effect
    pub(crate) fn to_effect(&self, errs: &mut ToASTErrors) -> Option<ast::Effect> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let effect = self.as_inner()?;

        match effect {
            cst::Ident::Permit => Some(ast::Effect::Permit),
            cst::Ident::Forbid => Some(ast::Effect::Forbid),
            _ => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidEffect(effect.clone())));
                None
            }
        }
    }
    pub(crate) fn to_cond_is_when(&self, errs: &mut ToASTErrors) -> Option<bool> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let cond = self.as_inner()?;

        match cond {
            cst::Ident::When => Some(true),
            cst::Ident::Unless => Some(false),
            _ => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidCondition(cond.clone())));
                None
            }
        }
    }

    fn to_var(&self, errs: &mut ToASTErrors) -> Option<ast::Var> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let ident = self.as_inner()?;

        match ident {
            cst::Ident::Principal => Some(ast::Var::Principal),
            cst::Ident::Action => Some(ast::Var::Action),
            cst::Ident::Resource => Some(ast::Var::Resource),
            ident => {
                errs.push(
                    self.to_ast_err(ToASTErrorKind::InvalidScopeConstraintVariable(
                        ident.clone(),
                    )),
                );
                None
            }
        }
    }
}

impl ast::Id {
    fn to_meth(
        &self,
        e: ast::Expr,
        mut args: Vec<ast::Expr>,
        errs: &mut ToASTErrors,
        loc: &Loc,
    ) -> Option<ast::Expr> {
        match self.as_ref() {
            "contains" => extract_single_argument(args.into_iter(), "contains", loc)
                .map(|arg| construct_method_contains(e, arg, loc.clone()))
                .map_err(|err| errs.push(err))
                .ok(),
            "containsAll" => extract_single_argument(args.into_iter(), "containsAll", loc)
                .map(|arg| construct_method_contains_all(e, arg, loc.clone()))
                .map_err(|err| errs.push(err))
                .ok(),
            "containsAny" => extract_single_argument(args.into_iter(), "containsAny", loc)
                .map(|arg| construct_method_contains_any(e, arg, loc.clone()))
                .map_err(|err| errs.push(err))
                .ok(),
            id => {
                if EXTENSION_STYLES.methods.contains(&id) {
                    args.insert(0, e);
                    // INVARIANT (MethodStyleArgs), we call insert above, so args is non-empty
                    Some(construct_ext_meth(id.to_string(), args, loc.clone()))
                } else {
                    let unqual_name = ast::Name::unqualified_name(self.clone());
                    if EXTENSION_STYLES.functions.contains(&unqual_name) {
                        errs.push(ToASTError::new(
                            ToASTErrorKind::MethodCallOnFunction(unqual_name.id),
                            loc.clone(),
                        ));
                    } else {
                        errs.push(ToASTError::new(
                            ToASTErrorKind::InvalidMethodName(id.to_string()),
                            loc.clone(),
                        ));
                    }
                    None
                }
            }
        }
    }
}

#[derive(Debug)]
enum PrincipalOrResource {
    Principal(PrincipalConstraint),
    Resource(ResourceConstraint),
}

impl Node<Option<cst::VariableDef>> {
    fn to_principal_constraint(&self, errs: &mut ToASTErrors) -> Option<PrincipalConstraint> {
        match self.to_principal_or_resource_constraint(ast::Var::Principal, errs)? {
            PrincipalOrResource::Principal(p) => Some(p),
            PrincipalOrResource::Resource(_) => {
                errs.push(self.to_ast_err(ToASTErrorKind::IncorrectVariable {
                    expected: ast::Var::Principal,
                    got: ast::Var::Resource,
                }));
                None
            }
        }
    }

    fn to_resource_constraint(&self, errs: &mut ToASTErrors) -> Option<ResourceConstraint> {
        match self.to_principal_or_resource_constraint(ast::Var::Resource, errs)? {
            PrincipalOrResource::Principal(_) => {
                errs.push(self.to_ast_err(ToASTErrorKind::IncorrectVariable {
                    expected: ast::Var::Resource,
                    got: ast::Var::Principal,
                }));
                None
            }
            PrincipalOrResource::Resource(r) => Some(r),
        }
    }

    fn to_principal_or_resource_constraint(
        &self,
        expected: ast::Var,
        errs: &mut ToASTErrors,
    ) -> Option<PrincipalOrResource> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let vardef = self.as_inner()?;

        let var = vardef.variable.to_var(errs)?;

        if let Some(unused_typename) = vardef.unused_type_name.as_ref() {
            unused_typename.to_type_constraint(errs)?;
        }

        let c = if let Some((op, rel_expr)) = &vardef.ineq {
            let eref = rel_expr.to_ref_or_slot(errs, var)?;
            match (op, &vardef.entity_type) {
                (cst::RelOp::Eq, None) => Some(PrincipalOrResourceConstraint::Eq(eref)),
                (cst::RelOp::Eq, Some(_)) => {
                    errs.push(self.to_ast_err(ToASTErrorKind::InvalidIs(
                        err::InvalidIsError::WrongOp(cst::RelOp::Eq),
                    )));
                    None
                }
                (cst::RelOp::In, None) => Some(PrincipalOrResourceConstraint::In(eref)),
                (cst::RelOp::In, Some(entity_type)) => Some(PrincipalOrResourceConstraint::IsIn(
                    entity_type.to_expr_or_special(errs)?.into_name(errs)?,
                    eref,
                )),
                (cst::RelOp::InvalidSingleEq, _) => {
                    errs.push(self.to_ast_err(ToASTErrorKind::InvalidSingleEq));
                    None
                }
                (op, _) => {
                    errs.push(self.to_ast_err(ToASTErrorKind::InvalidConstraintOperator(*op)));
                    None
                }
            }
        } else if let Some(entity_type) = &vardef.entity_type {
            Some(PrincipalOrResourceConstraint::Is(
                entity_type.to_expr_or_special(errs)?.into_name(errs)?,
            ))
        } else {
            Some(PrincipalOrResourceConstraint::Any)
        }?;
        match var {
            ast::Var::Principal => {
                Some(PrincipalOrResource::Principal(PrincipalConstraint::new(c)))
            }
            ast::Var::Resource => Some(PrincipalOrResource::Resource(ResourceConstraint::new(c))),
            got => {
                errs.push(self.to_ast_err(ToASTErrorKind::IncorrectVariable { expected, got }));
                None
            }
        }
    }

    fn to_action_constraint(&self, errs: &mut ToASTErrors) -> Option<ast::ActionConstraint> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let vardef = self.as_inner()?;

        match vardef.variable.to_var(errs) {
            Some(ast::Var::Action) => Some(()),
            Some(got) => {
                errs.push(self.to_ast_err(ToASTErrorKind::IncorrectVariable {
                    expected: ast::Var::Action,
                    got,
                }));
                None
            }
            None => None,
        }?;

        if let Some(typename) = vardef.unused_type_name.as_ref() {
            typename.to_type_constraint(errs)?;
        }

        if vardef.entity_type.is_some() {
            errs.push(self.to_ast_err(ToASTErrorKind::InvalidIs(err::InvalidIsError::ActionScope)));
            return None;
        }

        let action_constraint = if let Some((op, rel_expr)) = &vardef.ineq {
            match op {
                cst::RelOp::In => match rel_expr.to_refs(errs, ast::Var::Action)? {
                    OneOrMultipleRefs::Single(single_ref) => {
                        Some(ActionConstraint::is_in([single_ref]))
                    }
                    OneOrMultipleRefs::Multiple(refs) => Some(ActionConstraint::is_in(refs)),
                },
                cst::RelOp::Eq => {
                    let single_ref = rel_expr.to_ref(ast::Var::Action, errs)?;
                    Some(ActionConstraint::is_eq(single_ref))
                }
                cst::RelOp::InvalidSingleEq => {
                    errs.push(self.to_ast_err(ToASTErrorKind::InvalidSingleEq));
                    None
                }
                op => {
                    errs.push(self.to_ast_err(ToASTErrorKind::InvalidConstraintOperator(*op)));
                    None
                }
            }
        } else {
            Some(ActionConstraint::Any)
        }?;

        match action_constraint_contains_only_action_types(action_constraint, &self.loc) {
            Ok(a) => Some(a),
            Err(mut id_errs) => {
                errs.append(&mut id_errs);
                None
            }
        }
    }
}

/// Check that all of the EUIDs in an action constraint have the type `Action`, under an arbitrary namespace
fn action_constraint_contains_only_action_types(
    a: ActionConstraint,
    loc: &Loc,
) -> Result<ActionConstraint, ToASTErrors> {
    match a {
        ActionConstraint::Any => Ok(a),
        ActionConstraint::In(ref euids) => {
            let non_actions = euids
                .iter()
                .filter(|euid| !euid_has_action_type(euid))
                .collect::<Vec<_>>();
            if non_actions.is_empty() {
                Ok(a)
            } else {
                Err(non_actions
                    .into_iter()
                    .map(|euid| {
                        ToASTError::new(
                            ToASTErrorKind::InvalidActionType(euid.as_ref().clone()),
                            loc.clone(),
                        )
                    })
                    .collect())
            }
        }
        ActionConstraint::Eq(ref euid) => {
            if euid_has_action_type(euid) {
                Ok(a)
            } else {
                Err(vec![ToASTError::new(
                    ToASTErrorKind::InvalidActionType(euid.as_ref().clone()),
                    loc.clone(),
                )])
            }
        }
    }
}

/// Check if an EUID has the type `Action` under an arbitrary namespace
fn euid_has_action_type(euid: &EntityUID) -> bool {
    if let EntityType::Specified(name) = euid.entity_type() {
        name.id.as_ref() == "Action"
    } else {
        false
    }
}

impl Node<Option<cst::Cond>> {
    /// to expr. Also returns, for informational purposes, a `bool` which is
    /// `true` if the cond is a `when` clause, `false` if it is an `unless`
    /// clause. (The returned `expr` is already adjusted for this, the `bool` is
    /// for information only.)
    fn to_expr(&self, errs: &mut ToASTErrors) -> Option<(ast::Expr, bool)> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let cond = self.as_inner()?;

        let maybe_is_when = cond.cond.to_cond_is_when(errs)?;

        let maybe_expr = match &cond.expr {
            Some(expr) => expr.to_expr(errs),
            None => {
                let ident = match cond.cond.as_inner() {
                    Some(ident) => ident.clone(),
                    None => {
                        // `cond.cond.to_cond_is_when()` returned with `Some`,
                        // so `cond.cond.as_inner()` must have been `Some`
                        // inside that function call, making this unreachable.
                        if maybe_is_when {
                            cst::Ident::Ident("when".into())
                        } else {
                            cst::Ident::Ident("unless".into())
                        }
                    }
                };
                errs.push(self.to_ast_err(ToASTErrorKind::EmptyClause(Some(ident))));
                None
            }
        };

        maybe_expr.map(|e| {
            if maybe_is_when {
                (e, true)
            } else {
                (construct_expr_not(e, self.loc.clone()), false)
            }
        })
    }
}

impl Node<Option<cst::Str>> {
    pub(crate) fn as_valid_string(&self, errs: &mut ToASTErrors) -> Option<&SmolStr> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let id = self.as_inner()?;

        match id {
            cst::Str::String(s) => Some(s),
            // at time of comment, all strings are valid
            cst::Str::Invalid(s) => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidString(s.to_string())));
                None
            }
        }
    }
}

/// Result type of conversion when we expect an Expr, Var, Name, or String.
///
/// During conversion it is useful to keep track of expression that may be used
/// as function names, record names, or record attributes. This prevents parsing these
/// terms to a general Expr expression and then immediately unwrapping them.
#[derive(Debug)]
pub(crate) enum ExprOrSpecial<'a> {
    /// Any expression except a variable, name, or string literal
    Expr { expr: ast::Expr, loc: Loc },
    /// Variables, which act as expressions or names
    Var { var: ast::Var, loc: Loc },
    /// Name that isn't an expr and couldn't be converted to var
    Name { name: ast::Name, loc: Loc },
    /// String literal, not yet unescaped
    /// Must be processed with to_unescaped_string or to_pattern before inclusion in the AST
    StrLit { lit: &'a SmolStr, loc: Loc },
}

impl ExprOrSpecial<'_> {
    fn to_ast_err(&self, kind: impl Into<ToASTErrorKind>) -> ToASTError {
        ToASTError::new(
            kind.into(),
            match self {
                ExprOrSpecial::Expr { loc, .. } => loc.clone(),
                ExprOrSpecial::Var { loc, .. } => loc.clone(),
                ExprOrSpecial::Name { loc, .. } => loc.clone(),
                ExprOrSpecial::StrLit { loc, .. } => loc.clone(),
            },
        )
    }

    fn into_expr(self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        match self {
            Self::Expr { expr, .. } => Some(expr),
            Self::Var { var, loc } => Some(construct_expr_var(var, loc)),
            Self::Name { name, loc } => {
                errs.push(ToASTError::new(
                    ToASTErrorKind::ArbitraryVariable(name.to_string().into()),
                    loc,
                ));
                None
            }
            Self::StrLit { lit, loc } => match to_unescaped_string(lit) {
                Ok(s) => Some(construct_expr_string(s, loc)),
                Err(escape_errs) => {
                    errs.extend(
                        escape_errs
                            .into_iter()
                            .map(|e| ToASTError::new(ToASTErrorKind::Unescape(e), loc.clone())),
                    );
                    None
                }
            },
        }
    }

    /// Variables, names (with no prefixes), and string literals can all be used as record attributes
    pub(crate) fn into_valid_attr(self, errs: &mut ToASTErrors) -> Option<SmolStr> {
        match self {
            Self::Var { var, .. } => Some(construct_string_from_var(var)),
            Self::Name { name, loc } => name.into_valid_attr(errs, loc),
            Self::StrLit { lit, loc } => match to_unescaped_string(lit) {
                Ok(s) => Some(s),
                Err(escape_errs) => {
                    errs.extend(
                        escape_errs
                            .into_iter()
                            .map(|e| ToASTError::new(ToASTErrorKind::Unescape(e), loc.clone())),
                    );
                    None
                }
            },
            Self::Expr { expr, loc } => {
                errs.push(ToASTError::new(
                    ToASTErrorKind::InvalidAttribute(expr.to_string().into()),
                    loc,
                ));
                None
            }
        }
    }

    pub(crate) fn into_pattern(self, errs: &mut ToASTErrors) -> Option<Vec<PatternElem>> {
        match &self {
            Self::StrLit { lit, .. } => match to_pattern(lit) {
                Ok(pat) => Some(pat),
                Err(escape_errs) => {
                    errs.extend(
                        escape_errs
                            .into_iter()
                            .map(|e| self.to_ast_err(ToASTErrorKind::Unescape(e))),
                    );
                    None
                }
            },
            Self::Var { var, .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidPattern(var.to_string())));
                None
            }
            Self::Name { name, .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidPattern(name.to_string())));
                None
            }
            Self::Expr { expr, .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidPattern(expr.to_string())));
                None
            }
        }
    }
    /// to string literal
    fn into_string_literal(self, errs: &mut ToASTErrors) -> Option<SmolStr> {
        match &self {
            Self::StrLit { lit, .. } => match to_unescaped_string(lit) {
                Ok(s) => Some(s),
                Err(escape_errs) => {
                    errs.extend(
                        escape_errs
                            .into_iter()
                            .map(|e| self.to_ast_err(ToASTErrorKind::Unescape(e))),
                    );
                    None
                }
            },
            Self::Var { var, .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidString(var.to_string())));
                None
            }
            Self::Name { name, .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidString(name.to_string())));
                None
            }
            Self::Expr { expr, .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::InvalidString(expr.to_string())));
                None
            }
        }
    }

    fn into_name(self, errs: &mut ToASTErrors) -> Option<ast::Name> {
        match self {
            Self::StrLit { lit, .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::IsInvalidName(lit.to_string())));
                None
            }
            Self::Var { var, .. } => Some(ast::Name::unqualified_name(var.into())),
            Self::Name { name, .. } => Some(name),
            Self::Expr { ref expr, .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::IsInvalidName(expr.to_string())));
                None
            }
        }
    }
}

impl Node<Option<cst::Expr>> {
    /// to ref
    fn to_ref(&self, var: ast::Var, errs: &mut ToASTErrors) -> Option<EntityUID> {
        self.to_ref_or_refs::<SingleEntity>(errs, var).map(|x| x.0)
    }

    fn to_ref_or_slot(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<EntityReference> {
        self.to_ref_or_refs::<EntityReference>(errs, var)
    }

    fn to_refs(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<OneOrMultipleRefs> {
        self.to_ref_or_refs::<OneOrMultipleRefs>(errs, var)
    }

    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let expr = self.as_inner()?;

        match &*expr.expr {
            cst::ExprData::Or(o) => o.to_ref_or_refs::<T>(errs, var),
            cst::ExprData::If(_, _, _) => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    "an `if` expression",
                    None::<String>,
                )));
                None
            }
        }
    }

    /// convert `cst::Expr` to `ast::Expr`
    pub fn to_expr(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        self.to_expr_or_special(errs)?.into_expr(errs)
    }
    pub(crate) fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let expr = self.as_inner()?;

        match &*expr.expr {
            cst::ExprData::Or(or) => or.to_expr_or_special(errs),
            cst::ExprData::If(i, t, e) => {
                let maybe_guard = i.to_expr(errs);
                let maybe_then = t.to_expr(errs);
                let maybe_else = e.to_expr(errs);

                match (maybe_guard, maybe_then, maybe_else) {
                    (Some(i), Some(t), Some(e)) => Some(ExprOrSpecial::Expr {
                        expr: construct_expr_if(i, t, e, self.loc.clone()),
                        loc: self.loc.clone(),
                    }),
                    _ => None,
                }
            }
        }
    }
}

/// Type level marker for parsing sets of entity uids or single uids
/// This presents having either a large level of code duplication
/// or runtime data.
trait RefKind: Sized {
    fn err_str() -> &'static str;
    fn create_single_ref(e: EntityUID, errs: &mut ToASTErrors, loc: &Loc) -> Option<Self>;
    fn create_multiple_refs(es: Vec<EntityUID>, errs: &mut ToASTErrors, loc: &Loc) -> Option<Self>;
    fn create_slot(errs: &mut ToASTErrors, loc: &Loc) -> Option<Self>;
}

struct SingleEntity(pub EntityUID);

impl RefKind for SingleEntity {
    fn err_str() -> &'static str {
        "an entity uid"
    }

    fn create_single_ref(e: EntityUID, _errs: &mut ToASTErrors, _loc: &Loc) -> Option<Self> {
        Some(SingleEntity(e))
    }

    fn create_multiple_refs(
        _es: Vec<EntityUID>,
        errs: &mut ToASTErrors,
        loc: &Loc,
    ) -> Option<Self> {
        errs.push(ToASTError::new(
            RefCreationError::one_expected(Ref::Single, Ref::Set).into(),
            loc.clone(),
        ));
        None
    }

    fn create_slot(errs: &mut ToASTErrors, loc: &Loc) -> Option<Self> {
        errs.push(ToASTError::new(
            RefCreationError::one_expected(Ref::Single, Ref::Template).into(),
            loc.clone(),
        ));
        None
    }
}

impl RefKind for EntityReference {
    fn err_str() -> &'static str {
        "an entity uid or matching template slot"
    }

    fn create_slot(_: &mut ToASTErrors, _loc: &Loc) -> Option<Self> {
        Some(EntityReference::Slot)
    }

    fn create_single_ref(e: EntityUID, _errs: &mut ToASTErrors, _loc: &Loc) -> Option<Self> {
        Some(EntityReference::euid(e))
    }

    fn create_multiple_refs(
        _es: Vec<EntityUID>,
        errs: &mut ToASTErrors,
        loc: &Loc,
    ) -> Option<Self> {
        errs.push(ToASTError::new(
            RefCreationError::two_expected(Ref::Single, Ref::Template, Ref::Set).into(),
            loc.clone(),
        ));
        None
    }
}

/// Simple utility enum for parsing lists/individual entityuids
#[derive(Debug)]
enum OneOrMultipleRefs {
    Single(EntityUID),
    Multiple(Vec<EntityUID>),
}

impl RefKind for OneOrMultipleRefs {
    fn err_str() -> &'static str {
        "an entity uid or set of entity uids"
    }

    fn create_slot(errs: &mut ToASTErrors, loc: &Loc) -> Option<Self> {
        errs.push(ToASTError::new(
            RefCreationError::two_expected(Ref::Single, Ref::Set, Ref::Template).into(),
            loc.clone(),
        ));
        None
    }

    fn create_single_ref(e: EntityUID, _errs: &mut ToASTErrors, _loc: &Loc) -> Option<Self> {
        Some(OneOrMultipleRefs::Single(e))
    }

    fn create_multiple_refs(
        es: Vec<EntityUID>,
        _errs: &mut ToASTErrors,
        _loc: &Loc,
    ) -> Option<Self> {
        Some(OneOrMultipleRefs::Multiple(es))
    }
}

impl Node<Option<cst::Or>> {
    fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let or = self.as_inner()?;

        let maybe_first = or.initial.to_expr_or_special(errs);
        let mut more = or.extended.iter().filter_map(|i| i.to_expr(errs));
        // getting the second here avoids the possibility of a singleton construction
        let maybe_second = more.next();
        // collect() preforms all the conversions, generating any errors
        let rest: Vec<_> = more.collect();

        match (maybe_first, maybe_second, rest.len(), or.extended.len()) {
            (f, None, _, 0) => f,
            (Some(f), Some(s), r, e) if 1 + r == e => {
                f.into_expr(errs).map(|e| ExprOrSpecial::Expr {
                    expr: construct_expr_or(e, s, rest, &self.loc),
                    loc: self.loc.clone(),
                })
            }
            _ => None,
        }
    }

    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let or = self.as_inner()?;

        match or.extended.len() {
            0 => or.initial.to_ref_or_refs::<T>(errs, var),
            _n => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    "a `||` expression",
                    None::<String>,
                )));
                None
            }
        }
    }
}

impl Node<Option<cst::And>> {
    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let and = self.as_inner()?;

        match and.extended.len() {
            0 => and.initial.to_ref_or_refs::<T>(errs, var),
            _n => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    "a `&&` expression",
                    None::<String>,
                )));
                None
            }
        }
    }

    fn to_expr(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        self.to_expr_or_special(errs)?.into_expr(errs)
    }
    fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let and = self.as_inner()?;

        let maybe_first = and.initial.to_expr_or_special(errs);
        let mut more = and.extended.iter().filter_map(|i| i.to_expr(errs));
        // getting the second here avoids the possibility of a singleton construction
        let maybe_second = more.next();
        // collect() preforms all the conversions, generating any errors
        let rest: Vec<_> = more.collect();

        match (maybe_first, maybe_second, rest.len(), and.extended.len()) {
            (f, None, _, 0) => f,
            (Some(f), Some(s), r, e) if 1 + r == e => {
                f.into_expr(errs).map(|e| ExprOrSpecial::Expr {
                    expr: construct_expr_and(e, s, rest, &self.loc),
                    loc: self.loc.clone(),
                })
            }
            _ => None,
        }
    }
}

impl Node<Option<cst::Relation>> {
    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let rel = self.as_inner()?;

        match rel {
            cst::Relation::Common { initial, extended } => match extended.len() {
                0 => initial.to_ref_or_refs::<T>(errs, var),
                _n => {
                    errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                        T::err_str(),
                        "a binary operator",
                        None::<String>,
                    )));
                    None
                }
            },
            cst::Relation::Has { .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    "a `has` expression",
                    None::<String>,
                )));
                None
            }
            cst::Relation::Like { .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    "a `like` expression",
                    None::<String>,
                )));
                None
            }
            cst::Relation::IsIn { .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    "an `is` expression",
                    None::<String>,
                )));
                None
            }
        }
    }

    fn to_expr(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        self.to_expr_or_special(errs)?.into_expr(errs)
    }
    fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let rel = self.as_inner()?;

        match rel {
            cst::Relation::Common { initial, extended } => {
                let maybe_first = initial.to_expr_or_special(errs);
                let mut more = extended
                    .iter()
                    .filter_map(|(op, i)| i.to_expr(errs).map(|e| (op, e)));
                // getting the second here avoids the possibility of a singleton construction
                let maybe_second = more.next();
                // collect() preforms all the conversions, generating any errors
                let _rest: Vec<_> = more.collect();

                match (maybe_first, maybe_second, extended.len()) {
                    (_, _, len) if len > 1 => {
                        errs.push(self.to_ast_err(ToASTErrorKind::AmbiguousOperators));
                        None
                    }
                    // error reported and result filtered out
                    (_, None, 1) => None,
                    (f, None, 0) => f,
                    (Some(f), Some((op, s)), _) => f.into_expr(errs).map(|e| {
                        Some(ExprOrSpecial::Expr {
                            expr: construct_expr_rel(e, *op, s, self.loc.clone(), errs)?,
                            loc: self.loc.clone(),
                        })
                    })?,
                    _ => None,
                }
            }
            cst::Relation::Has { target, field } => {
                match (
                    target.to_expr(errs),
                    field.to_expr_or_special(errs)?.into_valid_attr(errs),
                ) {
                    (Some(t), Some(s)) => Some(ExprOrSpecial::Expr {
                        expr: construct_expr_has(t, s, self.loc.clone()),
                        loc: self.loc.clone(),
                    }),
                    _ => None,
                }
            }
            cst::Relation::Like { target, pattern } => {
                match (
                    target.to_expr(errs),
                    pattern.to_expr_or_special(errs)?.into_pattern(errs),
                ) {
                    (Some(t), Some(s)) => Some(ExprOrSpecial::Expr {
                        expr: construct_expr_like(t, s, self.loc.clone()),
                        loc: self.loc.clone(),
                    }),
                    _ => None,
                }
            }
            cst::Relation::IsIn {
                target,
                entity_type,
                in_entity,
            } => match (
                target.to_expr(errs),
                entity_type.to_expr_or_special(errs)?.into_name(errs),
            ) {
                (Some(t), Some(n)) => match in_entity {
                    Some(in_entity) => in_entity.to_expr(errs).map(|in_entity| {
                        Some(ExprOrSpecial::Expr {
                            expr: construct_expr_and(
                                construct_expr_is(t.clone(), n, self.loc.clone()),
                                construct_expr_rel(
                                    t,
                                    cst::RelOp::In,
                                    in_entity,
                                    self.loc.clone(),
                                    errs,
                                )?,
                                std::iter::empty(),
                                &self.loc,
                            ),
                            loc: self.loc.clone(),
                        })
                    })?,
                    None => Some(ExprOrSpecial::Expr {
                        expr: construct_expr_is(t, n, self.loc.clone()),
                        loc: self.loc.clone(),
                    }),
                },
                _ => None,
            },
        }
    }
}

impl Node<Option<cst::Add>> {
    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let add = self.as_inner()?;

        match add.extended.len() {
            0 => add.initial.to_ref_or_refs::<T>(errs, var),
            _n => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(T::err_str(), "a `+/-` expression", Some("entity types and namespaces cannot use `+` or `-` characters -- perhaps try `_` or `::` instead?"))));
                None
            }
        }
    }

    fn to_expr(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        self.to_expr_or_special(errs)?.into_expr(errs)
    }
    pub(crate) fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let add = self.as_inner()?;

        let maybe_first = add.initial.to_expr_or_special(errs);
        // collect() performs all the conversions, generating any errors
        let more: Vec<(cst::AddOp, _)> = add
            .extended
            .iter()
            .filter_map(|&(op, ref i)| i.to_expr(errs).map(|e| (op, e)))
            .collect();
        if !more.is_empty() {
            Some(ExprOrSpecial::Expr {
                expr: construct_expr_add(maybe_first?.into_expr(errs)?, more, &self.loc),
                loc: self.loc.clone(),
            })
        } else {
            maybe_first
        }
    }
}

impl Node<Option<cst::Mult>> {
    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let mult = self.as_inner()?;

        match mult.extended.len() {
            0 => mult.initial.to_ref_or_refs::<T>(errs, var),
            _n => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    "a `*` expression",
                    None::<String>,
                )));
                None
            }
        }
    }

    fn to_expr(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        self.to_expr_or_special(errs)?.into_expr(errs)
    }
    fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let mult = self.as_inner()?;

        let maybe_first = mult.initial.to_expr_or_special(errs);
        let more = mult
            .extended
            .iter()
            .filter_map(|&(op, ref i)| i.to_expr(errs).map(|e| (op, e)));

        let (more, new_errs): (Vec<_>, Vec<_>) = more
            .map(|(op, expr)| match op {
                cst::MultOp::Times => Ok(expr),
                cst::MultOp::Divide => Err(self.to_ast_err(ToASTErrorKind::UnsupportedDivision)),
                cst::MultOp::Mod => Err(self.to_ast_err(ToASTErrorKind::UnsupportedModulo)),
            })
            .partition_result();
        errs.extend(new_errs);
        if !more.is_empty() {
            // in this case, `first` must be an expr, we should collect any errors there as well
            let first = maybe_first?.into_expr(errs)?;
            Some(ExprOrSpecial::Expr {
                expr: construct_expr_mul(first, more, &self.loc),
                loc: self.loc.clone(),
            })
        } else {
            maybe_first
        }
    }
}

impl Node<Option<cst::Unary>> {
    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let unary = self.as_inner()?;

        match &unary.op {
            Some(op) => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    format!("a `{op}` expression"),
                    None::<String>,
                )));
                None
            }
            None => unary.item.to_ref_or_refs::<T>(errs, var),
        }
    }

    fn to_expr(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        self.to_expr_or_special(errs)?.into_expr(errs)
    }
    fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let unary = self.as_inner()?;

        // A thunk to delay the evaluation of `item`
        let mut maybe_item = || unary.item.to_expr_or_special(errs);

        match unary.op {
            None => maybe_item(),
            Some(cst::NegOp::Bang(0)) => maybe_item(),
            Some(cst::NegOp::Dash(0)) => maybe_item(),
            Some(cst::NegOp::Bang(n)) => {
                let item = maybe_item().and_then(|i| i.into_expr(errs));
                if n % 2 == 0 {
                    item.map(|i| ExprOrSpecial::Expr {
                        expr: construct_expr_not(
                            construct_expr_not(i, self.loc.clone()),
                            self.loc.clone(),
                        ),
                        loc: self.loc.clone(),
                    })
                } else {
                    // safe to collapse to !
                    item.map(|i| ExprOrSpecial::Expr {
                        expr: construct_expr_not(i, self.loc.clone()),
                        loc: self.loc.clone(),
                    })
                }
            }
            Some(cst::NegOp::Dash(c)) => {
                // Test if there is a negative numeric literal.
                // A negative numeric literal should match regex pattern
                // `-\d+` which is parsed into a `Unary(_, Member(Primary(Literal(Num(_))), []))`.
                // Given a successful match, the number of negation operations
                // decreases by one.
                let (last, rc) = if let Some(cst::Literal::Num(n)) = unary.item.to_lit() {
                    match n.cmp(&(i64::MAX as u64 + 1)) {
                        Ordering::Equal => (
                            Some(construct_expr_num(i64::MIN, unary.item.loc.clone())),
                            c - 1,
                        ),
                        Ordering::Less => (
                            Some(construct_expr_num(-(*n as i64), unary.item.loc.clone())),
                            c - 1,
                        ),
                        Ordering::Greater => {
                            errs.push(self.to_ast_err(ToASTErrorKind::IntegerLiteralTooLarge(*n)));
                            (None, 0)
                        }
                    }
                } else {
                    // If the operand is not a CST literal, convert it into
                    // an expression.
                    (maybe_item().and_then(|i| i.into_expr(errs)), c)
                };
                // Fold the expression into a series of negation operations.
                (0..rc)
                    .fold(last, |r, _| {
                        r.map(|e| (construct_expr_neg(e, self.loc.clone())))
                    })
                    .map(|expr| ExprOrSpecial::Expr {
                        expr,
                        loc: self.loc.clone(),
                    })
            }
            Some(cst::NegOp::OverBang) => {
                errs.push(self.to_ast_err(ToASTErrorKind::UnaryOpLimit(ast::UnaryOp::Not)));
                None
            }
            Some(cst::NegOp::OverDash) => {
                errs.push(self.to_ast_err(ToASTErrorKind::UnaryOpLimit(ast::UnaryOp::Neg)));
                None
            }
        }
    }
}

/// Temporary converted data, mirroring `cst::MemAccess`
enum AstAccessor {
    Field(ast::Id),
    Call(Vec<ast::Expr>),
    Index(SmolStr),
}

impl Node<Option<cst::Member>> {
    /// Try to convert `cst::Member` into a `cst::Literal`, i.e.
    /// match `Member(Primary(Literal(_), []))`.
    /// It does not match the `Expr` arm of `Primary`, which means expressions
    /// like `(1)` are not considered as literals on the CST level.
    pub fn to_lit(&self) -> Option<&cst::Literal> {
        let m = self.as_ref().node.as_ref()?;
        if !m.access.is_empty() {
            return None;
        }
        match m.item.as_ref().node.as_ref()? {
            cst::Primary::Literal(lit) => lit.as_ref().node.as_ref(),
            _ => None,
        }
    }

    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let mem = self.as_inner()?;

        match mem.access.len() {
            0 => mem.item.to_ref_or_refs::<T>(errs, var),
            _n => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(T::err_str(), "a `.` expression", Some("entity types and namespaces cannot use `.` characters -- perhaps try `_` or `::` instead?"))));
                None
            }
        }
    }

    fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let mem = self.as_inner()?;

        let maybe_prim = mem.item.to_expr_or_special(errs);

        // collect() allows all conversions to run and generate errors
        let mut accessors: Vec<_> = mem.access.iter().map(|a| a.to_access(errs)).collect();

        // we use `head` as our failure indicator going forward
        let mut head = maybe_prim;
        // we need at least three available items, for example:
        // var .call (args) -  which becomes one expr
        // so we use slice matching
        let mut tail = &mut accessors[..];

        // Starting off with a failure and filtering items from the accessor list
        // can cause false error messages. We consider this acceptable for now because
        // they only occur along side a real error.
        // TODO(#439): eliminate the false errors (likely with `Option`s inside `AstAccessor`)
        //
        // This algorithm is essentially an iterator over the accessor slice, but the
        // pattern match should be easier to read, since we have to check multiple elements
        // at once. We use `mem::replace` to "deconstruct" the slice as we go, filling it
        // with empty data and taking ownership of its contents.
        loop {
            use AstAccessor::*;
            use ExprOrSpecial::*;
            match (&mut head, tail) {
                // no accessors left - we're done
                (_, []) => break head,
                // failed method call (presumably) - ignore
                (_, [None, Some(Call(_)), rest @ ..]) => {
                    head = None;
                    tail = rest;
                }
                // failed access - ignore
                (_, [None, rest @ ..]) => {
                    head = None;
                    tail = rest;
                }
                // function call
                (Some(Name { name, .. }), [Some(Call(a)), rest @ ..]) => {
                    // move the vec out of the slice, we won't use the slice after
                    let args = std::mem::take(a);
                    // replace the object `name` refers to with a default value since it won't be used afterwards
                    let nn = mem::replace(
                        name,
                        ast::Name::unqualified_name(ast::Id::new_unchecked("")),
                    );
                    head = nn.into_func(args, errs, self.loc.clone()).map(|expr| Expr {
                        expr,
                        loc: self.loc.clone(),
                    });
                    tail = rest;
                }
                // variable call - error
                (Some(Var { var, .. }), [Some(Call(_)), rest @ ..]) => {
                    errs.push(self.to_ast_err(ToASTErrorKind::VariableCall(*var)));
                    head = None;
                    tail = rest;
                }
                // arbitrary call - error
                (_, [Some(Call(_)), rest @ ..]) => {
                    errs.push(self.to_ast_err(ToASTErrorKind::ExpressionCall));
                    head = None;
                    tail = rest;
                }
                // method call on failure - ignore
                (None, [Some(Field(_)), Some(Call(_)), rest @ ..]) => {
                    tail = rest;
                }
                // method call on name - error
                (Some(Name { name, .. }), [Some(Field(f)), Some(Call(_)), rest @ ..]) => {
                    errs.push(self.to_ast_err(ToASTErrorKind::NoMethods(name.clone(), f.clone())));
                    head = None;
                    tail = rest;
                }
                // method call on variable
                (Some(Var { var, loc: var_loc }), [Some(Field(i)), Some(Call(a)), rest @ ..]) => {
                    // move var and args out of the slice
                    let var = mem::replace(var, ast::Var::Principal);
                    let args = std::mem::take(a);
                    // move the id out of the slice as well, to avoid cloning the internal string
                    let id = mem::replace(i, ast::Id::new_unchecked(""));
                    head = id
                        .to_meth(
                            construct_expr_var(var, var_loc.clone()),
                            args,
                            errs,
                            &self.loc,
                        )
                        .map(|expr| Expr {
                            expr,
                            loc: self.loc.clone(),
                        });
                    tail = rest;
                }
                // method call on arbitrary expression
                (Some(Expr { expr, .. }), [Some(Field(i)), Some(Call(a)), rest @ ..]) => {
                    // move the expr and args out of the slice
                    let args = std::mem::take(a);
                    let expr = mem::replace(expr, ast::Expr::val(false));
                    // move the id out of the slice as well, to avoid cloning the internal string
                    let id = mem::replace(i, ast::Id::new_unchecked(""));
                    head = id.to_meth(expr, args, errs, &self.loc).map(|expr| Expr {
                        expr,
                        loc: self.loc.clone(),
                    });
                    tail = rest;
                }
                // method call on string literal (same as Expr case)
                (
                    Some(StrLit { lit, loc: lit_loc }),
                    [Some(Field(i)), Some(Call(a)), rest @ ..],
                ) => {
                    let args = std::mem::take(a);
                    let id = mem::replace(i, ast::Id::new_unchecked(""));
                    let maybe_expr = match to_unescaped_string(lit) {
                        Ok(s) => Some(construct_expr_string(s, lit_loc.clone())),
                        Err(escape_errs) => {
                            errs.extend(
                                escape_errs
                                    .into_iter()
                                    .map(|e| self.to_ast_err(ToASTErrorKind::Unescape(e))),
                            );
                            None
                        }
                    };
                    head = maybe_expr.and_then(|e| {
                        id.to_meth(e, args, errs, &self.loc).map(|expr| Expr {
                            expr,
                            loc: self.loc.clone(),
                        })
                    });
                    tail = rest;
                }
                // access of failure - ignore
                (None, [Some(Field(_)) | Some(Index(_)), rest @ ..]) => {
                    tail = rest;
                }
                // access on arbitrary name - error
                (Some(Name { name, .. }), [Some(Field(f)), rest @ ..]) => {
                    errs.push(self.to_ast_err(ToASTErrorKind::InvalidAccess(
                        name.clone(),
                        f.to_string().into(),
                    )));
                    head = None;
                    tail = rest;
                }
                (Some(Name { name, .. }), [Some(Index(i)), rest @ ..]) => {
                    errs.push(
                        self.to_ast_err(ToASTErrorKind::InvalidIndex(name.clone(), i.clone())),
                    );
                    head = None;
                    tail = rest;
                }
                // attribute of variable
                (Some(Var { var, loc: var_loc }), [Some(Field(i)), rest @ ..]) => {
                    let var = mem::replace(var, ast::Var::Principal);
                    let id = mem::replace(i, ast::Id::new_unchecked(""));
                    head = Some(Expr {
                        expr: construct_expr_attr(
                            construct_expr_var(var, var_loc.clone()),
                            id.into_smolstr(),
                            self.loc.clone(),
                        ),
                        loc: self.loc.clone(),
                    });
                    tail = rest;
                }
                // field of arbitrary expr
                (Some(Expr { expr, .. }), [Some(Field(i)), rest @ ..]) => {
                    let expr = mem::replace(expr, ast::Expr::val(false));
                    let id = mem::replace(i, ast::Id::new_unchecked(""));
                    head = Some(Expr {
                        expr: construct_expr_attr(expr, id.into_smolstr(), self.loc.clone()),
                        loc: self.loc.clone(),
                    });
                    tail = rest;
                }
                // field of string literal (same as Expr case)
                (Some(StrLit { lit, loc: lit_loc }), [Some(Field(i)), rest @ ..]) => {
                    let id = mem::replace(i, ast::Id::new_unchecked(""));
                    let maybe_expr = match to_unescaped_string(lit) {
                        Ok(s) => Some(construct_expr_string(s, lit_loc.clone())),
                        Err(escape_errs) => {
                            errs.extend(
                                escape_errs
                                    .into_iter()
                                    .map(|e| self.to_ast_err(ToASTErrorKind::Unescape(e))),
                            );
                            None
                        }
                    };
                    head = maybe_expr.map(|e| Expr {
                        expr: construct_expr_attr(e, id.into_smolstr(), self.loc.clone()),
                        loc: self.loc.clone(),
                    });
                    tail = rest;
                }
                // index into var
                (Some(Var { var, loc: var_loc }), [Some(Index(i)), rest @ ..]) => {
                    let var = mem::replace(var, ast::Var::Principal);
                    let s = mem::take(i);
                    head = Some(Expr {
                        expr: construct_expr_attr(
                            construct_expr_var(var, var_loc.clone()),
                            s,
                            self.loc.clone(),
                        ),
                        loc: self.loc.clone(),
                    });
                    tail = rest;
                }
                // index into arbitrary expr
                (Some(Expr { expr, .. }), [Some(Index(i)), rest @ ..]) => {
                    let expr = mem::replace(expr, ast::Expr::val(false));
                    let s = mem::take(i);
                    head = Some(Expr {
                        expr: construct_expr_attr(expr, s, self.loc.clone()),
                        loc: self.loc.clone(),
                    });
                    tail = rest;
                }
                // index into string literal (same as Expr case)
                (Some(StrLit { lit, loc: lit_loc }), [Some(Index(i)), rest @ ..]) => {
                    let id = mem::take(i);
                    let maybe_expr = match to_unescaped_string(lit) {
                        Ok(s) => Some(construct_expr_string(s, lit_loc.clone())),
                        Err(escape_errs) => {
                            errs.extend(
                                escape_errs
                                    .into_iter()
                                    .map(|e| self.to_ast_err(ToASTErrorKind::Unescape(e))),
                            );
                            None
                        }
                    };
                    head = maybe_expr.map(|e| Expr {
                        expr: construct_expr_attr(e, id, self.loc.clone()),
                        loc: self.loc.clone(),
                    });
                    tail = rest;
                }
            }
        }
    }
}

impl Node<Option<cst::MemAccess>> {
    fn to_access(&self, errs: &mut ToASTErrors) -> Option<AstAccessor> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let acc = self.as_inner()?;

        match acc {
            cst::MemAccess::Field(i) => {
                let ident = i.to_valid_ident(errs);
                ident.map(AstAccessor::Field)
            }
            cst::MemAccess::Call(args) => {
                let conv_args: Vec<_> = args.iter().filter_map(|e| e.to_expr(errs)).collect();
                if conv_args.len() == args.len() {
                    Some(AstAccessor::Call(conv_args))
                } else {
                    None
                }
            }
            cst::MemAccess::Index(index) => {
                let s = index.to_expr_or_special(errs)?.into_string_literal(errs);
                s.map(AstAccessor::Index)
            }
        }
    }
}

impl Node<Option<cst::Primary>> {
    fn to_ref_or_refs<T: RefKind>(&self, errs: &mut ToASTErrors, var: ast::Var) -> Option<T> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let prim = self.as_inner()?;

        match prim {
            cst::Primary::Slot(s) => {
                // Call `create_slot` first so that we fail immediately if the
                // `RefKind` does not permit slots, and only then complain if
                // it's the wrong slot. This avoids getting an error
                // `found ?action instead of ?action` when `action` doesn't
                // support slots.
                let slot_ref = T::create_slot(errs, &self.loc)?;
                let slot = s.as_inner()?;
                if slot.matches(var) {
                    Some(slot_ref)
                } else {
                    errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                        T::err_str(),
                        format!("{slot} instead of ?{var}"),
                        None::<String>,
                    )));
                    None
                }
            }
            cst::Primary::Literal(lit) => {
                let found = match lit.as_inner() {
                    Some(lit) => format!("literal `{lit}`"),
                    None => "empty node".to_string(),
                };
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    found,
                    None::<String>,
                )));
                None
            }
            cst::Primary::Ref(x) => T::create_single_ref(x.to_ref(errs)?, errs, &self.loc),
            cst::Primary::Name(name) => {
                let found = match name.as_inner() {
                    Some(name) => format!("name `{name}`"),
                    None => "name".to_string(),
                };
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    found,
                    None::<String>,
                )));
                None
            }
            cst::Primary::Expr(x) => x.to_ref_or_refs::<T>(errs, var),
            cst::Primary::EList(lst) => {
                let v: Option<Vec<EntityUID>> =
                    lst.iter().map(|expr| expr.to_ref(var, errs)).collect();
                T::create_multiple_refs(v?, errs, &self.loc)
            }
            cst::Primary::RInits(_) => {
                errs.push(self.to_ast_err(ToASTErrorKind::wrong_node(
                    T::err_str(),
                    "record initializer",
                    None::<String>,
                )));
                None
            }
        }
    }

    pub(crate) fn to_expr(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        self.to_expr_or_special(errs)?.into_expr(errs)
    }
    fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let prim = self.as_inner()?;

        match prim {
            cst::Primary::Literal(lit) => lit.to_expr_or_special(errs),
            cst::Primary::Ref(r) => r.to_expr(errs).map(|expr| ExprOrSpecial::Expr {
                expr,
                loc: r.loc.clone(),
            }),
            cst::Primary::Slot(s) => s.clone().into_expr(errs).map(|expr| ExprOrSpecial::Expr {
                expr,
                loc: s.loc.clone(),
            }),
            #[allow(clippy::manual_map)]
            cst::Primary::Name(n) => {
                // if `n` isn't a var we don't want errors, we'll get them later
                if let Some(var) = n.to_var(&mut vec![]) {
                    Some(ExprOrSpecial::Var {
                        var,
                        loc: self.loc.clone(),
                    })
                } else if let Some(name) = n.to_name(errs) {
                    Some(ExprOrSpecial::Name {
                        name,
                        loc: self.loc.clone(),
                    })
                } else {
                    None
                }
            }
            cst::Primary::Expr(e) => e.to_expr(errs).map(|expr| ExprOrSpecial::Expr {
                expr,
                loc: e.loc.clone(),
            }),
            cst::Primary::EList(es) => {
                let list: Vec<_> = es.iter().filter_map(|e| e.to_expr(errs)).collect();
                if list.len() == es.len() {
                    Some(ExprOrSpecial::Expr {
                        expr: construct_expr_set(list, self.loc.clone()),
                        loc: self.loc.clone(),
                    })
                } else {
                    None
                }
            }
            cst::Primary::RInits(is) => {
                let rec: Vec<_> = is.iter().filter_map(|i| i.to_init(errs)).collect();
                if rec.len() == is.len() {
                    match construct_expr_record(rec, self.loc.clone()) {
                        Ok(expr) => Some(ExprOrSpecial::Expr {
                            expr,
                            loc: self.loc.clone(),
                        }),
                        Err(e) => {
                            errs.push(e);
                            None
                        }
                    }
                } else {
                    errs.push(self.to_ast_err(ToASTErrorKind::InvalidAttributesInRecordLiteral));
                    None
                }
            }
        }
    }

    /// convert `cst::Primary` representing a string literal to a `SmolStr`.
    pub fn to_string_literal(&self, errs: &mut ToASTErrors) -> Option<SmolStr> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let prim = self.as_inner()?;

        match prim {
            cst::Primary::Literal(lit) => lit.to_expr_or_special(errs)?.into_string_literal(errs),
            _ => None,
        }
    }
}

impl Node<Option<cst::Slot>> {
    fn into_expr(self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        match self.as_inner()?.try_into() {
            Ok(slot_id) => Some(
                ast::ExprBuilder::new()
                    .with_source_loc(self.loc)
                    .slot(slot_id),
            ),
            Err(e) => {
                errs.push(self.to_ast_err(e));
                None
            }
        }
    }
}

impl TryFrom<&cst::Slot> for ast::SlotId {
    type Error = ToASTErrorKind;

    fn try_from(slot: &cst::Slot) -> Result<Self, Self::Error> {
        match slot {
            cst::Slot::Principal => Ok(ast::SlotId::principal()),
            cst::Slot::Resource => Ok(ast::SlotId::resource()),
            cst::Slot::Other(slot) => Err(ToASTErrorKind::InvalidSlot(slot.clone())),
        }
    }
}

impl From<ast::SlotId> for cst::Slot {
    fn from(slot: ast::SlotId) -> cst::Slot {
        match slot {
            ast::SlotId(ast::ValidSlotId::Principal) => cst::Slot::Principal,
            ast::SlotId(ast::ValidSlotId::Resource) => cst::Slot::Resource,
        }
    }
}

impl Node<Option<cst::Name>> {
    /// Build type constraints
    fn to_type_constraint(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        match self.as_inner() {
            Some(_) => {
                errs.push(self.to_ast_err(ToASTErrorKind::TypeConstraints));
                None
            }
            None => Some(construct_expr_bool(true, self.loc.clone())),
        }
    }

    pub(crate) fn to_name(&self, errs: &mut ToASTErrors) -> Option<ast::Name> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let name = self.as_inner()?;

        let path: Vec<_> = name
            .path
            .iter()
            .filter_map(|i| i.to_valid_ident(errs))
            .collect();
        let maybe_name = name.name.to_valid_ident(errs);

        // computation and error generation is complete, so fail or construct
        match (maybe_name, path.len()) {
            (Some(r), len) if len == name.path.len() => {
                Some(construct_name(path, r, self.loc.clone()))
            }
            _ => None,
        }
    }
    fn to_ident(&self, errs: &mut ToASTErrors) -> Option<&cst::Ident> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let name = self.as_inner()?;

        for id in &name.path {
            // We don't need the actual ident, but we want to report an error
            // if they're invalid.
            id.to_valid_ident(errs);
        }

        if !name.path.is_empty() {
            errs.push(self.to_ast_err(ToASTErrorKind::InvalidPath));
            return None;
        }

        name.name.as_inner()
    }
    fn to_var(&self, errs: &mut ToASTErrors) -> Option<ast::Var> {
        let name = self.to_ident(errs)?;

        match name {
            cst::Ident::Principal => Some(ast::Var::Principal),
            cst::Ident::Action => Some(ast::Var::Action),
            cst::Ident::Resource => Some(ast::Var::Resource),
            cst::Ident::Context => Some(ast::Var::Context),
            n => {
                errs.push(self.to_ast_err(ToASTErrorKind::ArbitraryVariable(n.to_string().into())));
                None
            }
        }
    }
}

impl ast::Name {
    /// Convert the `Name` into a `String` attribute, which fails if it had any namespaces
    fn into_valid_attr(self, errs: &mut ToASTErrors, loc: Loc) -> Option<SmolStr> {
        if !self.path.is_empty() {
            errs.push(ToASTError::new(
                ToASTErrorKind::PathAsAttribute(self.to_string()),
                loc,
            ));
            None
        } else {
            Some(self.id.into_smolstr())
        }
    }

    /// If this name is a known extension function/method name or not
    pub(crate) fn is_known_extension_func_name(&self) -> bool {
        EXTENSION_STYLES.functions.contains(self)
            || (self.path.is_empty() && EXTENSION_STYLES.methods.contains(self.id.as_ref()))
    }

    fn into_func(
        self,
        args: Vec<ast::Expr>,
        errs: &mut ToASTErrors,
        loc: Loc,
    ) -> Option<ast::Expr> {
        // error on standard methods
        if self.path.is_empty() {
            let id = self.id.as_ref();
            if EXTENSION_STYLES.methods.contains(id)
                || matches!(id, "contains" | "containsAll" | "containsAny")
            {
                errs.push(ToASTError::new(
                    ToASTErrorKind::FunctionCallOnMethod(self.id),
                    loc,
                ));
                return None;
            }
        }
        if EXTENSION_STYLES.functions.contains(&self) {
            Some(construct_ext_func(self, args, loc))
        } else {
            errs.push(ToASTError::new(ToASTErrorKind::NotAFunction(self), loc));
            None
        }
    }
}

impl Node<Option<cst::Ref>> {
    /// convert `cst::Ref` to `ast::EntityUID`
    pub fn to_ref(&self, errs: &mut ToASTErrors) -> Option<ast::EntityUID> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let refr = self.as_inner()?;

        match refr {
            cst::Ref::Uid { path, eid } => {
                let maybe_path = path.to_name(errs);
                let maybe_eid = match eid
                    .as_valid_string(errs)
                    .map(|s| to_unescaped_string(s))
                    .transpose()
                {
                    Ok(opt) => opt,
                    Err(escape_errs) => {
                        errs.extend(
                            escape_errs
                                .into_iter()
                                .map(|e| self.to_ast_err(ToASTErrorKind::Unescape(e))),
                        );
                        None
                    }
                };

                match (maybe_path, maybe_eid) {
                    (Some(p), Some(e)) => Some(construct_refr(p, e, self.loc.clone())),
                    _ => None,
                }
            }
            cst::Ref::Ref { .. } => {
                errs.push(self.to_ast_err(ToASTErrorKind::UnsupportedEntityLiterals));
                None
            }
        }
    }
    fn to_expr(&self, errs: &mut ToASTErrors) -> Option<ast::Expr> {
        self.to_ref(errs)
            .map(|euid| construct_expr_ref(euid, self.loc.clone()))
    }
}

impl Node<Option<cst::Literal>> {
    fn to_expr_or_special(&self, errs: &mut ToASTErrors) -> Option<ExprOrSpecial<'_>> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let lit = self.as_inner()?;

        match lit {
            cst::Literal::True => Some(ExprOrSpecial::Expr {
                expr: construct_expr_bool(true, self.loc.clone()),
                loc: self.loc.clone(),
            }),
            cst::Literal::False => Some(ExprOrSpecial::Expr {
                expr: construct_expr_bool(false, self.loc.clone()),
                loc: self.loc.clone(),
            }),
            cst::Literal::Num(n) => match Integer::try_from(*n) {
                Ok(i) => Some(ExprOrSpecial::Expr {
                    expr: construct_expr_num(i, self.loc.clone()),
                    loc: self.loc.clone(),
                }),
                Err(_) => {
                    errs.push(self.to_ast_err(ToASTErrorKind::IntegerLiteralTooLarge(*n)));
                    None
                }
            },
            cst::Literal::Str(s) => {
                let maybe_str = s.as_valid_string(errs);
                maybe_str.map(|lit| ExprOrSpecial::StrLit {
                    lit,
                    loc: self.loc.clone(),
                })
            }
        }
    }
}

impl Node<Option<cst::RecInit>> {
    fn to_init(&self, errs: &mut ToASTErrors) -> Option<(SmolStr, ast::Expr)> {
        // if `self` doesn't have data, nothing we can do here, just propagate
        // the `None`; we don't need to signal an error, because one was already
        // signaled when the `Node` without data was created
        let lit = self.as_inner()?;

        let maybe_attr = lit.0.to_expr_or_special(errs)?.into_valid_attr(errs);
        let maybe_value = lit.1.to_expr(errs);

        match (maybe_attr, maybe_value) {
            (Some(s), Some(v)) => Some((s, v)),
            _ => None,
        }
    }
}

/// This section (construct_*) exists to handle differences between standard ast constructors and
/// the needs or conveniences here. Especially concerning source location data.
#[allow(clippy::too_many_arguments)]
fn construct_template_policy(
    id: ast::PolicyID,
    annotations: ast::Annotations,
    effect: ast::Effect,
    principal: ast::PrincipalConstraint,
    action: ast::ActionConstraint,
    resource: ast::ResourceConstraint,
    conds: Vec<ast::Expr>,
    loc: &Loc,
) -> ast::Template {
    let construct_template = |non_scope_constraint| {
        ast::Template::new(
            id,
            Some(loc.clone()),
            annotations,
            effect,
            principal,
            action,
            resource,
            non_scope_constraint,
        )
    };
    let mut conds_iter = conds.into_iter();
    if let Some(first_expr) = conds_iter.next() {
        // a left fold of conditions
        // e.g., [c1, c2, c3,] --> ((c1 && c2) && c3)
        construct_template(match conds_iter.next() {
            Some(e) => construct_expr_and(first_expr, e, conds_iter, loc),
            None => first_expr,
        })
    } else {
        // use `true` to mark the absence of non-scope constraints
        construct_template(construct_expr_bool(true, loc.clone()))
    }
}
fn construct_string_from_var(v: ast::Var) -> SmolStr {
    match v {
        ast::Var::Principal => "principal".into(),
        ast::Var::Action => "action".into(),
        ast::Var::Resource => "resource".into(),
        ast::Var::Context => "context".into(),
    }
}
fn construct_name(path: Vec<ast::Id>, id: ast::Id, loc: Loc) -> ast::Name {
    ast::Name {
        id,
        path: Arc::new(path),
        loc: Some(loc),
    }
}
fn construct_refr(p: ast::Name, n: SmolStr, loc: Loc) -> ast::EntityUID {
    let eid = ast::Eid::new(n);
    ast::EntityUID::from_components(p, eid, Some(loc))
}
fn construct_expr_ref(r: ast::EntityUID, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).val(r)
}
fn construct_expr_num(n: Integer, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).val(n)
}
fn construct_expr_string(s: SmolStr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).val(s)
}
fn construct_expr_bool(b: bool, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).val(b)
}
fn construct_expr_neg(e: ast::Expr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).neg(e)
}
fn construct_expr_not(e: ast::Expr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).not(e)
}
fn construct_expr_var(v: ast::Var, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).var(v)
}
fn construct_expr_if(i: ast::Expr, t: ast::Expr, e: ast::Expr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).ite(i, t, e)
}
fn construct_expr_or(
    f: ast::Expr,
    s: ast::Expr,
    chained: impl IntoIterator<Item = ast::Expr>,
    loc: &Loc,
) -> ast::Expr {
    let first = ast::ExprBuilder::new()
        .with_source_loc(loc.clone())
        .or(f, s);
    chained.into_iter().fold(first, |a, n| {
        ast::ExprBuilder::new()
            .with_source_loc(loc.clone())
            .or(a, n)
    })
}
fn construct_expr_and(
    f: ast::Expr,
    s: ast::Expr,
    chained: impl IntoIterator<Item = ast::Expr>,
    loc: &Loc,
) -> ast::Expr {
    let first = ast::ExprBuilder::new()
        .with_source_loc(loc.clone())
        .and(f, s);
    chained.into_iter().fold(first, |a, n| {
        ast::ExprBuilder::new()
            .with_source_loc(loc.clone())
            .and(a, n)
    })
}
fn construct_expr_rel(
    f: ast::Expr,
    rel: cst::RelOp,
    s: ast::Expr,
    loc: Loc,
    errs: &mut ToASTErrors,
) -> Option<ast::Expr> {
    let builder = ast::ExprBuilder::new().with_source_loc(loc.clone());
    match rel {
        cst::RelOp::Less => Some(builder.less(f, s)),
        cst::RelOp::LessEq => Some(builder.lesseq(f, s)),
        cst::RelOp::GreaterEq => Some(builder.greatereq(f, s)),
        cst::RelOp::Greater => Some(builder.greater(f, s)),
        cst::RelOp::NotEq => Some(builder.noteq(f, s)),
        cst::RelOp::Eq => Some(builder.is_eq(f, s)),
        cst::RelOp::In => Some(builder.is_in(f, s)),
        cst::RelOp::InvalidSingleEq => {
            errs.push(ToASTError::new(ToASTErrorKind::InvalidSingleEq, loc));
            None
        }
    }
}
/// used for a chain of addition and/or subtraction
fn construct_expr_add(
    f: ast::Expr,
    chained: impl IntoIterator<Item = (cst::AddOp, ast::Expr)>,
    loc: &Loc,
) -> ast::Expr {
    let mut expr = f;
    for (op, next_expr) in chained {
        let builder = ast::ExprBuilder::new().with_source_loc(loc.clone());
        expr = match op {
            cst::AddOp::Plus => builder.add(expr, next_expr),
            cst::AddOp::Minus => builder.sub(expr, next_expr),
        };
    }
    expr
}
/// used for a chain of multiplication only (no division or mod)
fn construct_expr_mul(
    f: ast::Expr,
    chained: impl IntoIterator<Item = ast::Expr>,
    loc: &Loc,
) -> ast::Expr {
    let mut expr = f;
    for next_expr in chained {
        expr = ast::ExprBuilder::new()
            .with_source_loc(loc.clone())
            .mul(expr, next_expr);
    }
    expr
}
fn construct_expr_has(t: ast::Expr, s: SmolStr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).has_attr(t, s)
}
fn construct_expr_attr(e: ast::Expr, s: SmolStr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).get_attr(e, s)
}
fn construct_expr_like(e: ast::Expr, s: Vec<PatternElem>, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).like(e, s)
}
fn construct_expr_is(e: ast::Expr, n: ast::Name, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new()
        .with_source_loc(loc)
        .is_entity_type(e, n)
}
fn construct_ext_func(name: ast::Name, args: Vec<ast::Expr>, loc: Loc) -> ast::Expr {
    // INVARIANT (MethodStyleArgs): CallStyle is not MethodStyle, so any args vector is fine
    ast::ExprBuilder::new()
        .with_source_loc(loc)
        .call_extension_fn(name, args)
}

fn construct_method_contains(e0: ast::Expr, e1: ast::Expr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new()
        .with_source_loc(loc)
        .contains(e0, e1)
}
fn construct_method_contains_all(e0: ast::Expr, e1: ast::Expr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new()
        .with_source_loc(loc)
        .contains_all(e0, e1)
}
fn construct_method_contains_any(e0: ast::Expr, e1: ast::Expr, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new()
        .with_source_loc(loc)
        .contains_any(e0, e1)
}

// INVARIANT (MethodStyleArgs), args must be non-empty
fn construct_ext_meth(n: String, args: Vec<ast::Expr>, loc: Loc) -> ast::Expr {
    let id = ast::Id::new_unchecked(n);
    let name = ast::Name::unqualified_name(id);
    // INVARIANT (MethodStyleArgs), args must be non-empty
    ast::ExprBuilder::new()
        .with_source_loc(loc)
        .call_extension_fn(name, args)
}
fn construct_expr_set(s: Vec<ast::Expr>, loc: Loc) -> ast::Expr {
    ast::ExprBuilder::new().with_source_loc(loc).set(s)
}
fn construct_expr_record(
    kvs: Vec<(SmolStr, ast::Expr)>,
    loc: Loc,
) -> Result<ast::Expr, ToASTError> {
    ast::ExprBuilder::new()
        .with_source_loc(loc.clone())
        .record(kvs)
        .map_err(|e| ToASTError::new(e.into(), loc))
}

// PANIC SAFETY: Unit Test Code
#[allow(clippy::panic)]
// PANIC SAFETY: Unit Test Code
#[allow(clippy::indexing_slicing)]
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        ast::Expr,
        parser::{err::ParseErrors, test_utils::*, *},
        test_utils::*,
    };
    use cool_asserts::assert_matches;
    use std::str::FromStr;

    #[track_caller]
    fn assert_parse_expr_succeeds(text: &str) -> Expr {
        let mut errs = vec![];
        let expr = text_to_cst::parse_expr(text)
            .expect("failed parser")
            .to_expr(&mut errs)
            .unwrap_or_else(|| {
                panic!(
                    "failed conversion to AST:\n{:?}",
                    miette::Report::new(ParseErrors::from(errs.clone()))
                )
            });
        assert!(errs.is_empty());
        expr
    }

    #[track_caller]
    fn assert_parse_expr_fails(text: &str) -> ParseErrors {
        let mut errs = vec![];
        let result = text_to_cst::parse_expr(text)
            .expect("failed parser")
            .to_expr(&mut errs);
        match result {
            Some(expr) => {
                panic!("conversion to AST should have failed, but succeeded with:\n{expr}")
            }
            None => errs.into(),
        }
    }

    #[track_caller]
    fn assert_parse_policy_succeeds(text: &str) -> ast::StaticPolicy {
        let expr = text_to_cst::parse_policy(text)
            .expect("failed parser")
            .to_policy(ast::PolicyID::from_string("id"))
            .unwrap_or_else(|errs| {
                panic!("failed conversion to AST:\n{:?}", miette::Report::new(errs))
            });
        expr
    }

    #[track_caller]
    fn assert_parse_policy_fails(text: &str) -> ParseErrors {
        let result = text_to_cst::parse_policy(text)
            .expect("failed parser")
            .to_policy(ast::PolicyID::from_string("id"));
        match result {
            Ok(policy) => {
                panic!("conversion to AST should have failed, but succeeded with:\n{policy}")
            }
            Err(errs) => errs,
        }
    }

    #[test]
    fn show_expr1() {
        assert_parse_expr_succeeds(
            r#"
            if 7 then 6 > 5 else !5 || "thursday" && ((8) >= "fish")
        "#,
        );
    }

    #[test]
    fn show_expr2() {
        assert_parse_expr_succeeds(
            r#"
            [2,3,4].foo["hello"]
        "#,
        );
    }

    #[test]
    fn show_expr3() {
        // these exprs are ill-typed, but are allowed by the parser
        let expr = assert_parse_expr_succeeds(
            r#"
            "first".some_ident
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::GetAttr { attr, .. } => {
            assert_eq!(attr, "some_ident");
        });
    }

    #[test]
    fn show_expr4() {
        let expr = assert_parse_expr_succeeds(
            r#"
            1.some_ident
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::GetAttr { attr, .. } => {
            assert_eq!(attr, "some_ident");
        });
    }

    #[test]
    fn show_expr5() {
        let expr = assert_parse_expr_succeeds(
            r#"
            "first"["some string"]
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::GetAttr { attr, .. } => {
            assert_eq!(attr, "some string");
        });
    }

    #[test]
    fn show_expr6() {
        let expr = assert_parse_expr_succeeds(
            r#"
            {"one":1,"two":2} has one
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::HasAttr { attr, .. } => {
            assert_eq!(attr, "one");
        });
    }

    #[test]
    fn show_expr7() {
        let expr = assert_parse_expr_succeeds(
            r#"
            {"one":1,"two":2}.one
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::GetAttr { attr, .. } => {
            assert_eq!(attr, "one");
        });
    }

    #[test]
    fn show_expr8() {
        // parses to the same AST expression as above
        let expr = assert_parse_expr_succeeds(
            r#"
            {"one":1,"two":2}["one"]
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::GetAttr { attr, .. } => {
            assert_eq!(attr, "one");
        });
    }

    #[test]
    fn show_expr9() {
        // accessing a record with a non-identifier attribute
        let expr = assert_parse_expr_succeeds(
            r#"
            {"this is a valid map key+.-_%()":1,"two":2}["this is a valid map key+.-_%()"]
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::GetAttr { attr, .. } => {
            assert_eq!(attr, "this is a valid map key+.-_%()");
        });
    }

    #[test]
    fn show_expr10() {
        let src = r#"
            {if true then a else b:"b"} ||
            {if false then a else b:"b"}
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 6);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("record literal has invalid attributes")
                .exactly_one_underline("{if true then a else b:\"b\"}")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("record literal has invalid attributes")
                .exactly_one_underline("{if false then a else b:\"b\"}")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("arbitrary variables are not supported; the valid Cedar variables are `principal`, `action`, `resource`, and `context`")
                .help("did you mean to enclose `a` in quotes to make a string?")
                .exactly_one_underline("a")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("arbitrary variables are not supported; the valid Cedar variables are `principal`, `action`, `resource`, and `context`")
                .help("did you mean to enclose `b` in quotes to make a string?")
                .exactly_one_underline("b")
                .build(),
        );
    }

    #[test]
    fn show_expr11() {
        let expr = assert_parse_expr_succeeds(
            r#"
            {principal:"principal"}
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::Record { .. });
    }

    #[test]
    fn show_expr12() {
        let expr = assert_parse_expr_succeeds(
            r#"
            {"principal":"principal"}
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::Record { .. });
    }

    #[test]
    fn reserved_idents1() {
        let src = r#"
            The::true::path::to::"enlightenment".false
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 2);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `true`",
            )
            .exactly_one_underline("true")
            .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `false`",
            )
            .exactly_one_underline("false")
            .build(),
        );
    }

    #[test]
    fn reserved_idents2() {
        let src = r#"
            if {if: true}.if then {"if":false}["if"] else {when:true}.permit
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 3);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `if`",
            )
            .exactly_one_underline("if: true")
            .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `if`",
            )
            .exactly_one_underline("if")
            .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("record literal has invalid attributes")
                .exactly_one_underline("{if: true}")
                .build(),
        );
    }

    #[test]
    fn reserved_idents3() {
        let src = r#"
            if {where: true}.like || {has:false}.in then {"like":false}["in"] else {then:true}.else
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 7);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `has`",
            )
            .exactly_one_underline("has")
            .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `like`",
            )
            .exactly_one_underline("like")
            .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `in`",
            )
            .exactly_one_underline("in")
            .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `then`",
            )
            .exactly_one_underline("then")
            .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `else`",
            )
            .exactly_one_underline("else")
            .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("record literal has invalid attributes")
                .exactly_one_underline("{has:false}")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("record literal has invalid attributes")
                .exactly_one_underline("{then:true}")
                .build(),
        );
    }

    #[test]
    fn show_policy1() {
        let src = r#"
            permit(principal:p,action:a,resource:r)when{w}unless{u}advice{"doit"};
        "#;
        let errs = assert_parse_policy_fails(src);
        expect_n_errors(src, &errs, 6);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("type constraints using `:` are not supported")
                .help("try using `is` instead")
                .exactly_one_underline("p")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("type constraints using `:` are not supported")
                .help("try using `is` instead")
                .exactly_one_underline("a")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("type constraints using `:` are not supported")
                .help("try using `is` instead")
                .exactly_one_underline("r")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("arbitrary variables are not supported; the valid Cedar variables are `principal`, `action`, `resource`, and `context`")
                .help("did you mean to enclose `w` in quotes to make a string?")
                .exactly_one_underline("w")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("arbitrary variables are not supported; the valid Cedar variables are `principal`, `action`, `resource`, and `context`")
                .help("did you mean to enclose `u` in quotes to make a string?")
                .exactly_one_underline("u")
                .build(),
        );
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("not a valid policy condition: `advice`")
                .help("condition must be either `when` or `unless`")
                .exactly_one_underline("advice")
                .build(),
        );
    }

    #[test]
    fn show_policy2() {
        let src = r#"
            permit(principal,action,resource)when{true};
        "#;
        assert_parse_policy_succeeds(src);
    }

    #[test]
    fn show_policy3() {
        let src = r#"
            permit(principal in User::"jane",action,resource);
        "#;
        assert_parse_policy_succeeds(src);
    }

    #[test]
    fn show_policy4() {
        let src = r#"
            forbid(principal in User::"jane",action,resource)unless{
                context.group != "friends"
            };
        "#;
        assert_parse_policy_succeeds(src);
    }

    #[test]
    fn policy_annotations() {
        // common use-case
        let policy = assert_parse_policy_succeeds(
            r#"
            @anno("good annotation")permit(principal,action,resource);
        "#,
        );
        assert_matches!(
            policy.annotation(&ast::AnyId::new_unchecked("anno")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "good annotation")
        );

        // duplication is error
        let src = r#"
            @anno("good annotation")
            @anno2("good annotation")
            @anno("oops, duplicate")
            permit(principal,action,resource);
        "#;
        let errs = assert_parse_policy_fails(src);
        // annotation duplication (anno)
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("duplicate annotation: @anno")
                .exactly_one_underline("@anno(\"oops, duplicate\")")
                .build(),
        );

        // can have multiple annotations
        let policyset = text_to_cst::parse_policies(
            r#"
            @anno1("first")
            permit(principal,action,resource);

            @anno2("second")
            permit(principal,action,resource);

            @anno3a("third-a")
            @anno3b("third-b")
            permit(principal,action,resource);
        "#,
        )
        .expect("should parse")
        .to_policyset()
        .unwrap_or_else(|errs| panic!("failed convert to AST:\n{:?}", miette::Report::new(errs)));
        assert_matches!(
            policyset
                .get(&ast::PolicyID::from_string("policy0"))
                .expect("should be a policy")
                .annotation(&ast::AnyId::new_unchecked("anno0")),
            None
        );
        assert_matches!(
            policyset
                .get(&ast::PolicyID::from_string("policy0"))
                .expect("should be a policy")
                .annotation(&ast::AnyId::new_unchecked("anno1")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "first")
        );
        assert_matches!(
            policyset
                .get(&ast::PolicyID::from_string("policy1"))
                .expect("should be a policy")
                .annotation(&ast::AnyId::new_unchecked("anno2")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "second")
        );
        assert_matches!(
            policyset
                .get(&ast::PolicyID::from_string("policy2"))
                .expect("should be a policy")
                .annotation(&ast::AnyId::new_unchecked("anno3a")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "third-a")
        );
        assert_matches!(
            policyset
                .get(&ast::PolicyID::from_string("policy2"))
                .expect("should be a policy")
                .annotation(&ast::AnyId::new_unchecked("anno3b")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "third-b")
        );
        assert_matches!(
            policyset
                .get(&ast::PolicyID::from_string("policy2"))
                .expect("should be a policy")
                .annotation(&ast::AnyId::new_unchecked("anno3c")),
            None
        );
        assert_eq!(
            policyset
                .get(&ast::PolicyID::from_string("policy2"))
                .expect("should be a policy")
                .annotations()
                .count(),
            2
        );

        // can't have spaces or '+' in annotation keys
        assert_matches!(
            text_to_cst::parse_policy(
                r#"
            @hi mom("this should be invalid")
            permit(principal, action, resource);
            "#,
            ),
            Err(_)
        );
        assert_matches!(
            text_to_cst::parse_policy(
                r#"
            @hi+mom("this should be invalid")
            permit(principal, action, resource);
            "#,
            ),
            Err(_)
        );

        // can have Cedar reserved words as annotation keys
        let policyset = text_to_cst::parse_policies(
            r#"
            @if("this is the annotation for `if`")
            @then("this is the annotation for `then`")
            @else("this is the annotation for `else`")
            @true("this is the annotation for `true`")
            @false("this is the annotation for `false`")
            @in("this is the annotation for `in`")
            @is("this is the annotation for `is`")
            @like("this is the annotation for `like`")
            @has("this is the annotation for `has`")
            @principal("this is the annotation for `principal`") // not reserved at time of this writing, but we test it anyway
            permit(principal, action, resource);
            "#,
        ).expect("should parse")
        .to_policyset()
        .unwrap_or_else(|errs| panic!("failed convert to AST:\n{:?}", miette::Report::new(errs)));
        let policy0 = policyset
            .get(&ast::PolicyID::from_string("policy0"))
            .expect("should be the right policy ID");
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("if")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `if`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("then")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `then`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("else")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `else`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("true")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `true`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("false")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `false`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("in")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `in`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("is")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `is`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("like")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `like`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("has")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `has`")
        );
        assert_matches!(
            policy0.annotation(&ast::AnyId::new_unchecked("principal")),
            Some(ast::Annotation { val, .. }) => assert_eq!(val.as_ref(), "this is the annotation for `principal`")
        );
    }

    #[test]
    fn fail_scope1() {
        let src = r#"
            permit(
                principal in [User::"jane",Group::"friends"],
                action,
                resource
            );
        "#;
        let errs = assert_parse_policy_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "expected single entity uid or template slot, got: set of entity uids",
            )
            .exactly_one_underline(r#"[User::"jane",Group::"friends"]"#)
            .build(),
        );
    }

    #[test]
    fn fail_scope2() {
        let src = r#"
            permit(
                principal in User::"jane",
                action == if true then Photo::"view" else Photo::"edit",
                resource
            );
        "#;
        let errs = assert_parse_policy_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("expected an entity uid, found an `if` expression")
                .exactly_one_underline(r#"if true then Photo::"view" else Photo::"edit""#)
                .build(),
        );
    }

    #[test]
    fn fail_scope3() {
        let src = r#"
            permit(principal,action,resource,context);
        "#;
        let errs = assert_parse_policy_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "this policy has an extra constraint in the scope: `context`",
            )
            .help("a policy must have exactly `principal`, `action`, and `resource` constraints")
            .exactly_one_underline("context")
            .build(),
        );
    }

    #[test]
    fn method_call2() {
        assert_parse_expr_succeeds(
            r#"
                principal.contains(resource)
                "#,
        );

        let src = r#"
        contains(principal,resource)
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("`contains` is a method, not a function")
                .help("use a method-style call: `e.contains(..)`")
                .exactly_one_underline("contains(principal,resource)")
                .build(),
        );
    }

    #[test]
    fn construct_record_1() {
        let e = assert_parse_expr_succeeds(
            r#"
                {one:"one"}
                "#,
        );
        // ast should be acceptable, with record construction
        assert_matches!(e.expr_kind(), ast::ExprKind::Record { .. });
        println!("{e}");
    }

    #[test]
    fn construct_record_2() {
        let e = assert_parse_expr_succeeds(
            r#"
                {"one":"one"}
                "#,
        );
        // ast should be acceptable, with record construction
        assert_matches!(e.expr_kind(), ast::ExprKind::Record { .. });
        println!("{e}");
    }

    #[test]
    fn construct_record_3() {
        let e = assert_parse_expr_succeeds(
            r#"
                {"one":"one",two:"two"}
                "#,
        );
        // ast should be acceptable, with record construction
        assert_matches!(e.expr_kind(), ast::ExprKind::Record { .. });
        println!("{e}");
    }

    #[test]
    fn construct_record_4() {
        let e = assert_parse_expr_succeeds(
            r#"
                {one:"one","two":"two"}
                "#,
        );
        // ast should be acceptable, with record construction
        assert_matches!(e.expr_kind(), ast::ExprKind::Record { .. });
        println!("{e}");
    }

    #[test]
    fn construct_record_5() {
        let e = assert_parse_expr_succeeds(
            r#"
                {one:"b\"","b\"":2}
                "#,
        );
        // ast should be acceptable, with record construction
        assert_matches!(e.expr_kind(), ast::ExprKind::Record { .. });
        println!("{e}");
    }

    #[test]
    fn construct_invalid_get_1() {
        let src = r#"
            {"one":1, "two":"two"}[0]
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("invalid string literal: `0`")
                .exactly_one_underline("0")
                .build(),
        );
    }

    #[test]
    fn construct_invalid_get_2() {
        let src = r#"
            {"one":1, "two":"two"}[-1]
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("invalid string literal: `(-1)`")
                .exactly_one_underline("-1")
                .build(),
        );
    }

    #[test]
    fn construct_invalid_get_3() {
        let src = r#"
            {"one":1, "two":"two"}[true]
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("invalid string literal: `true`")
                .exactly_one_underline("true")
                .build(),
        );
    }

    #[test]
    fn construct_invalid_get_4() {
        let src = r#"
            {"one":1, "two":"two"}[one]
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("invalid string literal: `one`")
                .exactly_one_underline("one")
                .build(),
        );
    }

    #[test]
    fn construct_has_1() {
        let expr = assert_parse_expr_succeeds(
            r#"
            {"one":1,"two":2} has "arbitrary+ _string"
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::HasAttr { attr, .. } => {
            assert_eq!(attr, "arbitrary+ _string");
        });
    }

    #[test]
    fn construct_has_2() {
        let src = r#"
            {"one":1,"two":2} has 1
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("not a valid attribute name: `1`")
                .help("attribute names can either be identifiers or string literals")
                .exactly_one_underline("1")
                .build(),
        );
    }

    #[test]
    fn construct_like_1() {
        let expr = assert_parse_expr_succeeds(
            r#"
            "354 hams" like "*5*"
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::Like { pattern, .. } => {
            assert_eq!(pattern.to_string(), "*5*");
        });
    }

    #[test]
    fn construct_like_2() {
        let src = r#"
            "354 hams" like 354
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error(
                "right hand side of a `like` expression must be a pattern literal, but got `354`",
            )
            .exactly_one_underline("354")
            .build(),
        );
    }

    #[test]
    fn construct_like_3() {
        let expr = assert_parse_expr_succeeds(
            r#"
            "string\\with\\backslashes" like "string\\with\\backslashes"
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::Like { pattern, .. } => {
            assert_eq!(pattern.to_string(), r"string\\with\\backslashes");
        });
    }

    #[test]
    fn construct_like_4() {
        let expr = assert_parse_expr_succeeds(
            r#"
            "string\\with\\backslashes" like "string\*with\*backslashes"
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::Like { pattern, .. } => {
            assert_eq!(pattern.to_string(), r"string\*with\*backslashes");
        });
    }

    #[test]
    fn construct_like_5() {
        let src = r#"
            "string\*with\*escaped\*stars" like "string\*with\*escaped\*stars"
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 3);
        // all three errors are the same -- they report a use of \* in the first argument
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("the input `\\*` is not a valid escape")
                .exactly_one_underline(r#""string\*with\*escaped\*stars""#)
                .build(),
        );
    }

    #[test]
    fn construct_like_6() {
        let expr = assert_parse_expr_succeeds(
            r#"
            "string*with*stars" like "string\*with\*stars"
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::Like { pattern, .. } => {
            assert_eq!(pattern.to_string(), "string\\*with\\*stars");
        });
    }

    #[test]
    fn construct_like_7() {
        let expr = assert_parse_expr_succeeds(
            r#"
            "string\\*with\\*backslashes\\*and\\*stars" like "string\\\*with\\\*backslashes\\\*and\\\*stars"
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::Like { pattern, .. } => {
            assert_eq!(
                pattern.to_string(),
                r"string\\\*with\\\*backslashes\\\*and\\\*stars"
            );
        });
    }

    #[test]
    fn pattern_roundtrip() {
        let test_pattern = &vec![
            PatternElem::Char('h'),
            PatternElem::Char('e'),
            PatternElem::Char('l'),
            PatternElem::Char('l'),
            PatternElem::Char('o'),
            PatternElem::Char('\\'),
            PatternElem::Char('0'),
            PatternElem::Char('*'),
            PatternElem::Char('\\'),
            PatternElem::Char('*'),
        ];
        let e1 = ast::Expr::like(ast::Expr::val("hello"), test_pattern.clone());
        let s1 = format!("{e1}");
        // Char('\\') prints to r#"\\"# and Char('*') prints to r#"\*"#.
        assert_eq!(s1, r#""hello" like "hello\\0\*\\\*""#);
        let e2 = assert_parse_expr_succeeds(&s1);
        assert_matches!(e2.expr_kind(), ast::ExprKind::Like { pattern, .. } => {
            assert_eq!(pattern.get_elems(), test_pattern);
        });
        let s2 = format!("{e2}");
        assert_eq!(s1, s2);
    }

    #[test]
    fn issue_wf_5046() {
        let policy = parse_policy(
            Some("WF-5046".into()),
            r#"permit(
            principal,
            action in [Action::"action"],
            resource in G::""
          ) when {
            true && ("" like "/gisterNatives\\*D")
          };"#,
        );
        assert!(policy.is_ok());
    }

    #[test]
    fn entity_access() {
        // entities can be accessed using the same notation as records

        // ok
        let expr = assert_parse_expr_succeeds(
            r#"
            User::"jane" has age
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::HasAttr { attr, .. } => {
            assert_eq!(attr, "age");
        });

        // ok
        let expr = assert_parse_expr_succeeds(
            r#"
            User::"jane" has "arbitrary+ _string"
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::HasAttr { attr, .. } => {
            assert_eq!(attr, "arbitrary+ _string");
        });

        // not ok: 1 is not a valid attribute
        let src = r#"
            User::"jane" has 1
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("not a valid attribute name: `1`")
                .help("attribute names can either be identifiers or string literals")
                .exactly_one_underline("1")
                .build(),
        );

        // ok
        let expr = assert_parse_expr_succeeds(
            r#"
            User::"jane".age
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::GetAttr { attr, .. } => {
            assert_eq!(attr, "age");
        });

        // ok
        let expr: ast::Expr = assert_parse_expr_succeeds(
            r#"
            User::"jane"["arbitrary+ _string"]
        "#,
        );
        assert_matches!(expr.expr_kind(), ast::ExprKind::GetAttr { attr, .. } => {
            assert_eq!(attr, "arbitrary+ _string");
        });

        // not ok: age is not a string literal
        let src = r#"
            User::"jane"[age]
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("invalid string literal: `age`")
                .exactly_one_underline("age")
                .build(),
        );
    }

    #[test]
    fn relational_ops1() {
        let src = r#"
            3 >= 2 >= 1
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("multiple relational operators (>, ==, in, etc.) must be used with parentheses to make ordering explicit")
                .exactly_one_underline("3 >= 2 >= 1")
                .build(),
        );
    }

    #[test]
    fn relational_ops2() {
        assert_parse_expr_succeeds(
            r#"
                    3 >= ("dad" in "dad")
                    "#,
        );
    }

    #[test]
    fn relational_ops3() {
        assert_parse_expr_succeeds(
            r#"
                (3 >= 2) == true
                "#,
        );
    }

    #[test]
    fn relational_ops4() {
        let src = r#"
            if 4 < 3 then 4 != 3 else 4 == 3 < 4
        "#;
        let errs = assert_parse_expr_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("multiple relational operators (>, ==, in, etc.) must be used with parentheses to make ordering explicit")
                .exactly_one_underline("4 == 3 < 4")
                .build(),
        );
    }

    #[test]
    fn arithmetic() {
        assert_parse_expr_succeeds(r#" 2 + 4 "#);
        assert_parse_expr_succeeds(r#" 2 + -5 "#);
        assert_parse_expr_succeeds(r#" 2 - 5 "#);
        assert_parse_expr_succeeds(r#" 2 * 5 "#);
        assert_parse_expr_succeeds(r#" 2 * -5 "#);
        assert_parse_expr_succeeds(r#" context.size * 4 "#);
        assert_parse_expr_succeeds(r#" 4 * context.size "#);
        assert_parse_expr_succeeds(r#" context.size * context.scale "#);
        assert_parse_expr_succeeds(r#" 5 + 10 + 90 "#);
        assert_parse_expr_succeeds(r#" 5 + 10 - 90 * -2 "#);
        assert_parse_expr_succeeds(r#" 5 + 10 * 90 - 2 "#);
        assert_parse_expr_succeeds(r#" 5 - 10 - 90 - 2 "#);
        assert_parse_expr_succeeds(r#" 5 * context.size * 10 "#);
        assert_parse_expr_succeeds(r#" context.size * 3 * context.scale "#);
    }

    const CORRECT_TEMPLATES: [&str; 7] = [
        r#"permit(principal == ?principal, action == Action::"action", resource == ?resource);"#,
        r#"permit(principal in ?principal, action == Action::"action", resource in ?resource);"#,
        r#"permit(principal in ?principal, action == Action::"action", resource in ?resource);"#,
        r#"permit(principal in p::"principal", action == Action::"action", resource in ?resource);"#,
        r#"permit(principal == p::"principal", action == Action::"action", resource in ?resource);"#,
        r#"permit(principal in ?principal, action == Action::"action", resource in r::"resource");"#,
        r#"permit(principal in ?principal, action == Action::"action", resource == r::"resource");"#,
    ];

    #[test]
    fn template_tests() {
        for src in CORRECT_TEMPLATES {
            text_to_cst::parse_policy(src)
                .expect("parse_error")
                .to_policy_template(ast::PolicyID::from_string("i0"))
                .unwrap_or_else(|errs| {
                    panic!("Failed to create a policy template: {:?}", errs);
                });
        }
    }

    #[test]
    fn var_type() {
        assert_parse_policy_succeeds(
            r#"
                permit(principal,action,resource);
                "#,
        );

        let src = r#"
            permit(principal:User,action,resource);
        "#;
        let errs = assert_parse_policy_fails(src);
        expect_n_errors(src, &errs, 1);
        expect_some_error_matches(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("type constraints using `:` are not supported")
                .help("try using `is` instead")
                .exactly_one_underline("User")
                .build(),
        );
    }

    #[test]
    fn unescape_err_positions() {
        let assert_invalid_escape = |p_src, underline| {
            assert_matches!(parse_policy_template(None, p_src), Err(e) => {
                expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("the input `\\q` is not a valid escape").exactly_one_underline(underline).build());
            });
        };
        assert_invalid_escape(
            r#"@foo("\q")permit(principal, action, resource);"#,
            r#"@foo("\q")"#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "\q" };"#,
            r#""\q""#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "\q".contains(0) };"#,
            r#""\q".contains(0)"#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "\q".bar };"#,
            r#""\q".bar"#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "\q"["a"] };"#,
            r#""\q"["a"]"#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "" like "\q" };"#,
            r#""\q""#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { {}["\q"] };"#,
            r#""\q""#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { {"\q": 0} };"#,
            r#""\q""#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { User::"\q" };"#,
            r#"User::"\q""#,
        );
    }

    #[track_caller] // report the caller's location as the location of the panic, not the location in this function
    fn expect_action_error(test: &str, euid_strs: Vec<&str>, underlines: Vec<&str>) {
        let euids = euid_strs
            .iter()
            .map(|euid_str| {
                EntityUID::from_str(euid_str).expect("Test was provided with invalid euid")
            })
            .collect::<Vec<_>>();
        assert_matches!(parse_policyset(test), Err(es) => {
            assert_eq!(es.len(), euids.len(),
                "should have produced exactly {} parse errors, produced {}:\n{:?}",
                euids.len(),
                es.len(),
                miette::Report::new(es)
            );
            for (euid, underline) in euids.into_iter().zip(underlines.into_iter()) {
                expect_some_error_matches(
                    test,
                    &es,
                    &ExpectedErrorMessageBuilder::error(&format!("expected an entity uid with the type `Action` but got `{euid}`")).help(
                        "action entities must have type `Action`, optionally in a namespace",
                    ).exactly_one_underline(underline).build(),
                );
            }
        });
    }

    #[test]
    fn action_checker() {
        let euid = EntityUID::from_str("Action::\"view\"").unwrap();
        assert!(euid_has_action_type(&euid));
        let euid = EntityUID::from_str("Foo::Action::\"view\"").unwrap();
        assert!(euid_has_action_type(&euid));
        let euid = EntityUID::from_str("Foo::\"view\"").unwrap();
        assert!(!euid_has_action_type(&euid));
        let euid = EntityUID::from_str("Action::Foo::\"view\"").unwrap();
        assert!(!euid_has_action_type(&euid));
    }

    #[test]
    fn action_must_be_action() {
        parse_policyset(r#"permit(principal, action == Action::"view", resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(r#"permit(principal, action == Foo::Action::"view", resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(r#"permit(principal, action in Action::"view", resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(r#"permit(principal, action in Foo::Action::"view", resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(r#"permit(principal, action in [Foo::Action::"view"], resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(
            r#"permit(principal, action in [Foo::Action::"view", Action::"view"], resource);"#,
        )
        .expect("Valid policy failed to parse");
        expect_action_error(
            r#"permit(principal, action == Foo::"view", resource);"#,
            vec!["Foo::\"view\""],
            vec!["action == Foo::\"view\""], // TODO: don't underline the `action ==` part
        );
        expect_action_error(
            r#"permit(principal, action == Action::Foo::"view", resource);"#,
            vec!["Action::Foo::\"view\""],
            vec!["action == Action::Foo::\"view\""], // TODO: don't underline the `action ==` part
        );
        expect_action_error(
            r#"permit(principal, action == Bar::Action::Foo::"view", resource);"#,
            vec!["Bar::Action::Foo::\"view\""],
            vec!["action == Bar::Action::Foo::\"view\""], // TODO: don't underline the `action ==` part
        );
        expect_action_error(
            r#"permit(principal, action in Bar::Action::Foo::"view", resource);"#,
            vec!["Bar::Action::Foo::\"view\""],
            vec!["action in Bar::Action::Foo::\"view\""], // TODO: don't underline the `action in` part
        );
        expect_action_error(
            r#"permit(principal, action in [Bar::Action::Foo::"view"], resource);"#,
            vec!["Bar::Action::Foo::\"view\""],
            vec!["action in [Bar::Action::Foo::\"view\"]"], // TODO: don't underline the `action in` part
        );
        expect_action_error(
            r#"permit(principal, action in [Bar::Action::Foo::"view", Action::"check"], resource);"#,
            vec!["Bar::Action::Foo::\"view\""],
            vec!["action in [Bar::Action::Foo::\"view\", Action::\"check\"]"], // TODO: don't underline the `action in` part
        );
        expect_action_error(
            r#"permit(principal, action in [Bar::Action::Foo::"view", Foo::"delete", Action::"check"], resource);"#,
            vec!["Bar::Action::Foo::\"view\"", "Foo::\"delete\""],
            vec!["action in [Bar::Action::Foo::\"view\", Foo::\"delete\", Action::\"check\"]"], // TODO: don't underline the `action in` part
        );
    }

    #[test]
    fn method_style() {
        let src = r#"permit(principal, action, resource)
            when { contains(true) < 1 };"#;
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_n_errors(src, &e, 1);
            expect_some_error_matches(src, &e, &ExpectedErrorMessageBuilder::error(
                "`contains` is a method, not a function",
            ).help(
                "use a method-style call: `e.contains(..)`",
            ).exactly_one_underline("contains(true)").build());
        });
    }

    #[test]
    fn test_mul() {
        for (str, expected) in [
            ("--2*3", Expr::mul(Expr::neg(Expr::val(-2)), Expr::val(3))),
            (
                "1 * 2 * false",
                Expr::mul(Expr::mul(Expr::val(1), Expr::val(2)), Expr::val(false)),
            ),
            (
                "0 * 1 * principal",
                Expr::mul(
                    Expr::mul(Expr::val(0), Expr::val(1)),
                    Expr::var(ast::Var::Principal),
                ),
            ),
            (
                "0 * (-1) * principal",
                Expr::mul(
                    Expr::mul(Expr::val(0), Expr::val(-1)),
                    Expr::var(ast::Var::Principal),
                ),
            ),
            (
                "0 * 6 * context.foo",
                Expr::mul(
                    Expr::mul(Expr::val(0), Expr::val(6)),
                    Expr::get_attr(Expr::var(ast::Var::Context), "foo".into()),
                ),
            ),
            (
                "(0 * 6) * context.foo",
                Expr::mul(
                    Expr::mul(Expr::val(0), Expr::val(6)),
                    Expr::get_attr(Expr::var(ast::Var::Context), "foo".into()),
                ),
            ),
            (
                "0 * (6 * context.foo)",
                Expr::mul(
                    Expr::val(0),
                    Expr::mul(
                        Expr::val(6),
                        Expr::get_attr(Expr::var(ast::Var::Context), "foo".into()),
                    ),
                ),
            ),
            (
                "0 * (context.foo * 6)",
                Expr::mul(
                    Expr::val(0),
                    Expr::mul(
                        Expr::get_attr(Expr::var(ast::Var::Context), "foo".into()),
                        Expr::val(6),
                    ),
                ),
            ),
            (
                "1 * 2 * 3 * context.foo * 4 * 5 * 6",
                Expr::mul(
                    Expr::mul(
                        Expr::mul(
                            Expr::mul(
                                Expr::mul(Expr::mul(Expr::val(1), Expr::val(2)), Expr::val(3)),
                                Expr::get_attr(Expr::var(ast::Var::Context), "foo".into()),
                            ),
                            Expr::val(4),
                        ),
                        Expr::val(5),
                    ),
                    Expr::val(6),
                ),
            ),
            (
                "principal * (1 + 2)",
                Expr::mul(
                    Expr::var(ast::Var::Principal),
                    Expr::add(Expr::val(1), Expr::val(2)),
                ),
            ),
            (
                "principal * -(-1)",
                Expr::mul(Expr::var(ast::Var::Principal), Expr::neg(Expr::val(-1))),
            ),
            (
                "principal * --1",
                Expr::mul(Expr::var(ast::Var::Principal), Expr::neg(Expr::val(-1))),
            ),
            (
                r#"false * "bob""#,
                Expr::mul(Expr::val(false), Expr::val("bob")),
            ),
        ] {
            let e = assert_parse_expr_succeeds(str);
            assert!(
                e.eq_shape(&expected),
                "{e:?} and {expected:?} should have the same shape",
            );
        }
    }

    #[test]
    fn test_not() {
        for (es, expr) in [
            (
                "!1 + 2 == 3",
                Expr::is_eq(
                    Expr::add(Expr::not(Expr::val(1)), Expr::val(2)),
                    Expr::val(3),
                ),
            ),
            (
                "!!1 + 2 == 3",
                Expr::is_eq(
                    Expr::add(Expr::not(Expr::not(Expr::val(1))), Expr::val(2)),
                    Expr::val(3),
                ),
            ),
            (
                "!!!1 + 2 == 3",
                Expr::is_eq(
                    Expr::add(Expr::not(Expr::val(1)), Expr::val(2)),
                    Expr::val(3),
                ),
            ),
            (
                "!!!!1 + 2 == 3",
                Expr::is_eq(
                    Expr::add(Expr::not(Expr::not(Expr::val(1))), Expr::val(2)),
                    Expr::val(3),
                ),
            ),
            (
                "!!(-1) + 2 == 3",
                Expr::is_eq(
                    Expr::add(Expr::not(Expr::not(Expr::val(-1))), Expr::val(2)),
                    Expr::val(3),
                ),
            ),
        ] {
            let e = assert_parse_expr_succeeds(es);
            assert!(
                e.eq_shape(&expr),
                "{:?} and {:?} should have the same shape.",
                e,
                expr
            );
        }
    }

    #[test]
    fn test_neg() {
        for (es, expr) in [
            ("-(1 + 2)", Expr::neg(Expr::add(Expr::val(1), Expr::val(2)))),
            ("1-(2)", Expr::sub(Expr::val(1), Expr::val(2))),
            ("1-2", Expr::sub(Expr::val(1), Expr::val(2))),
            ("(-1)", Expr::val(-1)),
            ("-(-1)", Expr::neg(Expr::val(-1))),
            ("--1", Expr::neg(Expr::val(-1))),
            ("--(--1)", Expr::neg(Expr::neg(Expr::neg(Expr::val(-1))))),
            ("2--1", Expr::sub(Expr::val(2), Expr::val(-1))),
            ("-9223372036854775808", Expr::val(-(9223372036854775808))),
            // Evaluating this expression leads to overflows but the parser
            // won't reject it.
            (
                "--9223372036854775808",
                Expr::neg(Expr::val(-9223372036854775808)),
            ),
            (
                "-(9223372036854775807)",
                Expr::neg(Expr::val(9223372036854775807)),
            ),
        ] {
            let e = assert_parse_expr_succeeds(es);
            assert!(
                e.eq_shape(&expr),
                "{:?} and {:?} should have the same shape.",
                e,
                expr
            );
        }

        for (es, em) in [
            (
                "-9223372036854775809",
                ExpectedErrorMessageBuilder::error(
                    "integer literal `9223372036854775809` is too large",
                )
                .help("maximum allowed integer literal is `9223372036854775807`")
                .exactly_one_underline("-9223372036854775809")
                .build(),
            ),
            // This test doesn't fail with an internal representation of i128:
            // Contrary to Rust, this expression is not valid because the
            // parser treats it as a negation operation whereas the operand
            // (9223372036854775808) is too large.
            (
                "-(9223372036854775808)",
                ExpectedErrorMessageBuilder::error(
                    "integer literal `9223372036854775808` is too large",
                )
                .help("maximum allowed integer literal is `9223372036854775807`")
                .exactly_one_underline("9223372036854775808")
                .build(),
            ),
        ] {
            let errs = assert_parse_expr_fails(es);
            expect_err(es, &miette::Report::new(errs), &em);
        }
    }

    #[test]
    fn test_is_condition_ok() {
        for (es, expr) in [
            (
                r#"User::"alice" is User"#,
                Expr::is_entity_type(
                    Expr::val(r#"User::"alice""#.parse::<EntityUID>().unwrap()),
                    "User".parse().unwrap(),
                ),
            ),
            (
                r#"principal is User"#,
                Expr::is_entity_type(Expr::var(ast::Var::Principal), "User".parse().unwrap()),
            ),
            (
                r#"principal.foo is User"#,
                Expr::is_entity_type(
                    Expr::get_attr(Expr::var(ast::Var::Principal), "foo".into()),
                    "User".parse().unwrap(),
                ),
            ),
            (
                r#"1 is User"#,
                Expr::is_entity_type(Expr::val(1), "User".parse().unwrap()),
            ),
            (
                r#"principal is User in Group::"friends""#,
                Expr::and(
                    Expr::is_entity_type(Expr::var(ast::Var::Principal), "User".parse().unwrap()),
                    Expr::is_in(
                        Expr::var(ast::Var::Principal),
                        Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                    ),
                ),
            ),
            (
                r#"principal is User && principal in Group::"friends""#,
                Expr::and(
                    Expr::is_entity_type(Expr::var(ast::Var::Principal), "User".parse().unwrap()),
                    Expr::is_in(
                        Expr::var(ast::Var::Principal),
                        Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                    ),
                ),
            ),
            (
                r#"principal is User || principal in Group::"friends""#,
                Expr::or(
                    Expr::is_entity_type(Expr::var(ast::Var::Principal), "User".parse().unwrap()),
                    Expr::is_in(
                        Expr::var(ast::Var::Principal),
                        Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                    ),
                ),
            ),
            (
                r#"true && principal is User in principal"#,
                Expr::and(
                    Expr::val(true),
                    Expr::and(
                        Expr::is_entity_type(
                            Expr::var(ast::Var::Principal),
                            "User".parse().unwrap(),
                        ),
                        Expr::is_in(
                            Expr::var(ast::Var::Principal),
                            Expr::var(ast::Var::Principal),
                        ),
                    ),
                ),
            ),
            (
                r#"principal is User in principal && true"#,
                Expr::and(
                    Expr::and(
                        Expr::is_entity_type(
                            Expr::var(ast::Var::Principal),
                            "User".parse().unwrap(),
                        ),
                        Expr::is_in(
                            Expr::var(ast::Var::Principal),
                            Expr::var(ast::Var::Principal),
                        ),
                    ),
                    Expr::val(true),
                ),
            ),
            (
                r#"principal is A::B::C::User"#,
                Expr::is_entity_type(
                    Expr::var(ast::Var::Principal),
                    "A::B::C::User".parse().unwrap(),
                ),
            ),
            (
                r#"principal is A::B::C::User in Group::"friends""#,
                Expr::and(
                    Expr::is_entity_type(
                        Expr::var(ast::Var::Principal),
                        "A::B::C::User".parse().unwrap(),
                    ),
                    Expr::is_in(
                        Expr::var(ast::Var::Principal),
                        Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                    ),
                ),
            ),
            (
                r#"if principal is User then 1 else 2"#,
                Expr::ite(
                    Expr::is_entity_type(Expr::var(ast::Var::Principal), "User".parse().unwrap()),
                    Expr::val(1),
                    Expr::val(2),
                ),
            ),
            (
                r#"if principal is User in Group::"friends" then 1 else 2"#,
                Expr::ite(
                    Expr::and(
                        Expr::is_entity_type(
                            Expr::var(ast::Var::Principal),
                            "User".parse().unwrap(),
                        ),
                        Expr::is_in(
                            Expr::var(ast::Var::Principal),
                            Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                        ),
                    ),
                    Expr::val(1),
                    Expr::val(2),
                ),
            ),
            (
                r#"principal::"alice" is principal"#,
                Expr::is_entity_type(
                    Expr::val(r#"principal::"alice""#.parse::<EntityUID>().unwrap()),
                    "principal".parse().unwrap(),
                ),
            ),
            (
                r#"foo::principal::"alice" is foo::principal"#,
                Expr::is_entity_type(
                    Expr::val(r#"foo::principal::"alice""#.parse::<EntityUID>().unwrap()),
                    "foo::principal".parse().unwrap(),
                ),
            ),
            (
                r#"principal::foo::"alice" is principal::foo"#,
                Expr::is_entity_type(
                    Expr::val(r#"principal::foo::"alice""#.parse::<EntityUID>().unwrap()),
                    "principal::foo".parse().unwrap(),
                ),
            ),
            (
                r#"resource::"thing" is resource"#,
                Expr::is_entity_type(
                    Expr::val(r#"resource::"thing""#.parse::<EntityUID>().unwrap()),
                    "resource".parse().unwrap(),
                ),
            ),
            (
                r#"action::"do" is action"#,
                Expr::is_entity_type(
                    Expr::val(r#"action::"do""#.parse::<EntityUID>().unwrap()),
                    "action".parse().unwrap(),
                ),
            ),
            (
                r#"context::"stuff" is context"#,
                Expr::is_entity_type(
                    Expr::val(r#"context::"stuff""#.parse::<EntityUID>().unwrap()),
                    "context".parse().unwrap(),
                ),
            ),
        ] {
            let e = parse_expr(es).unwrap();
            assert!(
                e.eq_shape(&expr),
                "{:?} and {:?} should have the same shape.",
                e,
                expr
            );
        }
    }

    #[test]
    fn is_scope() {
        for (src, p, a, r) in [
            (
                r#"permit(principal is User, action, resource);"#,
                PrincipalConstraint::is_entity_type("User".parse().unwrap()),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is principal, action, resource);"#,
                PrincipalConstraint::is_entity_type("principal".parse().unwrap()),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is A::User, action, resource);"#,
                PrincipalConstraint::is_entity_type("A::User".parse().unwrap()),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is User in Group::"thing", action, resource);"#,
                PrincipalConstraint::is_entity_type_in(
                    "User".parse().unwrap(),
                    r#"Group::"thing""#.parse().unwrap(),
                ),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is principal in Group::"thing", action, resource);"#,
                PrincipalConstraint::is_entity_type_in(
                    "principal".parse().unwrap(),
                    r#"Group::"thing""#.parse().unwrap(),
                ),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is A::User in Group::"thing", action, resource);"#,
                PrincipalConstraint::is_entity_type_in(
                    "A::User".parse().unwrap(),
                    r#"Group::"thing""#.parse().unwrap(),
                ),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is User in ?principal, action, resource);"#,
                PrincipalConstraint::is_entity_type_in_slot("User".parse().unwrap()),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal, action, resource is Folder);"#,
                PrincipalConstraint::any(),
                ActionConstraint::any(),
                ResourceConstraint::is_entity_type("Folder".parse().unwrap()),
            ),
            (
                r#"permit(principal, action, resource is Folder in Folder::"inner");"#,
                PrincipalConstraint::any(),
                ActionConstraint::any(),
                ResourceConstraint::is_entity_type_in(
                    "Folder".parse().unwrap(),
                    r#"Folder::"inner""#.parse().unwrap(),
                ),
            ),
            (
                r#"permit(principal, action, resource is Folder in ?resource);"#,
                PrincipalConstraint::any(),
                ActionConstraint::any(),
                ResourceConstraint::is_entity_type_in_slot("Folder".parse().unwrap()),
            ),
        ] {
            let policy = parse_policy_template(None, src).unwrap();
            assert_eq!(policy.principal_constraint(), &p);
            assert_eq!(policy.action_constraint(), &a);
            assert_eq!(policy.resource_constraint(), &r);
        }
    }

    #[test]
    fn is_err() {
        let invalid_is_policies = [
            (
                r#"permit(principal in Group::"friends" is User, action, resource);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found an `is` expression").exactly_one_underline(r#"Group::"friends" is User"#).build(),
            ),
            (
                r#"permit(principal, action, resource in Folder::"folder" is File);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found an `is` expression").exactly_one_underline(r#"Folder::"folder" is File"#).build(),
            ),
            (
                r#"permit(principal is User == User::"Alice", action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the scope at the same time as `==`",
                ).help(
                    "try moving `is` into a `when` condition"
                ).exactly_one_underline("principal is User == User::\"Alice\"").build(),
            ),
            (
                r#"permit(principal, action, resource is Doc == Doc::"a");"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the scope at the same time as `==`",
                ).help(
                    "try moving `is` into a `when` condition"
                ).exactly_one_underline("resource is Doc == Doc::\"a\"").build(),
            ),
            (
                r#"permit(principal is User::"alice", action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `User::"alice"`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("User::\"alice\"").build(),
            ),
            (
                r#"permit(principal, action, resource is File::"f");"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `File::"f"`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("File::\"f\"").build(),
            ),
            (
                r#"permit(principal is User in 1, action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "expected an entity uid or matching template slot, found literal `1`",
                ).exactly_one_underline("1").build(),
            ),
            (
                r#"permit(principal, action, resource is File in 1);"#,
                ExpectedErrorMessageBuilder::error(
                    "expected an entity uid or matching template slot, found literal `1`",
                ).exactly_one_underline("1").build(),
            ),
            (
                r#"permit(principal is User in User, action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "expected an entity uid or matching template slot, found name `User`",
                ).exactly_one_underline("User").build(),
            ),
            (
                r#"permit(principal is User::"Alice" in Group::"f", action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `User::"Alice"`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("User::\"Alice\"").build(),
            ),
            (
                r#"permit(principal, action, resource is File in File);"#,
                ExpectedErrorMessageBuilder::error(
                    "expected an entity uid or matching template slot, found name `File`",
                ).exactly_one_underline("File").build(),
            ),
            (
                r#"permit(principal, action, resource is File::"file" in Folder::"folder");"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `File::"file"`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("File::\"file\"").build(),
            ),
            (
                r#"permit(principal is 1, action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `1`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("1").build(),
            ),
            (
                r#"permit(principal, action, resource is 1);"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `1`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("1").build(),
            ),
            (
                r#"permit(principal, action is Action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the action scope",
                ).help(
                    "try moving `action is ..` into a `when` condition"
                ).exactly_one_underline("action is Action").build(),
            ),
            (
                r#"permit(principal, action is Action::"a", resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the action scope",
                ).help(
                    "try moving `action is ..` into a `when` condition"
                ).exactly_one_underline("action is Action::\"a\"").build(),
            ),
            (
                r#"permit(principal, action is Action in Action::"A", resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the action scope",
                ).help(
                    "try moving `action is ..` into a `when` condition"
                ).exactly_one_underline("action is Action in Action::\"A\"").build(),
            ),
            (
                r#"permit(principal, action is Action in Action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the action scope",
                ).help(
                    "try moving `action is ..` into a `when` condition"
                ).exactly_one_underline("action is Action in Action").build(),
            ),
            (
                r#"permit(principal, action is Action::"a" in Action::"b", resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the action scope",
                ).help(
                    "try moving `action is ..` into a `when` condition"
                ).exactly_one_underline("action is Action::\"a\" in Action::\"b\"").build(),
            ),
            (
                r#"permit(principal, action is Action in ?action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the action scope",
                ).help(
                    "try moving `action is ..` into a `when` condition"
                ).exactly_one_underline("action is Action in ?action").build(),
            ),
            (
                r#"permit(principal, action is ?action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "`is` cannot appear in the action scope",
                ).help(
                    "try moving `action is ..` into a `when` condition"
                ).exactly_one_underline("action is ?action").build(),
            ),
            (
                r#"permit(principal is User in ?resource, action, resource);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?resource instead of ?principal").exactly_one_underline("?resource").build(),
            ),
            (
                r#"permit(principal, action, resource is Folder in ?principal);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?principal instead of ?resource").exactly_one_underline("?principal").build(),
            ),
            (
                r#"permit(principal is ?principal, action, resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "right hand side of an `is` expression must be an entity type name, but got `?principal`",
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("?principal").build(),
            ),
            (
                r#"permit(principal, action, resource is ?resource);"#,
                ExpectedErrorMessageBuilder::error(
                    "right hand side of an `is` expression must be an entity type name, but got `?resource`",
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("?resource").build(),
            ),
            (
                r#"permit(principal, action, resource) when { principal is 1 };"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `1`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("1").build(),
            ),
            (
                r#"permit(principal, action, resource) when { principal is User::"alice" in Group::"friends" };"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `User::"alice"`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("User::\"alice\"").build(),
            ),
            (
                r#"permit(principal, action, resource) when { principal is ! User::"alice" in Group::"friends" };"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `!User::"alice"`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("! User::\"alice\"").build(),
            ),
            (
                r#"permit(principal, action, resource) when { principal is User::"alice" + User::"alice" in Group::"friends" };"#,
                ExpectedErrorMessageBuilder::error(
                    r#"right hand side of an `is` expression must be an entity type name, but got `User::"alice" + User::"alice"`"#,
                ).help(
                    "try using `==` to test for equality"
                ).exactly_one_underline("User::\"alice\" + User::\"alice\"").build(),
            ),
            (
                r#"permit(principal, action, resource) when { principal is User in User::"alice" in Group::"friends" };"#,
                ExpectedErrorMessageBuilder::error(
                    "unexpected token `in`"
                ).exactly_one_underline("in").build(),
            ),
            (
                r#"permit(principal, action, resource) when { principal is User == User::"alice" in Group::"friends" };"#,
                ExpectedErrorMessageBuilder::error(
                    "unexpected token `==`"
                ).exactly_one_underline("==").build(),
            ),
        ];
        for (p_src, expected) in invalid_is_policies {
            assert_matches!(parse_policy_template(None, p_src), Err(e) => {
                expect_err(p_src, &miette::Report::new(e), &expected);
            });
        }
    }

    #[test]
    fn issue_255() {
        let policy = r#"
            permit (
                principal == name-with-dashes::"Alice",
                action,
                resource
            );
        "#;
        assert_matches!(
            parse_policy(None, policy),
            Err(e) => {
                expect_n_errors(policy, &e, 1);
                expect_some_error_matches(policy, &e, &ExpectedErrorMessageBuilder::error(
                    "expected an entity uid or matching template slot, found a `+/-` expression",
                ).help(
                    "entity types and namespaces cannot use `+` or `-` characters -- perhaps try `_` or `::` instead?",
                ).exactly_one_underline("name-with-dashes::\"Alice\"").build());
            }
        );
    }

    #[test]
    fn invalid_methods_function_calls() {
        let invalid_exprs = [
            (
                r#"contains([], 1)"#,
                ExpectedErrorMessageBuilder::error("`contains` is a method, not a function")
                    .help("use a method-style call: `e.contains(..)`")
                    .exactly_one_underline("contains([], 1)")
                    .build(),
            ),
            (
                r#"[].contains()"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `contains` requires exactly 1 argument, but got 0 arguments",
                )
                .exactly_one_underline("[].contains()")
                .build(),
            ),
            (
                r#"[].contains(1, 2)"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `contains` requires exactly 1 argument, but got 2 arguments",
                )
                .exactly_one_underline("[].contains(1, 2)")
                .build(),
            ),
            (
                r#"[].containsAll()"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `containsAll` requires exactly 1 argument, but got 0 arguments",
                )
                .exactly_one_underline("[].containsAll()")
                .build(),
            ),
            (
                r#"[].containsAll(1, 2)"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `containsAll` requires exactly 1 argument, but got 2 arguments",
                )
                .exactly_one_underline("[].containsAll(1, 2)")
                .build(),
            ),
            (
                r#"[].containsAny()"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `containsAny` requires exactly 1 argument, but got 0 arguments",
                )
                .exactly_one_underline("[].containsAny()")
                .build(),
            ),
            (
                r#"[].containsAny(1, 2)"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `containsAny` requires exactly 1 argument, but got 2 arguments",
                )
                .exactly_one_underline("[].containsAny(1, 2)")
                .build(),
            ),
            (
                r#""1.1.1.1".ip()"#,
                ExpectedErrorMessageBuilder::error("`ip` is a function, not a method")
                    .help("use a function-style call: `ip(..)`")
                    .exactly_one_underline(r#""1.1.1.1".ip()"#)
                    .build(),
            ),
            (
                r#"greaterThan(1, 2)"#,
                ExpectedErrorMessageBuilder::error("`greaterThan` is a method, not a function")
                    .help("use a method-style call: `e.greaterThan(..)`")
                    .exactly_one_underline("greaterThan(1, 2)")
                    .build(),
            ),
            (
                "[].bar()",
                ExpectedErrorMessageBuilder::error("not a valid method name: `bar`")
                    .exactly_one_underline("[].bar()")
                    .build(),
            ),
            (
                "bar([])",
                ExpectedErrorMessageBuilder::error("`bar` is not a function")
                    .exactly_one_underline("bar([])")
                    .build(),
            ),
            (
                "principal()",
                ExpectedErrorMessageBuilder::error("`principal(...)` is not a valid function call")
                    .help("variables cannot be called as functions")
                    .exactly_one_underline("principal()")
                    .build(),
            ),
            (
                "(1+1)()",
                ExpectedErrorMessageBuilder::error(
                    "function calls must be of the form: `<name>(arg1, arg2, ...)`",
                )
                .exactly_one_underline("(1+1)()")
                .build(),
            ),
            (
                "foo.bar()",
                ExpectedErrorMessageBuilder::error(
                    "attempted to call `foo.bar`, but `foo` does not have any methods",
                )
                .exactly_one_underline("foo.bar()")
                .build(),
            ),
        ];
        for (src, expected) in invalid_exprs {
            assert_matches!(parse_expr(src), Err(e) => {
                expect_err(src, &miette::Report::new(e), &expected);
            });
        }
    }

    #[test]
    fn invalid_slot() {
        let invalid_policies = [
            (
                r#"permit(principal == ?resource, action, resource);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?resource instead of ?principal").exactly_one_underline("?resource").build(),
            ),
            (
                r#"permit(principal in ?resource, action, resource);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?resource instead of ?principal").exactly_one_underline("?resource").build(),
            ),
            (
                r#"permit(principal == ?foo, action, resource);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?foo instead of ?principal").exactly_one_underline("?foo").build(),
            ),
            (
                r#"permit(principal in ?foo, action, resource);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?foo instead of ?principal").exactly_one_underline("?foo").build(),
            ),

            (
                r#"permit(principal, action, resource == ?principal);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?principal instead of ?resource").exactly_one_underline("?principal").build(),
            ),
            (
                r#"permit(principal, action, resource in ?principal);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?principal instead of ?resource").exactly_one_underline("?principal").build(),
            ),
            (
                r#"permit(principal, action, resource == ?baz);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?baz instead of ?resource").exactly_one_underline("?baz").build(),
            ),
            (
                r#"permit(principal, action, resource in ?baz);"#,
                ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?baz instead of ?resource").exactly_one_underline("?baz").build(),
            ),
            (
                r#"permit(principal, action, resource) when { principal == ?foo};"#,
                ExpectedErrorMessageBuilder::error(
                    "`?foo` is not a valid template slot",
                ).help(
                    "a template slot may only be `?principal` or `?resource`",
                ).exactly_one_underline("?foo").build(),
            ),

            (
                r#"permit(principal, action == ?action, resource);"#,
                ExpectedErrorMessageBuilder::error("expected single entity uid, got: template slot").exactly_one_underline("?action").build(),
            ),
            (
                r#"permit(principal, action in ?action, resource);"#,
                ExpectedErrorMessageBuilder::error("expected single entity uid or set of entity uids, got: template slot").exactly_one_underline("?action").build(),
            ),
            (
                r#"permit(principal, action == ?principal, resource);"#,
                ExpectedErrorMessageBuilder::error("expected single entity uid, got: template slot").exactly_one_underline("?principal").build(),
            ),
            (
                r#"permit(principal, action in ?principal, resource);"#,
                ExpectedErrorMessageBuilder::error("expected single entity uid or set of entity uids, got: template slot").exactly_one_underline("?principal").build(),
            ),
            (
                r#"permit(principal, action == ?resource, resource);"#,
                ExpectedErrorMessageBuilder::error("expected single entity uid, got: template slot").exactly_one_underline("?resource").build(),
            ),
            (
                r#"permit(principal, action in ?resource, resource);"#,
                ExpectedErrorMessageBuilder::error("expected single entity uid or set of entity uids, got: template slot").exactly_one_underline("?resource").build(),
            ),
            (
                r#"permit(principal, action in [?bar], resource);"#,
                ExpectedErrorMessageBuilder::error("expected single entity uid, got: template slot").exactly_one_underline("?bar").build(),
            ),
        ];

        for (p_src, expected) in invalid_policies {
            assert_matches!(parse_policy_template(None, p_src), Err(e) => {
                expect_err(p_src, &miette::Report::new(e), &expected);
            });
            let forbid_src = format!("forbid{}", &p_src[6..]);
            assert_matches!(parse_policy_template(None, &forbid_src), Err(e) => {
                expect_err(forbid_src.as_str(), &miette::Report::new(e), &expected);
            });
        }
    }

    #[test]
    fn missing_scope_constraint() {
        let p_src = "permit();";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("this policy is missing the `principal` variable in the scope").exactly_one_underline("").build());
        });
        let p_src = "permit(principal);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("this policy is missing the `action` variable in the scope").exactly_one_underline("").build());
        });
        let p_src = "permit(principal, action);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("this policy is missing the `resource` variable in the scope").exactly_one_underline("").build());
        });
    }

    #[test]
    fn invalid_scope_constraint() {
        let p_src = "permit(foo, action, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "expected a variable that is valid in the policy scope; found: `foo`",
                ).help(
                "policy scopes must contain a `principal`, `action`, and `resource` element in that order",
            ).exactly_one_underline("foo").build());
        });
        let p_src = "permit(foo::principal, action, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "unexpected token `::`",
            ).exactly_one_underline("::").build());
        });
        let p_src = "permit(resource, action, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "found the variable `resource` where the variable `principal` must be used",
                ).help(
                "policy scopes must contain a `principal`, `action`, and `resource` element in that order",
            ).exactly_one_underline("resource").build());
        });

        let p_src = "permit(principal, principal, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "found the variable `principal` where the variable `action` must be used",
                ).help(
                "policy scopes must contain a `principal`, `action`, and `resource` element in that order",
            ).exactly_one_underline("principal").build());
        });
        let p_src = "permit(principal, if, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "expected a variable that is valid in the policy scope; found: `if`",
                ).help(
                "policy scopes must contain a `principal`, `action`, and `resource` element in that order",
            ).exactly_one_underline("if").build());
        });

        let p_src = "permit(principal, action, like);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "expected a variable that is valid in the policy scope; found: `like`",
                ).help(
                "policy scopes must contain a `principal`, `action`, and `resource` element in that order",
            ).exactly_one_underline("like").build());
        });
        let p_src = "permit(principal, action, principal);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "found the variable `principal` where the variable `resource` must be used",
                ).help(
                "policy scopes must contain a `principal`, `action`, and `resource` element in that order",
            ).exactly_one_underline("principal").build());
        });
        let p_src = "permit(principal, action, action);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "found the variable `action` where the variable `resource` must be used",
                ).help(
                "policy scopes must contain a `principal`, `action`, and `resource` element in that order",
            ).exactly_one_underline("action").build());
        });
    }

    #[test]
    fn invalid_scope_operator() {
        let p_src = r#"permit(principal > User::"alice", action, resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "not a valid policy scope constraint: >",
                ).help(
                "policy scope constraints must be either `==`, `in`, `is`, or `_ is _ in _`"
            ).exactly_one_underline("principal > User::\"alice\"").build());
        });
        let p_src = r#"permit(principal, action != Action::"view", resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "not a valid policy scope constraint: !=",
                ).help(
                "policy scope constraints must be either `==`, `in`, `is`, or `_ is _ in _`"
            ).exactly_one_underline("action != Action::\"view\"").build());
        });
        let p_src = r#"permit(principal, action, resource <= Folder::"things");"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "not a valid policy scope constraint: <=",
                ).help(
                "policy scope constraints must be either `==`, `in`, `is`, or `_ is _ in _`"
            ).exactly_one_underline("resource <= Folder::\"things\"").build());
        });
        let p_src = r#"permit(principal = User::"alice", action, resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "'=' is not a valid operator in Cedar",
                ).help(
                "try using '==' instead",
            ).exactly_one_underline("principal = User::\"alice\"").build());
        });
    }

    #[test]
    fn scope_action_eq_set() {
        let p_src = r#"permit(principal, action == [Action::"view", Action::"edit"], resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("expected single entity uid, got: set of entity uids").exactly_one_underline(r#"[Action::"view", Action::"edit"]"#).build());
        });
    }

    #[test]
    fn scope_action_in_set_set() {
        let p_src = r#"permit(principal, action in [[Action::"view"]], resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("expected single entity uid, got: set of entity uids").exactly_one_underline(r#"[Action::"view"]"#).build());
        });
    }

    #[test]
    fn unsupported_ops() {
        let src = "1/2";
        assert_matches!(parse_expr(src), Err(e) => {
            expect_err(src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("division is not supported").exactly_one_underline("1/2").build());
        });
        let src = "7 % 3";
        assert_matches!(parse_expr(src), Err(e) => {
            expect_err(src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("remainder/modulo is not supported").exactly_one_underline("7 % 3").build());
        });
    }

    #[test]
    fn over_unary() {
        let src = "!!!!!!false";
        assert_matches!(parse_expr(src), Err(e) => {
            expect_err(src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "too many occurrences of `!_`",
                ).help(
                "cannot chain more the 4 applications of a unary operator"
            ).exactly_one_underline("!!!!!!false").build());
        });
        let src = "-------0";
        assert_matches!(parse_expr(src), Err(e) => {
            expect_err(src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "too many occurrences of `-_`",
                ).help(
                "cannot chain more the 4 applications of a unary operator"
            ).exactly_one_underline("-------0").build());
        });
    }

    #[test]
    fn arbitrary_variables() {
        #[track_caller]
        fn expect_arbitrary_var(name: &str) {
            assert_matches!(parse_expr(name), Err(e) => {
                expect_err(name, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                    "arbitrary variables are not supported; the valid Cedar variables are `principal`, `action`, `resource`, and `context`",
                ).help(
                    &format!("did you mean to enclose `{name}` in quotes to make a string?"),
                ).exactly_one_underline(name).build());
            })
        }
        expect_arbitrary_var("foo::principal");
        expect_arbitrary_var("bar::action");
        expect_arbitrary_var("baz::resource");
        expect_arbitrary_var("buz::context");
        expect_arbitrary_var("foo::principal");
        expect_arbitrary_var("foo::bar::principal");
        expect_arbitrary_var("principal::foo");
        expect_arbitrary_var("principal::foo::bar");
        expect_arbitrary_var("foo::principal::bar");
        expect_arbitrary_var("foo");
        expect_arbitrary_var("foo::bar");
        expect_arbitrary_var("foo::bar::baz");
    }

    #[test]
    fn empty_clause() {
        #[track_caller]
        fn expect_empty_clause(policy: &str, clause: &str) {
            assert_matches!(parse_policy_template(None, policy), Err(e) => {
                expect_err(policy, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                    &format!("`{clause}` condition clause cannot be empty")
                ).exactly_one_underline(&format!("{clause} {{}}")).build());
            })
        }

        expect_empty_clause("permit(principal, action, resource) when {};", "when");
        expect_empty_clause("permit(principal, action, resource) unless {};", "unless");
        expect_empty_clause(
            "permit(principal, action, resource) when { principal has foo } when {};",
            "when",
        );
        expect_empty_clause(
            "permit(principal, action, resource) when { principal has foo } unless {};",
            "unless",
        );
        expect_empty_clause(
            "permit(principal, action, resource) when {} unless { resource.bar };",
            "when",
        );
        expect_empty_clause(
            "permit(principal, action, resource) unless {} unless { resource.bar };",
            "unless",
        );
    }

    #[test]
    fn namespaced_attr() {
        #[track_caller]
        fn expect_namespaced_attr(expr: &str, name: &str) {
            assert_matches!(parse_expr(expr), Err(e) => {
                expect_err(expr, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                    &format!("`{name}` cannot be used as an attribute as it contains a namespace")
                ).exactly_one_underline(name).build());
            })
        }

        expect_namespaced_attr("principal has foo::bar", "foo::bar");
        expect_namespaced_attr("principal has foo::bar::baz", "foo::bar::baz");
        expect_namespaced_attr("principal has foo::principal", "foo::principal");
        expect_namespaced_attr("{foo::bar: 1}", "foo::bar");

        let expr = "principal has if::foo";
        assert_matches!(parse_expr(expr), Err(e) => {
            expect_err(expr, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: `if`"
            ).exactly_one_underline("if").build());
        })
    }

    #[test]
    fn reserved_ident_var() {
        #[track_caller]
        fn expect_reserved_ident(name: &str, reserved: &str) {
            assert_matches!(parse_expr(name), Err(e) => {
                expect_err(name, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                    &format!("this identifier is reserved and cannot be used: `{reserved}`"),
                ).exactly_one_underline(reserved).build());
            })
        }
        expect_reserved_ident("if::principal", "if");
        expect_reserved_ident("then::action", "then");
        expect_reserved_ident("else::resource", "else");
        expect_reserved_ident("true::context", "true");
        expect_reserved_ident("false::bar::principal", "false");
        expect_reserved_ident("foo::in::principal", "in");
        expect_reserved_ident("foo::is::bar::principal", "is");
    }
}
