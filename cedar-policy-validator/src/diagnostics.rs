/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use cedar_policy_core::ast::PolicyID;
use cedar_policy_core::parser::Loc;
use miette::Diagnostic;
use thiserror::Error;

use self::validation_errors::TypeError;

pub mod validation_errors;
pub mod validation_warnings;

pub use self::validation_errors::ValidationErrorKind;

/// Contains the result of policy validation. The result includes the list of
/// issues found by validation and whether validation succeeds or fails.
/// Validation succeeds if there are no fatal errors. There may still be
/// non-fatal warnings present when validation passes.
#[derive(Debug)]
pub struct ValidationResult {
    validation_errors: Vec<ValidationError>,
    validation_warnings: Vec<ValidationWarning>,
}

impl ValidationResult {
    pub fn new(
        errors: impl IntoIterator<Item = ValidationError>,
        warnings: impl IntoIterator<Item = ValidationWarning>,
    ) -> Self {
        Self {
            validation_errors: errors.into_iter().collect(),
            validation_warnings: warnings.into_iter().collect(),
        }
    }

    /// True when validation passes. There are no errors, but there may be
    /// non-fatal warnings.
    pub fn validation_passed(&self) -> bool {
        self.validation_errors.is_empty()
    }

    /// Get an iterator over the errors found by the validator.
    pub fn validation_errors(&self) -> impl Iterator<Item = &ValidationError> {
        self.validation_errors.iter()
    }

    /// Get an iterator over the warnings found by the validator.
    pub fn validation_warnings(&self) -> impl Iterator<Item = &ValidationWarning> {
        self.validation_warnings.iter()
    }

    /// Get an iterator over the errors and warnings found by the validator.
    pub fn into_errors_and_warnings(
        self,
    ) -> (
        impl Iterator<Item = ValidationError>,
        impl Iterator<Item = ValidationWarning>,
    ) {
        (
            self.validation_errors.into_iter(),
            self.validation_warnings.into_iter(),
        )
    }
}

/// An error generated by the validator when it finds a potential problem in a
/// policy. The error contains a enumeration that specifies the kind of problem,
/// and provides details specific to that kind of problem. The error also records
/// where the problem was encountered.
#[derive(Clone, Debug, Error, Eq, PartialEq)]
#[error("for policy `{policy_id}`, {kind}")]
pub struct ValidationError {
    pub(crate) policy_id: PolicyID,
    pub(crate) source_loc: Option<Loc>,
    pub(crate) kind: ValidationErrorKind,
}

impl ValidationError {
    pub(crate) fn with_policy_id(
        policy_id: PolicyID,
        source_loc: Option<Loc>,
        err: TypeError,
    ) -> Self {
        let (kind, error_loc) = err.kind_and_location();
        let source_loc = error_loc.or(source_loc);
        Self {
            policy_id,
            source_loc,
            kind,
        }
    }

    /// Extract details about the exact issue detected by the validator.
    pub fn kind(&self) -> &ValidationErrorKind {
        &self.kind
    }

    /// Extract the policy id of the policy where the validator found the issue.
    pub fn policy_id(&self) -> &PolicyID {
        &self.policy_id
    }

    /// Extract the location where the validator found the issue.
    pub fn loc(&self) -> Option<&Loc> {
        self.source_loc.as_ref()
    }
}

// custom impl of `Diagnostic`: source location and source code are from
// .location, everything else forwarded to .error_kind
impl Diagnostic for ValidationError {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = miette::LabeledSpan> + '_>> {
        let label = miette::LabeledSpan::underline(self.source_loc.as_ref()?.span);
        Some(Box::new(std::iter::once(label)))
    }

    fn source_code(&self) -> Option<&dyn miette::SourceCode> {
        Some(&self.source_loc.as_ref()?.src)
    }

    fn code(&self) -> Option<Box<dyn std::fmt::Display + '_>> {
        self.kind.code()
    }

    fn severity(&self) -> Option<miette::Severity> {
        self.kind.severity()
    }

    fn url(&self) -> Option<Box<dyn std::fmt::Display + '_>> {
        self.kind.url()
    }

    fn help(&self) -> Option<Box<dyn std::fmt::Display + '_>> {
        self.kind.help()
    }

    fn related(&self) -> Option<Box<dyn Iterator<Item = &dyn Diagnostic> + '_>> {
        self.kind.related()
    }

    fn diagnostic_source(&self) -> Option<&dyn Diagnostic> {
        self.kind.diagnostic_source()
    }
}

/// The structure for validation warnings.
#[derive(Hash, Eq, PartialEq, Error, Debug, Clone)]
#[error("for policy `{policy_id}`, {kind}")]
pub struct ValidationWarning {
    pub(crate) policy_id: PolicyID,
    pub(crate) source_loc: Option<Loc>,
    pub(crate) kind: ValidationWarningKind,
}

impl ValidationWarning {
    pub(crate) fn with_policy_id(
        policy_id: PolicyID,
        source_loc: Option<Loc>,
        kind: ValidationWarningKind,
    ) -> Self {
        Self {
            kind,
            policy_id,
            source_loc,
        }
    }

    /// Extract the policy id of the policy where the validator found the issue.
    pub fn policy_id(&self) -> &PolicyID {
        &self.policy_id
    }

    /// Extract the location where the validator found the issue.
    pub fn loc(&self) -> Option<&Loc> {
        self.source_loc.as_ref()
    }

    /// Extract details about the exact issue detected by the validator.
    pub fn kind(&self) -> &ValidationWarningKind {
        &self.kind
    }
}

// custom impl of `Diagnostic`: source location and source code are from
// .location, everything else forwarded to .kind
impl Diagnostic for ValidationWarning {
    fn labels(&self) -> Option<Box<dyn Iterator<Item = miette::LabeledSpan> + '_>> {
        let label = miette::LabeledSpan::underline(self.source_loc.as_ref()?.span);
        Some(Box::new(std::iter::once(label)))
    }

    fn source_code(&self) -> Option<&dyn miette::SourceCode> {
        Some(&self.source_loc.as_ref()?.src)
    }

    fn code(&self) -> Option<Box<dyn std::fmt::Display + '_>> {
        self.kind.code()
    }

    fn severity(&self) -> Option<miette::Severity> {
        self.kind.severity()
    }

    fn url(&self) -> Option<Box<dyn std::fmt::Display + '_>> {
        self.kind.url()
    }

    fn help(&self) -> Option<Box<dyn std::fmt::Display + '_>> {
        self.kind.help()
    }

    fn related(&self) -> Option<Box<dyn Iterator<Item = &dyn Diagnostic> + '_>> {
        self.kind.related()
    }

    fn diagnostic_source(&self) -> Option<&dyn Diagnostic> {
        self.kind.diagnostic_source()
    }
}

/// Represents the different kinds of validation warnings and information
/// specific to that warning. Marked as `non_exhaustive` to allow adding
/// additional warnings in the future as a non-breaking change.
#[derive(Debug, Clone, PartialEq, Diagnostic, Error, Eq, Hash)]
#[non_exhaustive]
pub enum ValidationWarningKind {
    /// A string contains mixed scripts. Different scripts can contain visually similar characters which may be confused for each other.
    #[diagnostic(transparent)]
    #[error(transparent)]
    MixedScriptString(#[from] validation_warnings::MixedScriptString),
    /// A string contains BIDI control characters. These can be used to create crafted pieces of code that obfuscate true control flow.
    #[diagnostic(transparent)]
    #[error(transparent)]
    BidiCharsInString(#[from] validation_warnings::BidiCharsInString),
    /// An id contains BIDI control characters. These can be used to create crafted pieces of code that obfuscate true control flow.
    #[diagnostic(transparent)]
    #[error(transparent)]
    BidiCharsInIdentifier(#[from] validation_warnings::BidiCharsInIdentifier),
    /// An id contains mixed scripts. This can cause characters to be confused for each other.
    #[diagnostic(transparent)]
    #[error(transparent)]
    MixedScriptIdentifier(#[from] validation_warnings::MixedScriptIdentifier),
    /// An id contains characters that fall outside of the General Security Profile for Identifiers. We recommend adhering to this if possible. See UnicodeÂ® Technical Standard #39 for more info.
    #[diagnostic(transparent)]
    #[error(transparent)]
    ConfusableIdentifier(#[from] validation_warnings::ConfusableIdentifier),
    /// The typechecker found that a policy condition will always evaluate to false.
    #[diagnostic(transparent)]
    #[error(transparent)]
    ImpossiblePolicy(#[from] validation_warnings::ImpossiblePolicy),
}

impl ValidationWarningKind {
    pub(crate) fn mixed_script_string(string: impl Into<String>) -> Self {
        validation_warnings::MixedScriptString {
            string: string.into(),
        }
        .into()
    }

    pub(crate) fn bidi_chars_strings(string: impl Into<String>) -> Self {
        validation_warnings::BidiCharsInString {
            string: string.into(),
        }
        .into()
    }

    pub(crate) fn mixed_script_identifier(id: impl Into<String>) -> Self {
        validation_warnings::MixedScriptIdentifier { id: id.into() }.into()
    }

    pub(crate) fn bidi_chars_identifier(id: impl Into<String>) -> Self {
        validation_warnings::BidiCharsInIdentifier { id: id.into() }.into()
    }

    pub(crate) fn confusable_identifier(id: impl Into<String>) -> Self {
        validation_warnings::ConfusableIdentifier { id: id.into() }.into()
    }

    pub(crate) fn impossible_policy() -> Self {
        validation_warnings::ImpossiblePolicy {}.into()
    }
}
