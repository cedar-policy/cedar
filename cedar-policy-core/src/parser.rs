/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! This module contains the parser for the Cedar language.

/// Concrete Syntax Tree def used as parser first pass
pub mod cst;
/// Step two: convert CST to package AST
mod cst_to_ast;
/// error handling utilities
pub mod err;
/// implementations for formatting, like `Display`
mod fmt;
pub use fmt::join_with_conjunction;
/// Source location struct
mod loc;
pub use loc::Loc;
/// Metadata wrapper for CST Nodes
mod node;
pub use node::Node;
/// Step one: Convert text to CST
pub mod text_to_cst;
/// Utility functions to unescape string literals
pub mod unescape;
/// Utility functions
pub mod util;

use smol_str::SmolStr;
use std::collections::HashMap;

use crate::ast;
use crate::ast::RestrictedExpressionParseError;
use crate::est;

/// simple main function for parsing policies
/// generates numbered ids
pub fn parse_policyset(text: &str) -> Result<ast::PolicySet, err::ParseErrors> {
    let cst = text_to_cst::parse_policies(text)?;
    cst.to_policyset()
}

/// Like `parse_policyset()`, but also returns the (lossless) original text of
/// each individual policy.
/// INVARIANT: The `PolicyId` of every `Policy` and `Template` returned by the
/// `policies()` and `templates()` methods on the returned `Policy` _must_
/// appear as a key in the returned map.
pub fn parse_policyset_and_also_return_policy_text(
    text: &str,
) -> Result<(HashMap<ast::PolicyID, &str>, ast::PolicySet), err::ParseErrors> {
    let cst = text_to_cst::parse_policies(text)?;
    let pset = cst.to_policyset()?;
    // PANIC SAFETY Shouldn't be `none` since `parse_policies()` and `to_policyset()` didn't return `Err`
    #[allow(clippy::expect_used)]
    // PANIC SAFETY Indexing is safe because of how the `SourceSpan` is constructed
    #[allow(clippy::indexing_slicing)]
    // The `PolicyID` keys for `texts` are generated by
    // `cst.with_generated_policyids()`. This is the same method used to
    // generate the ids for policies and templates in `cst.to_policyset()`,
    // so every static policy and template in the policy set will have its
    // `PolicyId` present as a key in this map.
    let texts = cst
        .with_generated_policyids()
        .expect("shouldn't be None since parse_policies() and to_policyset() didn't return Err")
        .map(|(id, policy)| (id, &text[policy.loc.start()..policy.loc.end()]))
        .collect::<HashMap<ast::PolicyID, &str>>();
    Ok((texts, pset))
}

/// Like `parse_policyset()`, but also returns the (lossless) ESTs -- that is,
/// the ESTs of the original policies without any of the lossy transforms
/// involved in converting to AST.
pub fn parse_policyset_to_ests_and_pset(
    text: &str,
) -> Result<(HashMap<ast::PolicyID, est::Policy>, ast::PolicySet), err::ParseErrors> {
    let cst = text_to_cst::parse_policies(text)?;
    let pset = cst.to_policyset()?;
    // PANIC SAFETY Shouldn't be `None` since `parse_policies()` and `to_policyset()` didn't return `Err`
    #[allow(clippy::expect_used)]
    let ests = cst
        .with_generated_policyids()
        .expect("missing policy set node")
        .map(|(id, policy)| {
            let p = policy.node.as_ref().expect("missing policy node").clone();
            Ok((id, p.try_into()?))
        })
        .collect::<Result<HashMap<ast::PolicyID, est::Policy>, err::ParseErrors>>()?;
    Ok((ests, pset))
}

/// Simple main function for parsing a policy template.
/// If `id` is Some, then the resulting template will have that `id`.
/// If the `id` is None, the parser will use "policy0".
pub fn parse_policy_template(
    id: Option<String>,
    text: &str,
) -> Result<ast::Template, err::ParseErrors> {
    let id = match id {
        Some(id) => ast::PolicyID::from_string(id),
        None => ast::PolicyID::from_string("policy0"),
    };
    let cst = text_to_cst::parse_policy(text)?;
    cst.to_policy_template(id)
}

/// Like `parse_policy_template()`, but also returns the (lossless) EST -- that
/// is, the EST of the original template without any of the lossy transforms
/// involved in converting to AST.
pub fn parse_policy_template_to_est_and_ast(
    id: Option<String>,
    text: &str,
) -> Result<(est::Policy, ast::Template), err::ParseErrors> {
    let id = match id {
        Some(id) => ast::PolicyID::from_string(id),
        None => ast::PolicyID::from_string("policy0"),
    };
    let cst = text_to_cst::parse_policy(text)?;
    let ast = cst.to_policy_template(id)?;
    let est = cst.try_into_inner()?.try_into()?;
    Ok((est, ast))
}

/// simple main function for parsing a policy.
/// If `id` is Some, then the resulting policy will have that `id`.
/// If the `id` is None, the parser will use "policy0".
pub fn parse_policy(id: Option<String>, text: &str) -> Result<ast::StaticPolicy, err::ParseErrors> {
    let id = match id {
        Some(id) => ast::PolicyID::from_string(id),
        None => ast::PolicyID::from_string("policy0"),
    };
    let cst = text_to_cst::parse_policy(text)?;
    cst.to_policy(id)
}

/// Like `parse_policy()`, but also returns the (lossless) EST -- that is, the
/// EST of the original policy without any of the lossy transforms involved in
/// converting to AST.
pub fn parse_policy_to_est_and_ast(
    id: Option<String>,
    text: &str,
) -> Result<(est::Policy, ast::StaticPolicy), err::ParseErrors> {
    let id = match id {
        Some(id) => ast::PolicyID::from_string(id),
        None => ast::PolicyID::from_string("policy0"),
    };
    let cst = text_to_cst::parse_policy(text)?;
    let ast = cst.to_policy(id)?;
    let est = cst.try_into_inner()?.try_into()?;
    Ok((est, ast))
}

/// Parse a policy or template (either one works) to its EST representation
pub fn parse_policy_or_template_to_est(text: &str) -> Result<est::Policy, err::ParseErrors> {
    // We parse to EST and AST even though we only want the EST because some
    // checks are applied by the CST-to-AST conversion and not CST-to-EST, and
    // we do not want to return any EST if the policy text would not parse
    // normally.
    parse_policy_template_to_est_and_ast(None, text).map(|(est, _ast)| est)
}

/// parse an Expr
///
/// Private to this crate. Users outside Core should use `Expr`'s `FromStr` impl
/// or its constructors
pub(crate) fn parse_expr(ptext: &str) -> Result<ast::Expr, err::ParseErrors> {
    let cst = text_to_cst::parse_expr(ptext)?;
    cst.to_expr()
}

/// parse a RestrictedExpr
///
/// Private to this crate. Users outside Core should use `RestrictedExpr`'s
/// `FromStr` impl or its constructors
pub(crate) fn parse_restrictedexpr(
    ptext: &str,
) -> Result<ast::RestrictedExpr, RestrictedExpressionParseError> {
    let expr = parse_expr(ptext)?;
    Ok(ast::RestrictedExpr::new(expr)?)
}

/// parse an EntityUID
///
/// Private to this crate. Users outside Core should use `EntityUID`'s `FromStr`
/// impl or its constructors
pub(crate) fn parse_euid(euid: &str) -> Result<ast::EntityUID, err::ParseErrors> {
    let cst = text_to_cst::parse_ref(euid)?;
    cst.to_ref()
}

/// parse a Name
///
/// Private to this crate. Users outside Core should use `Name`'s `FromStr` impl
/// or its constructors
pub(crate) fn parse_name(name: &str) -> Result<ast::Name, err::ParseErrors> {
    let cst = text_to_cst::parse_name(name)?;
    cst.to_name()
}

/// parse a string into an ast::Literal (does not support expressions)
///
/// Private to this crate. Users outside Core should use `Literal`'s `FromStr` impl
/// or its constructors
pub(crate) fn parse_literal(val: &str) -> Result<ast::Literal, err::LiteralParseError> {
    let cst = text_to_cst::parse_primary(val)?;
    match cst.to_expr() {
        Ok(ast) => match ast.expr_kind() {
            ast::ExprKind::Lit(v) => Ok(v.clone()),
            _ => Err(err::LiteralParseError::InvalidLiteral(ast)),
        },
        Err(errs) => Err(err::LiteralParseError::Parse(errs)),
    }
}

/// parse a string into an internal Cedar string
///
/// This performs unescaping and validation, returning
/// a String suitable for an attr, eid, or literal.
///
/// Quote handling is as if the input is surrounded by
/// double quotes ("{val}").
///
/// It does not return a string suitable for a pattern. Use the
/// full expression parser for those.
pub fn parse_internal_string(val: &str) -> Result<SmolStr, err::ParseErrors> {
    // we need to add quotes for this to be a valid string literal
    let cst = text_to_cst::parse_primary(&format!(r#""{val}""#))?;
    cst.to_string_literal()
}

/// parse an identifier
///
/// Private to this crate. Users outside Core should use `Id`'s `FromStr` impl
/// or its constructors
pub(crate) fn parse_ident(id: &str) -> Result<ast::Id, err::ParseErrors> {
    let cst = text_to_cst::parse_ident(id)?;
    cst.to_valid_ident()
}

/// parse an `AnyId`
///
/// Private to this crate. Users outside Core should use `AnyId`'s `FromStr` impl
/// or its constructors
pub(crate) fn parse_anyid(id: &str) -> Result<ast::AnyId, err::ParseErrors> {
    let cst = text_to_cst::parse_ident(id)?;
    cst.to_any_ident()
}

/// Utilities used in tests in this file (and maybe other files in this crate)
#[cfg(test)]
// PANIC SAFETY unit tests
#[allow(clippy::panic)]
pub(crate) mod test_utils {
    use super::err::ParseErrors;
    use crate::test_utils::*;

    /// Expect that the given `ParseErrors` contains a particular number of errors.
    ///
    /// `src` is the original input text (which the miette labels index into).
    #[track_caller] // report the caller's location as the location of the panic, not the location in this function
    pub fn expect_n_errors(src: &str, errs: &ParseErrors, n: usize) {
        assert_eq!(
            errs.len(),
            n,
            "for the following input:\n{src}\nexpected {n} error(s), but saw {}\nactual errors were:\n{:?}", // the Debug representation of `miette::Report` is the pretty one, for some reason
            errs.len(),
            miette::Report::new(errs.clone())
        );
    }

    /// Expect that the given `ParseErrors` contains at least one error with the given `ExpectedErrorMessage`.
    ///
    /// `src` is the original input text, just for better assertion-failure messages.
    #[track_caller] // report the caller's location as the location of the panic, not the location in this function
    pub fn expect_some_error_matches(
        src: &str,
        errs: &ParseErrors,
        msg: &ExpectedErrorMessage<'_>,
    ) {
        assert!(
            errs.iter().any(|e| msg.matches(Some(src), e)),
            "for the following input:\n{src}\nexpected some error to match the following:\n{msg}\nbut actual errors were:\n{:?}", // the Debug representation of `miette::Report` is the pretty one, for some reason
            miette::Report::new(errs.clone()),
        );
    }

    /// Expect that the given `ParseErrors` contains exactly one error, and that it matches the given `ExpectedErrorMessage`.
    ///
    /// `src` is the original input text, just for better assertion-failure messages
    #[track_caller] // report the caller's location as the location of the panic, not the location in this function
    pub fn expect_exactly_one_error(src: &str, errs: &ParseErrors, msg: &ExpectedErrorMessage<'_>) {
        match errs.len() {
            0 => panic!("for the following input:\n{src}\nexpected an error, but the `ParseErrors` was empty"),
            1 => {
                let err = errs.iter().next().expect("already checked that len was 1");
                expect_err(src, &miette::Report::new(err.clone()), msg);
            }
            n => panic!(
                "for the following input:\n{src}\nexpected only one error, but got {n}. Expected to match the following:\n{msg}\nbut actual errors were:\n{:?}", // the Debug representation of `miette::Report` is the pretty one, for some reason
                miette::Report::new(errs.clone()),
            )
        }
    }
}

// PANIC SAFETY: Unit Test Code
#[allow(clippy::panic, clippy::indexing_slicing)]
#[cfg(test)]
/// Tests for the top-level parsing APIs
mod tests {

    use super::*;

    use crate::ast::test_generators::*;
    use crate::ast::{
        ActionConstraint, Eid, EntityUID, Expr, Literal, PrincipalConstraint, ResourceConstraint,
        Template, Value, Var,
    };
    use crate::evaluator as eval;
    use crate::extensions::Extensions;
    use crate::parser::err::*;
    use crate::parser::test_utils::*;
    use crate::test_utils::*;
    use cool_asserts::assert_matches;
    use std::collections::HashSet;
    use std::sync::Arc;

    #[test]
    fn issue_wf_5046() {
        let policy = parse_policy(
            Some("WF-5046".into()),
            r#"permit(
        principal,
        action in [Action::"action"],
        resource in G::""
      ) when {
        true && ("" like "/gisterNatives\\*D")
      };"#,
        );
        assert!(policy.is_ok());
    }

    #[test]
    fn unescape_err_positions() {
        let assert_invalid_escape = |p_src, underline| {
            assert_matches!(parse_policy_template(None, p_src), Err(e) => {
                expect_err(p_src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("the input `\\q` is not a valid escape").exactly_one_underline(underline).build());
            });
        };
        assert_invalid_escape(
            r#"@foo("\q")permit(principal, action, resource);"#,
            r#"@foo("\q")"#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "\q" };"#,
            r#""\q""#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "\q".contains(0) };"#,
            r#""\q".contains(0)"#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "\q".bar };"#,
            r#""\q".bar"#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "\q"["a"] };"#,
            r#""\q"["a"]"#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { "" like "\q" };"#,
            r#""\q""#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { {}["\q"] };"#,
            r#""\q""#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { {"\q": 0} };"#,
            r#""\q""#,
        );
        assert_invalid_escape(
            r#"permit(principal, action, resource) when { User::"\q" };"#,
            r#"User::"\q""#,
        );
    }

    #[track_caller] // report the caller's location as the location of the panic, not the location in this function
    fn expect_action_error(test: &str, msg: &str, underline: &str) {
        assert_matches!(parse_policyset(test), Err(es) => {
            expect_some_error_matches(
                test,
                &es,
                &ExpectedErrorMessageBuilder::error(msg)
                    .help("action entities must have type `Action`, optionally in a namespace")
                    .exactly_one_underline(underline)
                    .build(),
            );
        });
    }

    #[test]
    fn action_must_be_action() {
        parse_policyset(r#"permit(principal, action == Action::"view", resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(r#"permit(principal, action == Foo::Action::"view", resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(r#"permit(principal, action in Action::"view", resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(r#"permit(principal, action in Foo::Action::"view", resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(r#"permit(principal, action in [Foo::Action::"view"], resource);"#)
            .expect("Valid policy failed to parse");
        parse_policyset(
            r#"permit(principal, action in [Foo::Action::"view", Action::"view"], resource);"#,
        )
        .expect("Valid policy failed to parse");
        expect_action_error(
            r#"permit(principal, action == Foo::"view", resource);"#,
            "expected an entity uid with type `Action` but got `Foo::\"view\"`",
            "Foo::\"view\"",
        );
        expect_action_error(
            r#"permit(principal, action == Action::Foo::"view", resource);"#,
            "expected an entity uid with type `Action` but got `Action::Foo::\"view\"`",
            "Action::Foo::\"view\"",
        );
        expect_action_error(
            r#"permit(principal, action == Bar::Action::Foo::"view", resource);"#,
            "expected an entity uid with type `Action` but got `Bar::Action::Foo::\"view\"`",
            "Bar::Action::Foo::\"view\"",
        );
        expect_action_error(
            r#"permit(principal, action in Bar::Action::Foo::"view", resource);"#,
            "expected an entity uid with type `Action` but got `Bar::Action::Foo::\"view\"`",
            "Bar::Action::Foo::\"view\"",
        );
        expect_action_error(
            r#"permit(principal, action in [Bar::Action::Foo::"view"], resource);"#,
            "expected an entity uid with type `Action` but got `Bar::Action::Foo::\"view\"`",
            "[Bar::Action::Foo::\"view\"]",
        );
        expect_action_error(
            r#"permit(principal, action in [Bar::Action::Foo::"view", Action::"check"], resource);"#,
            "expected an entity uid with type `Action` but got `Bar::Action::Foo::\"view\"`",
            "[Bar::Action::Foo::\"view\", Action::\"check\"]",
        );
        expect_action_error(
        r#"permit(principal, action in [Bar::Action::Foo::"view", Foo::"delete", Action::"check"], resource);"#,
        "expected entity uids with type `Action` but got `Bar::Action::Foo::\"view\"` and `Foo::\"delete\"`",
        "[Bar::Action::Foo::\"view\", Foo::\"delete\", Action::\"check\"]",
    );
    }

    #[test]
    fn method_style() {
        let src = r#"permit(principal, action, resource)
        when { contains(true) < 1 };"#;
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_n_errors(src, &e, 1);
            expect_some_error_matches(
                src,
                &e,
                &ExpectedErrorMessageBuilder::error("`contains` is a method, not a function")
                    .help("use a method-style call `e.contains(..)`")
                    .exactly_one_underline("contains(true)")
                    .build()
            );
        });
    }

    #[test]
    fn test_is_condition_ok() {
        for (es, expr) in [
            (
                r#"User::"alice" is User"#,
                Expr::is_entity_type(
                    Expr::val(r#"User::"alice""#.parse::<EntityUID>().unwrap()),
                    "User".parse().unwrap(),
                ),
            ),
            (
                r#"principal is User"#,
                Expr::is_entity_type(Expr::var(Var::Principal), "User".parse().unwrap()),
            ),
            (
                r#"principal.foo is User"#,
                Expr::is_entity_type(
                    Expr::get_attr(Expr::var(Var::Principal), "foo".into()),
                    "User".parse().unwrap(),
                ),
            ),
            (
                r#"1 is User"#,
                Expr::is_entity_type(Expr::val(1), "User".parse().unwrap()),
            ),
            (
                r#"principal is User in Group::"friends""#,
                Expr::and(
                    Expr::is_entity_type(Expr::var(Var::Principal), "User".parse().unwrap()),
                    Expr::is_in(
                        Expr::var(Var::Principal),
                        Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                    ),
                ),
            ),
            (
                r#"principal is User && principal in Group::"friends""#,
                Expr::and(
                    Expr::is_entity_type(Expr::var(Var::Principal), "User".parse().unwrap()),
                    Expr::is_in(
                        Expr::var(Var::Principal),
                        Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                    ),
                ),
            ),
            (
                r#"principal is User || principal in Group::"friends""#,
                Expr::or(
                    Expr::is_entity_type(Expr::var(Var::Principal), "User".parse().unwrap()),
                    Expr::is_in(
                        Expr::var(Var::Principal),
                        Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                    ),
                ),
            ),
            (
                r#"true && principal is User in principal"#,
                Expr::and(
                    Expr::val(true),
                    Expr::and(
                        Expr::is_entity_type(Expr::var(Var::Principal), "User".parse().unwrap()),
                        Expr::is_in(Expr::var(Var::Principal), Expr::var(Var::Principal)),
                    ),
                ),
            ),
            (
                r#"principal is User in principal && true"#,
                Expr::and(
                    Expr::and(
                        Expr::is_entity_type(Expr::var(Var::Principal), "User".parse().unwrap()),
                        Expr::is_in(Expr::var(Var::Principal), Expr::var(Var::Principal)),
                    ),
                    Expr::val(true),
                ),
            ),
            (
                r#"principal is A::B::C::User"#,
                Expr::is_entity_type(Expr::var(Var::Principal), "A::B::C::User".parse().unwrap()),
            ),
            (
                r#"principal is A::B::C::User in Group::"friends""#,
                Expr::and(
                    Expr::is_entity_type(
                        Expr::var(Var::Principal),
                        "A::B::C::User".parse().unwrap(),
                    ),
                    Expr::is_in(
                        Expr::var(Var::Principal),
                        Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                    ),
                ),
            ),
            (
                r#"if principal is User then 1 else 2"#,
                Expr::ite(
                    Expr::is_entity_type(Expr::var(Var::Principal), "User".parse().unwrap()),
                    Expr::val(1),
                    Expr::val(2),
                ),
            ),
            (
                r#"if principal is User in Group::"friends" then 1 else 2"#,
                Expr::ite(
                    Expr::and(
                        Expr::is_entity_type(Expr::var(Var::Principal), "User".parse().unwrap()),
                        Expr::is_in(
                            Expr::var(Var::Principal),
                            Expr::val(r#"Group::"friends""#.parse::<EntityUID>().unwrap()),
                        ),
                    ),
                    Expr::val(1),
                    Expr::val(2),
                ),
            ),
            (
                r#"principal::"alice" is principal"#,
                Expr::is_entity_type(
                    Expr::val(r#"principal::"alice""#.parse::<EntityUID>().unwrap()),
                    "principal".parse().unwrap(),
                ),
            ),
            (
                r#"foo::principal::"alice" is foo::principal"#,
                Expr::is_entity_type(
                    Expr::val(r#"foo::principal::"alice""#.parse::<EntityUID>().unwrap()),
                    "foo::principal".parse().unwrap(),
                ),
            ),
            (
                r#"principal::foo::"alice" is principal::foo"#,
                Expr::is_entity_type(
                    Expr::val(r#"principal::foo::"alice""#.parse::<EntityUID>().unwrap()),
                    "principal::foo".parse().unwrap(),
                ),
            ),
            (
                r#"resource::"thing" is resource"#,
                Expr::is_entity_type(
                    Expr::val(r#"resource::"thing""#.parse::<EntityUID>().unwrap()),
                    "resource".parse().unwrap(),
                ),
            ),
            (
                r#"action::"do" is action"#,
                Expr::is_entity_type(
                    Expr::val(r#"action::"do""#.parse::<EntityUID>().unwrap()),
                    "action".parse().unwrap(),
                ),
            ),
            (
                r#"context::"stuff" is context"#,
                Expr::is_entity_type(
                    Expr::val(r#"context::"stuff""#.parse::<EntityUID>().unwrap()),
                    "context".parse().unwrap(),
                ),
            ),
        ] {
            let e = parse_expr(es).unwrap();
            assert!(
                e.eq_shape(&expr),
                "{:?} and {:?} should have the same shape.",
                e,
                expr
            );
        }
    }

    #[test]
    fn is_scope() {
        for (src, p, a, r) in [
            (
                r#"permit(principal is User, action, resource);"#,
                PrincipalConstraint::is_entity_type(Arc::new("User".parse().unwrap())),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is principal, action, resource);"#,
                PrincipalConstraint::is_entity_type(Arc::new("principal".parse().unwrap())),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is A::User, action, resource);"#,
                PrincipalConstraint::is_entity_type(Arc::new("A::User".parse().unwrap())),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is User in Group::"thing", action, resource);"#,
                PrincipalConstraint::is_entity_type_in(
                    Arc::new("User".parse().unwrap()),
                    Arc::new(r#"Group::"thing""#.parse().unwrap()),
                ),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is principal in Group::"thing", action, resource);"#,
                PrincipalConstraint::is_entity_type_in(
                    Arc::new("principal".parse().unwrap()),
                    Arc::new(r#"Group::"thing""#.parse().unwrap()),
                ),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is A::User in Group::"thing", action, resource);"#,
                PrincipalConstraint::is_entity_type_in(
                    Arc::new("A::User".parse().unwrap()),
                    Arc::new(r#"Group::"thing""#.parse().unwrap()),
                ),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal is User in ?principal, action, resource);"#,
                PrincipalConstraint::is_entity_type_in_slot(Arc::new("User".parse().unwrap())),
                ActionConstraint::any(),
                ResourceConstraint::any(),
            ),
            (
                r#"permit(principal, action, resource is Folder);"#,
                PrincipalConstraint::any(),
                ActionConstraint::any(),
                ResourceConstraint::is_entity_type(Arc::new("Folder".parse().unwrap())),
            ),
            (
                r#"permit(principal, action, resource is Folder in Folder::"inner");"#,
                PrincipalConstraint::any(),
                ActionConstraint::any(),
                ResourceConstraint::is_entity_type_in(
                    Arc::new("Folder".parse().unwrap()),
                    Arc::new(r#"Folder::"inner""#.parse().unwrap()),
                ),
            ),
            (
                r#"permit(principal, action, resource is Folder in ?resource);"#,
                PrincipalConstraint::any(),
                ActionConstraint::any(),
                ResourceConstraint::is_entity_type_in_slot(Arc::new("Folder".parse().unwrap())),
            ),
        ] {
            let policy = parse_policy_template(None, src).unwrap();
            assert_eq!(policy.principal_constraint(), &p);
            assert_eq!(policy.action_constraint(), &a);
            assert_eq!(policy.resource_constraint(), &r);
        }
    }

    #[test]
    fn is_err() {
        let invalid_is_policies = [
        (
            r#"permit(principal in Group::"friends" is User, action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found an `is` expression")
                .exactly_one_underline(r#"Group::"friends" is User"#)
                .build(),
        ),
        (
            r#"permit(principal, action, resource in Folder::"folder" is File);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found an `is` expression")
                .exactly_one_underline(r#"Folder::"folder" is File"#)
                .build(),
        ),
        (
            r#"permit(principal is User == User::"Alice", action, resource);"#,
            ExpectedErrorMessageBuilder::error("`is` cannot be used together with `==`")
                .help("try using `_ is _ in _`")
                .exactly_one_underline("principal is User == User::\"Alice\"")
                .build(),
        ),
        (
            r#"permit(principal, action, resource is Doc == Doc::"a");"#,
            ExpectedErrorMessageBuilder::error("`is` cannot be used together with `==`")
                .help("try using `_ is _ in _`")
                .exactly_one_underline("resource is Doc == Doc::\"a\"")
                .build(),
        ),
        (
            r#"permit(principal is User::"alice", action, resource);"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `User::"alice"`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("User::\"alice\"")
                .build(),
        ),
        (
            r#"permit(principal, action, resource is File::"f");"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `File::"f"`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("File::\"f\"")
                .build(),
        ),
        (
            r#"permit(principal is User in 1, action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found literal `1`")
                .exactly_one_underline("1")
                .build(),
        ),
        (
            r#"permit(principal, action, resource is File in 1);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found literal `1`")
                .exactly_one_underline("1")
                .build(),
        ),
        (
            r#"permit(principal is User in User, action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found name `User`")
                .exactly_one_underline("User")
                .build(),
        ),
        (
            r#"permit(principal is User::"Alice" in Group::"f", action, resource);"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `User::"Alice"`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("User::\"Alice\"")
                .build(),
        ),
        (
            r#"permit(principal, action, resource is File in File);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found name `File`")
                .exactly_one_underline("File")
                .build(),
        ),
        (
            r#"permit(principal, action, resource is File::"file" in Folder::"folder");"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `File::"file"`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("File::\"file\"")
                .build(),
        ),
        (
            r#"permit(principal is 1, action, resource);"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `1`"#)
            .help("try using `==` to test for equality")
            .exactly_one_underline("1")
            .build(),
        ),
        (
            r#"permit(principal, action, resource is 1);"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `1`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("1")
                .build(),
        ),
        (
            r#"permit(principal, action is Action, resource);"#,
            ExpectedErrorMessageBuilder::error("`is` cannot appear in the action scope")
                .help("try moving `action is ..` into a `when` condition")
                .exactly_one_underline("action is Action")
                .build(),
        ),
        (
            r#"permit(principal, action is Action::"a", resource);"#,
            ExpectedErrorMessageBuilder::error("`is` cannot appear in the action scope")
                .help("try moving `action is ..` into a `when` condition")
                .exactly_one_underline("action is Action::\"a\"")
                .build(),
        ),
        (
            r#"permit(principal, action is Action in Action::"A", resource);"#,
            ExpectedErrorMessageBuilder::error("`is` cannot appear in the action scope")
                .help("try moving `action is ..` into a `when` condition")
                .exactly_one_underline("action is Action in Action::\"A\"")
                .build(),
        ),
        (
            r#"permit(principal, action is Action in Action, resource);"#,
            ExpectedErrorMessageBuilder::error("`is` cannot appear in the action scope")
                .help("try moving `action is ..` into a `when` condition")
                .exactly_one_underline("action is Action in Action")
                .build(),
        ),
        (
            r#"permit(principal, action is Action::"a" in Action::"b", resource);"#,
            ExpectedErrorMessageBuilder::error("`is` cannot appear in the action scope")
                .help("try moving `action is ..` into a `when` condition")
                .exactly_one_underline("action is Action::\"a\" in Action::\"b\"")
                .build(),
        ),
        (
            r#"permit(principal, action is Action in ?action, resource);"#,
            ExpectedErrorMessageBuilder::error("`is` cannot appear in the action scope")
                .help("try moving `action is ..` into a `when` condition")
                .exactly_one_underline("action is Action in ?action")
                .build(),
        ),
        (
            r#"permit(principal, action is ?action, resource);"#,
            ExpectedErrorMessageBuilder::error("`is` cannot appear in the action scope")
                .help("try moving `action is ..` into a `when` condition")
                .exactly_one_underline("action is ?action")
                .build(),
        ),
        (
            r#"permit(principal is User in ?resource, action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?resource instead of ?principal")
                .exactly_one_underline("?resource")
                .build(),
        ),
        (
            r#"permit(principal, action, resource is Folder in ?principal);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?principal instead of ?resource")
                .exactly_one_underline("?principal")
                .build(),
        ),
        (
            r#"permit(principal is ?principal, action, resource);"#,
            ExpectedErrorMessageBuilder::error("right hand side of an `is` expression must be an entity type name, but got `?principal`")
                .help("try using `==` to test for equality")
                .exactly_one_underline("?principal")
                .build(),
        ),
        (
            r#"permit(principal, action, resource is ?resource);"#,
            ExpectedErrorMessageBuilder::error("right hand side of an `is` expression must be an entity type name, but got `?resource`")
                .help("try using `==` to test for equality")
                .exactly_one_underline("?resource")
                .build(),
        ),
        (
            r#"permit(principal, action, resource) when { principal is 1 };"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `1`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("1")
                .build(),
        ),
        (
            r#"permit(principal, action, resource) when { principal is User::"alice" in Group::"friends" };"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `User::"alice"`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("User::\"alice\"")
                .build(),
        ),
        (
            r#"permit(principal, action, resource) when { principal is ! User::"alice" in Group::"friends" };"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `!User::"alice"`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("! User::\"alice\"")
                .build(),
        ),
        (
            r#"permit(principal, action, resource) when { principal is User::"alice" + User::"alice" in Group::"friends" };"#,
            ExpectedErrorMessageBuilder::error(r#"right hand side of an `is` expression must be an entity type name, but got `User::"alice" + User::"alice"`"#)
                .help("try using `==` to test for equality")
                .exactly_one_underline("User::\"alice\" + User::\"alice\"")
                .build(),
        ),
        (
            r#"permit(principal, action, resource) when { principal is User in User::"alice" in Group::"friends" };"#,
            ExpectedErrorMessageBuilder::error("unexpected token `in`")
                .exactly_one_underline_with_label("in", "expected `&&`, `||`, or `}`")
                .build(),
        ),
        (
            r#"permit(principal, action, resource) when { principal is User == User::"alice" in Group::"friends" };"#,
            ExpectedErrorMessageBuilder::error("unexpected token `==`")
                .exactly_one_underline_with_label("==", "expected `&&`, `||`, `}`, or `in`")
                .build(),
        ),
    ];
        for (p_src, expected) in invalid_is_policies {
            assert_matches!(parse_policy_template(None, p_src), Err(e) => {
                expect_err(p_src, &miette::Report::new(e), &expected);
            });
        }
    }

    #[test]
    fn issue_255() {
        let policy = r#"
        permit (
            principal == name-with-dashes::"Alice",
            action,
            resource
        );
    "#;
        assert_matches!(
            parse_policy(None, policy),
            Err(e) => {
                expect_exactly_one_error(
                    policy,
                    &e,
                    &ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found a `+/-` expression")
                        .help("entity types and namespaces cannot use `+` or `-` characters -- perhaps try `_` or `::` instead?")
                        .exactly_one_underline("name-with-dashes::\"Alice\"")
                        .build()
                );
            }
        );
    }

    #[test]
    fn invalid_methods_function_calls() {
        let invalid_exprs = [
            (
                r#"contains([], 1)"#,
                ExpectedErrorMessageBuilder::error("`contains` is a method, not a function")
                    .help("use a method-style call `e.contains(..)`")
                    .exactly_one_underline("contains([], 1)")
                    .build(),
            ),
            (
                r#"[].contains()"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `contains` requires exactly 1 argument, but got 0 arguments",
                )
                .exactly_one_underline("[].contains()")
                .build(),
            ),
            (
                r#"[].contains(1, 2)"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `contains` requires exactly 1 argument, but got 2 arguments",
                )
                .exactly_one_underline("[].contains(1, 2)")
                .build(),
            ),
            (
                r#"[].containsAll()"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `containsAll` requires exactly 1 argument, but got 0 arguments",
                )
                .exactly_one_underline("[].containsAll()")
                .build(),
            ),
            (
                r#"[].containsAll(1, 2)"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `containsAll` requires exactly 1 argument, but got 2 arguments",
                )
                .exactly_one_underline("[].containsAll(1, 2)")
                .build(),
            ),
            (
                r#"[].containsAny()"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `containsAny` requires exactly 1 argument, but got 0 arguments",
                )
                .exactly_one_underline("[].containsAny()")
                .build(),
            ),
            (
                r#"[].containsAny(1, 2)"#,
                ExpectedErrorMessageBuilder::error(
                    "call to `containsAny` requires exactly 1 argument, but got 2 arguments",
                )
                .exactly_one_underline("[].containsAny(1, 2)")
                .build(),
            ),
            (
                r#""1.1.1.1".ip()"#,
                ExpectedErrorMessageBuilder::error("`ip` is a function, not a method")
                    .help("use a function-style call `ip(..)`")
                    .exactly_one_underline(r#""1.1.1.1".ip()"#)
                    .build(),
            ),
            (
                r#"greaterThan(1, 2)"#,
                ExpectedErrorMessageBuilder::error("`greaterThan` is a method, not a function")
                    .help("use a method-style call `e.greaterThan(..)`")
                    .exactly_one_underline("greaterThan(1, 2)")
                    .build(),
            ),
            (
                "[].bar()",
                ExpectedErrorMessageBuilder::error("`bar` is not a valid method")
                    .exactly_one_underline("[].bar()")
                    .build(),
            ),
            (
                "bar([])",
                ExpectedErrorMessageBuilder::error("`bar` is not a valid function")
                    .exactly_one_underline("bar([])")
                    .build(),
            ),
            (
                "principal()",
                ExpectedErrorMessageBuilder::error("`principal(...)` is not a valid function call")
                    .help("variables cannot be called as functions")
                    .exactly_one_underline("principal()")
                    .build(),
            ),
            (
                "(1+1)()",
                ExpectedErrorMessageBuilder::error(
                    "function calls must be of the form `<name>(arg1, arg2, ...)`",
                )
                .exactly_one_underline("(1+1)()")
                .build(),
            ),
            (
                "foo.bar()",
                ExpectedErrorMessageBuilder::error(
                    "attempted to call `foo.bar(...)`, but `foo` does not have any methods",
                )
                .exactly_one_underline("foo.bar()")
                .build(),
            ),
        ];
        for (src, expected) in invalid_exprs {
            assert_matches!(parse_expr(src), Err(e) => {
                expect_err(src, &miette::Report::new(e), &expected);
            });
        }
    }

    #[test]
    fn invalid_slot() {
        let invalid_policies = [
        (
            r#"permit(principal == ?resource, action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?resource instead of ?principal")
                .exactly_one_underline("?resource")
                .build(),
        ),
        (
            r#"permit(principal in ?resource, action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?resource instead of ?principal")
                .exactly_one_underline("?resource")
                .build(),
        ),
        (
            r#"permit(principal == ?foo, action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?foo instead of ?principal")
                .exactly_one_underline("?foo")
                .build(),
        ),
        (
            r#"permit(principal in ?foo, action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?foo instead of ?principal")
                .exactly_one_underline("?foo")
                .build(),
        ),

        (
            r#"permit(principal, action, resource == ?principal);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?principal instead of ?resource")
                .exactly_one_underline("?principal")
                .build(),
        ),
        (
            r#"permit(principal, action, resource in ?principal);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?principal instead of ?resource")
                .exactly_one_underline("?principal")
                .build(),
        ),
        (
            r#"permit(principal, action, resource == ?baz);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?baz instead of ?resource")
                .exactly_one_underline("?baz")
                .build(),
        ),
        (
            r#"permit(principal, action, resource in ?baz);"#,
            ExpectedErrorMessageBuilder::error("expected an entity uid or matching template slot, found ?baz instead of ?resource")
                .exactly_one_underline("?baz")
                .build(),
        ),
        (
            r#"permit(principal, action, resource) when { principal == ?foo};"#,
            ExpectedErrorMessageBuilder::error("`?foo` is not a valid template slot")
                .help("a template slot may only be `?principal` or `?resource`")
                .exactly_one_underline("?foo")
                .build(),
        ),

        (
            r#"permit(principal, action == ?action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected single entity uid, got: template slot")
                .exactly_one_underline("?action")
                .build(),
        ),
        (
            r#"permit(principal, action in ?action, resource);"#,
            ExpectedErrorMessageBuilder::error("expected single entity uid or set of entity uids, got: template slot")
                .exactly_one_underline("?action")
                .build(),
        ),
        (
            r#"permit(principal, action == ?principal, resource);"#,
            ExpectedErrorMessageBuilder::error("expected single entity uid, got: template slot")
                .exactly_one_underline("?principal")
                .build(),
        ),
        (
            r#"permit(principal, action in ?principal, resource);"#,
            ExpectedErrorMessageBuilder::error("expected single entity uid or set of entity uids, got: template slot")
                .exactly_one_underline("?principal")
                .build(),
        ),
        (
            r#"permit(principal, action == ?resource, resource);"#,
            ExpectedErrorMessageBuilder::error("expected single entity uid, got: template slot")
                .exactly_one_underline("?resource")
                .build(),
        ),
        (
            r#"permit(principal, action in ?resource, resource);"#,
            ExpectedErrorMessageBuilder::error("expected single entity uid or set of entity uids, got: template slot")
                .exactly_one_underline("?resource")
                .build(),
        ),
        (
            r#"permit(principal, action in [?bar], resource);"#,
            ExpectedErrorMessageBuilder::error("expected single entity uid, got: template slot")
                .exactly_one_underline("?bar")
                .build(),
        ),
    ];

        for (p_src, expected) in invalid_policies {
            assert_matches!(parse_policy_template(None, p_src), Err(e) => {
                expect_err(p_src, &miette::Report::new(e), &expected);
            });
            let forbid_src = format!("forbid{}", &p_src[6..]);
            assert_matches!(parse_policy_template(None, &forbid_src), Err(e) => {
                expect_err(forbid_src.as_str(), &miette::Report::new(e), &expected);
            });
        }
    }

    #[test]
    fn missing_scope_constraint() {
        let p_src = "permit();";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("this policy is missing the `principal` variable in the scope")
                    .exactly_one_underline("")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .build()
            );
        });
        let p_src = "permit(principal);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("this policy is missing the `action` variable in the scope")
                    .exactly_one_underline("")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .build()
            );
        });
        let p_src = "permit(principal, action);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("this policy is missing the `resource` variable in the scope")
                    .exactly_one_underline("")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .build()
            );
        });
    }

    #[test]
    fn invalid_scope_constraint() {
        let p_src = "permit(foo, action, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("found an invalid variable in the policy scope: foo")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .exactly_one_underline("foo")
                    .build()
            );
        });
        let p_src = "permit(foo::principal, action, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("unexpected token `::`")
                    .exactly_one_underline_with_label("::", "expected `!=`, `)`, `,`, `:`, `<`, `<=`, `==`, `>`, `>=`, `in`, or `is`")
                    .build()
            );
        });
        let p_src = "permit(resource, action, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("found the variable `resource` where the variable `principal` must be used")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .exactly_one_underline("resource")
                    .build()
            );
        });

        let p_src = "permit(principal, principal, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("found the variable `principal` where the variable `action` must be used")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .exactly_one_underline("principal")
                    .build()
            );
        });
        let p_src = "permit(principal, if, resource);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("found an invalid variable in the policy scope: if")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .exactly_one_underline("if")
                    .build()
            );
        });

        let p_src = "permit(principal, action, like);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("found an invalid variable in the policy scope: like")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .exactly_one_underline("like")
                    .build()
            );
        });
        let p_src = "permit(principal, action, principal);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("found the variable `principal` where the variable `resource` must be used")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .exactly_one_underline("principal")
                    .build()
            );
        });
        let p_src = "permit(principal, action, action);";
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("found the variable `action` where the variable `resource` must be used")
                    .help("policy scopes must contain a `principal`, `action`, and `resource` element in that order")
                    .exactly_one_underline("action")
                    .build()
            );
        });
    }

    #[test]
    fn invalid_scope_operator() {
        let p_src = r#"permit(principal > User::"alice", action, resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("invalid operator in the policy scope: >")
                    .help("policy scope clauses can only use `==`, `in`, `is`, or `_ is _ in _`")
                    .exactly_one_underline("principal > User::\"alice\"")
                    .build()
            );
        });
        let p_src = r#"permit(principal, action != Action::"view", resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("invalid operator in the action scope: !=")
                    .help("action scope clauses can only use `==` or `in`")
                    .exactly_one_underline("action != Action::\"view\"")
                    .build()
            );
        });
        let p_src = r#"permit(principal, action, resource <= Folder::"things");"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("invalid operator in the policy scope: <=")
                    .help("policy scope clauses can only use `==`, `in`, `is`, or `_ is _ in _`")
                    .exactly_one_underline("resource <= Folder::\"things\"")
                    .build()
            );
        });
        let p_src = r#"permit(principal = User::"alice", action, resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("'=' is not a valid operator in Cedar")
                    .help("try using '==' instead")
                    .exactly_one_underline("principal = User::\"alice\"")
                    .build()
            );
        });
    }

    #[test]
    fn scope_action_eq_set() {
        let p_src = r#"permit(principal, action == [Action::"view", Action::"edit"], resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("expected single entity uid, got: set of entity uids")
                    .exactly_one_underline(r#"[Action::"view", Action::"edit"]"#)
                    .build()
            );
        });
    }

    #[test]
    fn scope_action_in_set_set() {
        let p_src = r#"permit(principal, action in [[Action::"view"]], resource);"#;
        assert_matches!(parse_policy_template(None, p_src), Err(e) => {
            expect_err(
                p_src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("expected single entity uid, got: set of entity uids")
                    .exactly_one_underline(r#"[Action::"view"]"#)
                    .build()
            );
        });
    }

    #[test]
    fn unsupported_ops() {
        let src = "1/2";
        assert_matches!(parse_expr(src), Err(e) => {
            expect_err(
                src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("division is not supported")
                    .exactly_one_underline("1/2")
                    .build()
            );
        });
        let src = "7 % 3";
        assert_matches!(parse_expr(src), Err(e) => {
            expect_err(
                src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("remainder/modulo is not supported")
                    .exactly_one_underline("7 % 3")
                    .build()
            );
        });
    }

    #[test]
    fn over_unary() {
        let src = "!!!!!!false";
        assert_matches!(parse_expr(src), Err(e) => {
            expect_err(
                src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("too many occurrences of `!_`")
                    .help("cannot chain more the 4 applications of a unary operator")
                    .exactly_one_underline("!!!!!!false")
                    .build()
            );
        });
        let src = "-------0";
        assert_matches!(parse_expr(src), Err(e) => {
            expect_err(
                src,
                &miette::Report::new(e),
                &ExpectedErrorMessageBuilder::error("too many occurrences of `-_`")
                    .help("cannot chain more the 4 applications of a unary operator")
                    .exactly_one_underline("-------0")
                    .build()
            );
        });
    }

    #[test]
    fn arbitrary_variables() {
        #[track_caller]
        fn expect_arbitrary_var(name: &str) {
            assert_matches!(parse_expr(name), Err(e) => {
                expect_err(
                    name,
                    &miette::Report::new(e),
                    &ExpectedErrorMessageBuilder::error(&format!("invalid variable: {name}"))
                        .help(&format!("the valid Cedar variables are `principal`, `action`, `resource`, and `context`; did you mean to enclose `{name}` in quotes to make a string?"))
                        .exactly_one_underline(name)
                        .build()
                );
            })
        }
        expect_arbitrary_var("foo::principal");
        expect_arbitrary_var("bar::action");
        expect_arbitrary_var("baz::resource");
        expect_arbitrary_var("buz::context");
        expect_arbitrary_var("foo::principal");
        expect_arbitrary_var("foo::bar::principal");
        expect_arbitrary_var("principal::foo");
        expect_arbitrary_var("principal::foo::bar");
        expect_arbitrary_var("foo::principal::bar");
        expect_arbitrary_var("foo");
        expect_arbitrary_var("foo::bar");
        expect_arbitrary_var("foo::bar::baz");
    }

    #[test]
    fn empty_clause() {
        #[track_caller]
        fn expect_empty_clause(policy: &str, clause: &str) {
            assert_matches!(parse_policy_template(None, policy), Err(e) => {
                expect_err(
                    policy,
                    &miette::Report::new(e),
                    &ExpectedErrorMessageBuilder::error(&format!("`{clause}` condition clause cannot be empty"))
                        .exactly_one_underline(&format!("{clause} {{}}"))
                        .build()
                );
            })
        }

        expect_empty_clause("permit(principal, action, resource) when {};", "when");
        expect_empty_clause("permit(principal, action, resource) unless {};", "unless");
        expect_empty_clause(
            "permit(principal, action, resource) when { principal has foo } when {};",
            "when",
        );
        expect_empty_clause(
            "permit(principal, action, resource) when { principal has foo } unless {};",
            "unless",
        );
        expect_empty_clause(
            "permit(principal, action, resource) when {} unless { resource.bar };",
            "when",
        );
        expect_empty_clause(
            "permit(principal, action, resource) unless {} unless { resource.bar };",
            "unless",
        );
    }

    #[test]
    fn namespaced_attr() {
        #[track_caller]
        fn expect_namespaced_attr(expr: &str, name: &str) {
            assert_matches!(parse_expr(expr), Err(e) => {
                expect_err(
                    expr,
                    &miette::Report::new(e),
                    &ExpectedErrorMessageBuilder::error(&format!("`{name}` cannot be used as an attribute as it contains a namespace"))
                        .exactly_one_underline(name)
                        .build()
                );
            })
        }

        expect_namespaced_attr("principal has foo::bar", "foo::bar");
        expect_namespaced_attr("principal has foo::bar::baz", "foo::bar::baz");
        expect_namespaced_attr("principal has foo::principal", "foo::principal");
        expect_namespaced_attr("{foo::bar: 1}", "foo::bar");

        let expr = "principal has if::foo";
        assert_matches!(parse_expr(expr), Err(e) => {
            expect_err(expr, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error(
                "this identifier is reserved and cannot be used: if"
            ).exactly_one_underline("if").build());
        })
    }

    #[test]
    fn reserved_ident_var() {
        #[track_caller]
        fn expect_reserved_ident(name: &str, reserved: &str) {
            assert_matches!(parse_expr(name), Err(e) => {
                expect_err(
                    name,
                    &miette::Report::new(e),
                    &ExpectedErrorMessageBuilder::error(&format!("this identifier is reserved and cannot be used: {reserved}"))
                        .exactly_one_underline(reserved)
                        .build()
                );
            })
        }
        expect_reserved_ident("if::principal", "if");
        expect_reserved_ident("then::action", "then");
        expect_reserved_ident("else::resource", "else");
        expect_reserved_ident("true::context", "true");
        expect_reserved_ident("false::bar::principal", "false");
        expect_reserved_ident("foo::in::principal", "in");
        expect_reserved_ident("foo::is::bar::principal", "is");
    }

    #[test]
    fn test_template_parsing() {
        for template in all_templates().map(Template::from) {
            let id = template.id();
            let src = format!("{template}");
            let parsed = parse_policy_template(Some(id.to_string()), &src).unwrap();
            assert_eq!(
                parsed.slots().collect::<HashSet<_>>(),
                template.slots().collect::<HashSet<_>>()
            );
            assert_eq!(parsed.id(), template.id());
            assert_eq!(parsed.effect(), template.effect());
            assert_eq!(
                parsed.principal_constraint(),
                template.principal_constraint()
            );
            assert_eq!(parsed.action_constraint(), template.action_constraint());
            assert_eq!(parsed.resource_constraint(), template.resource_constraint());
            assert!(
                parsed
                    .non_scope_constraints()
                    .eq_shape(template.non_scope_constraints()),
                "{:?} and {:?} should have the same shape.",
                parsed.non_scope_constraints(),
                template.non_scope_constraints()
            );
        }
    }

    #[test]
    fn test_error_out() {
        let src = r#"
            permit(principal:p,action:a,resource:r)
            when{w or if c but not z} // expr error
            unless{u if c else d or f} // expr error
            advice{"doit"};

            permit(principality in Group::"jane_friends", // policy error
            action in [PhotoOp::"view", PhotoOp::"comment"],
            resource in Album::"jane_trips");

            forbid(principal, action, resource)
            when   { "private" in resource.tags }
            unless { resource in principal.account };
        "#;
        let errs = parse_policyset(src).expect_err("expected parsing to fail");
        // Lots of errors! All of them are "unrecognized token" errors from the text->CST parser
        expect_n_errors(src, &errs, 16);
        assert!(errs.iter().all(|err| matches!(err, ParseError::ToCST(_))));
        let unrecognized_tokens = vec![
            ("or", "expected `!=`, `&&`, `(`, `*`, `+`, `-`, `.`, `::`, `<`, `<=`, `==`, `>`, `>=`, `[`, `||`, `}`, `has`, `in`, `is`, or `like`"), 
            ("if", "expected `(`"), 
            ("c", "expected `(`"), 
            ("but", "expected `(`"), 
            ("not", "expected `(`"), 
            ("z", "expected `(`"), 
            ("}", "expected `(`"), 
            ("{", "expected `(`"), 
            ("else", "expected `(`"), 
            ("d", "expected `(`"), 
            ("f", "expected `(`"),
        ];
        for (token, label) in unrecognized_tokens {
            expect_some_error_matches(
                src,
                &errs,
                &ExpectedErrorMessageBuilder::error(&format!("unexpected token `{token}`"))
                    .exactly_one_underline_with_label(token, label)
                    .build(),
            );
        }
    }

    #[test]
    fn entity_literals1() {
        let src = r#"Test::{ test : "Test" }"#;
        let errs = parse_euid(src).unwrap_err();
        expect_exactly_one_error(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("invalid entity literal: Test::{test: \"Test\"}")
                .help("entity literals should have a form like `Namespace::User::\"alice\"`")
                .exactly_one_underline("Test::{ test : \"Test\" }")
                .build(),
        );
    }

    #[test]
    fn entity_literals2() {
        let src = r#"permit(principal == Test::{ test : "Test" }, action, resource);"#;
        let errs = parse_policy(None, src).unwrap_err();
        expect_exactly_one_error(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("invalid entity literal: Test::{test: \"Test\"}")
                .help("entity literals should have a form like `Namespace::User::\"alice\"`")
                .exactly_one_underline("Test::{ test : \"Test\" }")
                .build(),
        );
    }

    #[test]
    fn interpret_exprs() {
        let request = eval::test::basic_request();
        let entities = eval::test::basic_entities();
        let exts = Extensions::none();
        let evaluator = eval::Evaluator::new(request, &entities, &exts);
        // The below tests check not only that we get the expected `Value`, but
        // that it has the expected source location.
        // We have to check that separately because the `PartialEq` and `Eq`
        // impls for `Value` do not compare source locations.
        // This is somewhat a test of the evaluator, not just the parser; but
        // the actual evaluator unit tests do not use the parser and thus do
        // not have source locations attached to their input expressions, so
        // this file is where we effectively perform evaluator tests related to
        // propagating source locations from expressions to values.

        // bools
        let src = "false";
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(false));
        assert_eq!(val.source_loc(), Some(&Loc::new(0..5, Arc::from(src))));

        let src = "true && true";
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(true));
        assert_eq!(val.source_loc(), Some(&Loc::new(0..12, Arc::from(src))));

        let src = "!true || false && !true";
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(false));
        assert_eq!(val.source_loc(), Some(&Loc::new(0..23, Arc::from(src))));

        let src = "!!!!true";
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(true));
        assert_eq!(val.source_loc(), Some(&Loc::new(0..8, Arc::from(src))));

        let src = r#"
        if false || true != 4 then
            600
        else
            -200
        "#;
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(600));
        assert_eq!(val.source_loc(), Some(&Loc::new(9..81, Arc::from(src))));
    }

    #[test]
    fn interpret_membership() {
        let request = eval::test::basic_request();
        let entities = eval::test::rich_entities();
        let exts = Extensions::none();
        let evaluator = eval::Evaluator::new(request, &entities, &exts);
        // The below tests check not only that we get the expected `Value`, but
        // that it has the expected source location.
        // See note on this in the above test.

        let src = r#"

        test_entity_type::"child" in
            test_entity_type::"unrelated"

        "#;
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(false));
        assert_eq!(val.source_loc(), Some(&Loc::new(10..80, Arc::from(src))));
        // because "10..80" is hard to read, we also assert that the correct portion of `src` is indicated
        assert_eq!(
            val.source_loc().unwrap().snippet(),
            Some(
                r#"test_entity_type::"child" in
            test_entity_type::"unrelated""#
            )
        );

        let src = r#"

        test_entity_type::"child" in
            test_entity_type::"child"

        "#;
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(true));
        assert_eq!(val.source_loc(), Some(&Loc::new(10..76, Arc::from(src))));
        assert_eq!(
            val.source_loc().unwrap().snippet(),
            Some(
                r#"test_entity_type::"child" in
            test_entity_type::"child""#
            )
        );

        let src = r#"

        other_type::"other_child" in
            test_entity_type::"parent"

        "#;
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(true));
        assert_eq!(val.source_loc(), Some(&Loc::new(10..77, Arc::from(src))));
        assert_eq!(
            val.source_loc().unwrap().snippet(),
            Some(
                r#"other_type::"other_child" in
            test_entity_type::"parent""#
            )
        );

        let src = r#"

        test_entity_type::"child" in
            test_entity_type::"grandparent"

        "#;
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(true));
        assert_eq!(val.source_loc(), Some(&Loc::new(10..82, Arc::from(src))));
        assert_eq!(
            val.source_loc().unwrap().snippet(),
            Some(
                r#"test_entity_type::"child" in
            test_entity_type::"grandparent""#
            )
        );
    }

    #[test]
    fn interpret_relation() {
        let request = eval::test::basic_request();
        let entities = eval::test::basic_entities();
        let exts = Extensions::none();
        let evaluator = eval::Evaluator::new(request, &entities, &exts);
        // The below tests check not only that we get the expected `Value`, but
        // that it has the expected source location.
        // See note on this in the above test.

        let src = r#"

            3 < 2 || 2 > 3

        "#;
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(false));
        assert_eq!(val.source_loc(), Some(&Loc::new(14..28, Arc::from(src))));
        // because "14..28" is hard to read, we also assert that the correct portion of `src` is indicated
        assert_eq!(val.source_loc().unwrap().snippet(), Some("3 < 2 || 2 > 3"));

        let src = r#"

            7 <= 7 && 4 != 5

        "#;
        let expr = parse_expr(src).unwrap();
        let val = evaluator.interpret_inline_policy(&expr).unwrap();
        assert_eq!(val, Value::from(true));
        assert_eq!(val.source_loc(), Some(&Loc::new(14..30, Arc::from(src))));
        assert_eq!(
            val.source_loc().unwrap().snippet(),
            Some("7 <= 7 && 4 != 5")
        );
    }

    #[test]
    fn parse_exists() {
        let result = parse_policyset(
            r#"
            permit(principal, action, resource)
            when{ true };
        "#,
        );
        assert!(!result.expect("parse error").is_empty());
    }

    #[test]
    fn test_parse_policyset() {
        use crate::ast::PolicyID;
        let multiple_policies = r#"
            permit(principal, action, resource)
            when { principal == resource.owner };

            forbid(principal, action == Action::"modify", resource) // a comment
            when { resource . highSecurity }; // intentionally not conforming to our formatter
        "#;
        let pset = parse_policyset(multiple_policies).expect("Should parse");
        assert_eq!(pset.policies().count(), 2);
        assert_eq!(pset.static_policies().count(), 2);
        let (texts, pset) =
            parse_policyset_and_also_return_policy_text(multiple_policies).expect("Should parse");
        assert_eq!(pset.policies().count(), 2);
        assert_eq!(pset.static_policies().count(), 2);
        assert_eq!(texts.len(), 2);
        assert_eq!(
            texts.get(&PolicyID::from_string("policy0")),
            Some(
                &r#"permit(principal, action, resource)
            when { principal == resource.owner };"#
            )
        );
        assert_eq!(
            texts.get(&PolicyID::from_string("policy1")),
            Some(
                &r#"forbid(principal, action == Action::"modify", resource) // a comment
            when { resource . highSecurity };"#
            )
        );
    }

    #[test]
    fn test_parse_string() {
        // test idempotence
        assert_eq!(
            Eid::new(parse_internal_string(r"a\nblock\nid").expect("should parse")).escaped(),
            r"a\nblock\nid",
        );
        parse_internal_string(r#"oh, no, a '! "#).expect("single quote should be fine");
        parse_internal_string(r#"oh, no, a \"! and a \'! "#).expect("escaped quotes should parse");
        let src = r#"oh, no, a "! "#;
        let errs = parse_internal_string(src).expect_err("unescaped double quote not allowed");
        expect_exactly_one_error(
            src,
            &errs,
            &ExpectedErrorMessageBuilder::error("invalid token")
                .exactly_one_underline("")
                .build(),
        );
    }

    #[test]
    fn good_cst_bad_ast() {
        let src = r#"
            permit(principal, action, resource) when { principal.name.like == "3" };
            "#;
        let p = parse_policyset_to_ests_and_pset(src);
        assert_matches!(p, Err(e) => expect_err(src, &miette::Report::new(e), &ExpectedErrorMessageBuilder::error("this identifier is reserved and cannot be used: like").exactly_one_underline("like").build()));
    }

    #[test]
    fn no_slots_in_condition() {
        let src = r#"
            permit(principal, action, resource) when {
                resource == ?resource
            };
            "#;
        let slot_in_when_clause =
            ExpectedErrorMessageBuilder::error("found template slot ?resource in a `when` clause")
                .help("slots are currently unsupported in `when` clauses")
                .exactly_one_underline("?resource")
                .build();
        let unexpected_template = ExpectedErrorMessageBuilder::error(
            "expected a static policy, got a template containing the slot ?resource",
        )
        .help("try removing the template slot(s) from this policy")
        .exactly_one_underline("?resource")
        .build();
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &unexpected_template);
        });
        assert_matches!(parse_policy_template(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_when_clause);
        });
        assert_matches!(parse_policy_to_est_and_ast(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &unexpected_template);
        });
        assert_matches!(parse_policy_template_to_est_and_ast(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_when_clause);
        });
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_when_clause);
        });
        assert_matches!(parse_policyset_to_ests_and_pset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_when_clause);
        });

        let src = r#"
            permit(principal, action, resource) when {
                resource == ?principal
            };
            "#;
        let slot_in_when_clause =
            ExpectedErrorMessageBuilder::error("found template slot ?principal in a `when` clause")
                .help("slots are currently unsupported in `when` clauses")
                .exactly_one_underline("?principal")
                .build();
        let unexpected_template = ExpectedErrorMessageBuilder::error(
            "expected a static policy, got a template containing the slot ?principal",
        )
        .help("try removing the template slot(s) from this policy")
        .exactly_one_underline("?principal")
        .build();
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &unexpected_template);
        });
        assert_matches!(parse_policy_template(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_when_clause);
        });
        assert_matches!(parse_policy_to_est_and_ast(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &unexpected_template);
        });
        assert_matches!(parse_policy_template_to_est_and_ast(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_when_clause);
        });
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_when_clause);
        });
        assert_matches!(parse_policyset_to_ests_and_pset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_when_clause);
        });

        let src = r#"
            permit(principal, action, resource) when {
                resource == ?blah
            };
            "#;
        let error = ExpectedErrorMessageBuilder::error("`?blah` is not a valid template slot")
            .help("a template slot may only be `?principal` or `?resource`")
            .exactly_one_underline("?blah")
            .build();
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policy_template(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policy_to_est_and_ast(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policy_template_to_est_and_ast(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policyset_to_ests_and_pset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });

        let src = r#"
            permit(principal, action, resource) unless {
                resource == ?resource
            };
            "#;
        let slot_in_unless_clause = ExpectedErrorMessageBuilder::error(
            "found template slot ?resource in a `unless` clause",
        )
        .help("slots are currently unsupported in `unless` clauses")
        .exactly_one_underline("?resource")
        .build();
        let unexpected_template = ExpectedErrorMessageBuilder::error(
            "expected a static policy, got a template containing the slot ?resource",
        )
        .help("try removing the template slot(s) from this policy")
        .exactly_one_underline("?resource")
        .build();
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
            expect_some_error_matches(src, &e, &unexpected_template);
        });
        assert_matches!(parse_policy_template(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policy_to_est_and_ast(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
            expect_some_error_matches(src, &e, &unexpected_template);
        });
        assert_matches!(parse_policy_template_to_est_and_ast(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policyset_to_ests_and_pset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_unless_clause);
        });

        let src = r#"
            permit(principal, action, resource) unless {
                resource == ?principal
            };
            "#;
        let slot_in_unless_clause = ExpectedErrorMessageBuilder::error(
            "found template slot ?principal in a `unless` clause",
        )
        .help("slots are currently unsupported in `unless` clauses")
        .exactly_one_underline("?principal")
        .build();
        let unexpected_template = ExpectedErrorMessageBuilder::error(
            "expected a static policy, got a template containing the slot ?principal",
        )
        .help("try removing the template slot(s) from this policy")
        .exactly_one_underline("?principal")
        .build();
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
            expect_some_error_matches(src, &e, &unexpected_template);
        });
        assert_matches!(parse_policy_template(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policy_to_est_and_ast(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
            expect_some_error_matches(src, &e, &unexpected_template);
        });
        assert_matches!(parse_policy_template_to_est_and_ast(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policyset_to_ests_and_pset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &slot_in_unless_clause);
        });

        let src = r#"
            permit(principal, action, resource) unless {
                resource == ?blah
            };
            "#;
        let error = ExpectedErrorMessageBuilder::error("`?blah` is not a valid template slot")
            .help("a template slot may only be `?principal` or `?resource`")
            .exactly_one_underline("?blah")
            .build();
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policy_template(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policy_to_est_and_ast(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policy_template_to_est_and_ast(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });
        assert_matches!(parse_policyset_to_ests_and_pset(src), Err(e) => {
            expect_exactly_one_error(src, &e, &error);
        });

        let src = r#"
            permit(principal, action, resource) unless {
                resource == ?resource
            } when {
                resource == ?resource
            };
            "#;
        let slot_in_when_clause =
            ExpectedErrorMessageBuilder::error("found template slot ?resource in a `when` clause")
                .help("slots are currently unsupported in `when` clauses")
                .exactly_one_underline("?resource")
                .build();
        let slot_in_unless_clause = ExpectedErrorMessageBuilder::error(
            "found template slot ?resource in a `unless` clause",
        )
        .help("slots are currently unsupported in `unless` clauses")
        .exactly_one_underline("?resource")
        .build();
        let unexpected_template = ExpectedErrorMessageBuilder::error(
            "expected a static policy, got a template containing the slot ?resource",
        )
        .help("try removing the template slot(s) from this policy")
        .exactly_one_underline("?resource")
        .build();
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_n_errors(src, &e, 4);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
            expect_some_error_matches(src, &e, &unexpected_template); // 2 copies of this error
        });
        assert_matches!(parse_policy_template(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policy_to_est_and_ast(None, src), Err(e) => {
            expect_n_errors(src, &e, 4);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
            expect_some_error_matches(src, &e, &unexpected_template); // 2 copies of this error
        });
        assert_matches!(parse_policy_template_to_est_and_ast(None, src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policyset(src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
        });
        assert_matches!(parse_policyset_to_ests_and_pset(src), Err(e) => {
            expect_n_errors(src, &e, 2);
            expect_some_error_matches(src, &e, &slot_in_when_clause);
            expect_some_error_matches(src, &e, &slot_in_unless_clause);
        });
    }

    #[test]
    fn record_literals() {
        // unquoted keys
        let src = r#"permit(principal, action, resource) when { context.foo == { foo: 2, bar: "baz" } };"#;
        assert_matches!(parse_policy(None, src), Ok(_));
        // quoted keys
        let src = r#"permit(principal, action, resource) when { context.foo == { "foo": 2, "hi mom it's 🦀": "baz" } };"#;
        assert_matches!(parse_policy(None, src), Ok(_));
        // duplicate key
        let src = r#"permit(principal, action, resource) when { context.foo == { "spam": -341, foo: 2, "🦀": true, foo: "baz" } };"#;
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &ExpectedErrorMessageBuilder::error("duplicate key `foo` in record literal").exactly_one_underline(r#"{ "spam": -341, foo: 2, "🦀": true, foo: "baz" }"#).build());
        });
    }

    #[test]
    fn annotation_errors() {
        let src = r#"
            @foo("1")
            @foo("2")
            permit(principal, action, resource);
        "#;
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &ExpectedErrorMessageBuilder::error("duplicate annotation: @foo").exactly_one_underline(r#"@foo("2")"#).build());
        });

        let src = r#"
            @foo("1")
            @foo("1")
            permit(principal, action, resource);
        "#;
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_exactly_one_error(src, &e, &ExpectedErrorMessageBuilder::error("duplicate annotation: @foo").exactly_one_underline(r#"@foo("1")"#).build());
        });

        let src = r#"
            @foo("1")
            @bar("yellow")
            @foo("abc")
            @hello("goodbye")
            @bar("123")
            @foo("def")
            permit(principal, action, resource);
        "#;
        assert_matches!(parse_policy(None, src), Err(e) => {
            expect_n_errors(src, &e, 3); // two errors for @foo and one for @bar
            expect_some_error_matches(src, &e, &ExpectedErrorMessageBuilder::error("duplicate annotation: @foo").exactly_one_underline(r#"@foo("abc")"#).build());
            expect_some_error_matches(src, &e, &ExpectedErrorMessageBuilder::error("duplicate annotation: @foo").exactly_one_underline(r#"@foo("def")"#).build());
            expect_some_error_matches(src, &e, &ExpectedErrorMessageBuilder::error("duplicate annotation: @bar").exactly_one_underline(r#"@bar("123")"#).build());
        })
    }

    #[test]
    fn unexpected_token_errors() {
        #[track_caller]
        fn assert_labeled_span(src: &str, msg: &str, underline: &str, label: &str) {
            assert_matches!(parse_policy(None, src), Err(e) => {
                expect_exactly_one_error(
                    src,
                    &e,
                    &ExpectedErrorMessageBuilder::error(msg)
                        .exactly_one_underline_with_label(underline, label)
                        .build());
            });
        }

        // Don't list out all the special case identifiers
        assert_labeled_span("@", "unexpected end of input", "", "expected identifier");
        assert_labeled_span(
            "permit(principal, action, resource) when { principal.",
            "unexpected end of input",
            "",
            "expected identifier",
        );

        // We specifically want `when` or `unless`, but we previously listed all
        // identifier tokens, so this is an improvement.
        assert_labeled_span(
            "permit(principal, action, resource)",
            "unexpected end of input",
            "",
            "expected `;` or identifier",
        );
        // AST actually requires `permit` or `forbid`, but grammar looks for any
        // identifier.
        assert_labeled_span(
            "@if(\"a\")",
            "unexpected end of input",
            "",
            "expected `@` or identifier",
        );
        // AST actually requires `principal` (`action`, `resource`, resp.). In
        // the `principal` case we also claim to expect `)` because an empty scope
        // initially parses to a CST. The trailing comma rules this out in the others.
        assert_labeled_span(
            "permit(",
            "unexpected end of input",
            "",
            "expected `)` or identifier",
        );
        assert_labeled_span(
            "permit(,,);",
            "unexpected token `,`",
            ",",
            "expected `)` or identifier",
        );
        assert_labeled_span(
            "permit(principal,",
            "unexpected end of input",
            "",
            "expected identifier",
        );
        assert_labeled_span(
            "permit(principal,action,",
            "unexpected end of input",
            "",
            "expected identifier",
        );
        // Nothing will actually convert to an AST here.
        assert_labeled_span(
            "permit(principal,action,resource,",
            "unexpected end of input",
            "",
            "expected identifier",
        );
        // We still list out `if` as an expected token because it doesn't get
        // parsed as an ident in this position.
        assert_labeled_span(
            "permit(principal, action, resource) when {",
            "unexpected end of input",
            "", 
            "expected `!`, `(`, `-`, `[`, `{`, `}`, `false`, identifier, `if`, number, `?principal`, `?resource`, string literal, or `true`",
        );
        // The right operand of an `is` gets parsed as any `Expr`, so we will
        // list out all the possible expression tokens even though _only_
        // `identifier` is accepted. This choice allows nicer error messages for
        // `principal is User::"alice"`, but it doesn't work in our favor here.
        assert_labeled_span(
            "permit(principal, action, resource) when { principal is",
            "unexpected end of input",
            "", 
            "expected `!`, `(`, `-`, `[`, `{`, `false`, identifier, `if`, number, `?principal`, `?resource`, string literal, or `true`",
        );

        // We expect binary operators, but don't claim to expect `=`, `%` or
        // `/`. We still expect `::` even though `true` is a reserved identifier
        // and so we can't have an entity reference `true::"eid"`
        assert_labeled_span(
            "permit(principal, action, resource) when { if true",
            "unexpected end of input",
            "", 
            "expected `!=`, `&&`, `(`, `*`, `+`, `-`, `.`, `::`, `<`, `<=`, `==`, `>`, `>=`, `[`, `||`, `has`, `in`, `is`, `like`, or `then`",
        )
    }

    #[test]
    fn string_escapes() {
        // test strings with valid escapes
        // convert a string `s` to `<double-quote> <escaped-form-of-s> <double-quote>`
        // and test if the resulting string literal AST contains exactly `s`
        // for instance, "\u{1F408}"" is converted into r#""\u{1F408}""#,
        // the latter should be parsed into `Literal(String("🐈"))` and
        // `🐈` is represented by '\u{1F408}'
        let test_valid = |s: &str| {
            let r = parse_literal(&format!("\"{}\"", s.escape_default()));
            assert_eq!(r, Ok(Literal::String(s.into())));
        };
        test_valid("\t");
        test_valid("\0");
        test_valid("👍");
        test_valid("🐈");
        test_valid("\u{1F408}");
        test_valid("abc\tde\\fg");
        test_valid("aaa\u{1F408}bcd👍👍👍");
        // test string with invalid escapes
        let test_invalid = |s: &str, bad_escapes: Vec<&str>| {
            let src: &str = &format!("\"{}\"", s);
            assert_matches!(parse_literal(src), Err(LiteralParseError::Parse(e)) => {
                expect_n_errors(src, &e, bad_escapes.len());
                bad_escapes.iter().for_each(|esc|
                    expect_some_error_matches(
                        src,
                        &e,
                        &ExpectedErrorMessageBuilder::error(&format!("the input `{esc}` is not a valid escape"))
                            .exactly_one_underline(src)
                            .build()
                    )
                );
            })
        };
        // invalid escape `\a`
        test_invalid("\\a", vec!["\\a"]);
        // invalid escape `\b`
        test_invalid("\\b", vec!["\\b"]);
        // invalid escape `\p`
        test_invalid("\\\\aa\\p", vec!["\\p"]);
        // invalid escape `\a` and empty unicode escape
        test_invalid(r"\aaa\u{}", vec!["\\a", "\\u{}"]);
    }
}
