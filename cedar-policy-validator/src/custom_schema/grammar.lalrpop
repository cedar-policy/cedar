use std::str::FromStr;
use std::sync::Arc;
use crate::custom_schema::err::{RawErrorRecovery, RawUserError, UserError};
use cedar_policy_core::parser::{Node, Loc, unescape::to_unescaped_string, cst::Ref};
use cedar_policy_core::ast::Id;
use smol_str::SmolStr;
use crate::custom_schema::ast::{ 
    Path, 
    EntityDecl, 
    Declaration, 
    Namespace, 
    Schema as ASchema, 
    Type as SType, 
    AttrDecl, 
    ActionDecl, 
    PR, 
    AppDecl, 
    PrimitiveType,
    PRAppDecl};
use nonempty::{NonEmpty, nonempty};
use itertools::Either;

use lalrpop_util::{ParseError, ErrorRecovery};

/// `errors` collects generated errors.
///
/// `src` is the (full) original source being parsed, which the source locations l,r index into.
grammar<'err, 's>(errors: &'err mut Vec<RawErrorRecovery<'input>>, src: &'s Arc<str>);

extern {
    type Error = RawUserError;
}

// New tokens should be reflected in the `FRIENDLY_TOKEN_NAMES` map in err.rs.
match {
    // Whitespace and comments
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`

    // keywords
    "namespace" => NAMESPACE,
    "entity" => ENTITY,
    "in" => IN,
    "type" => TYPE,
    "Set" => SET,
    "appliesTo" => APPLIESTO,
    "principal" => PRINCIPAL,
    "action" => ACTION,
    "resource" => RESOURCE,
    "context" => CONTEXT,
    "attributes" => ATTRIBUTES,
    "Long" => LONG,
    "String" => STRING,
    "Bool" => BOOL,

    // data input
    r"[_a-zA-Z][_a-zA-Z0-9]*" => IDENTIFIER,
    // The `NUMBER` token is a positive integer.
    // Negative number literals are negation operations.
    r"[0-9]+" => NUMBER,
    r#""(\\.|[^"\\])*""# => STRINGLIT,

    // other tokens
    ",", ";", ":", "::", "{", "}", "[", "]",
    "<", ">", "=", "?",

}

// PRIMTYPE := LONG | STRING | BOOL
PrimType : Node<PrimitiveType> = {
    <l:@L> LONG <r:@R> => Node::with_source_loc(PrimitiveType::Long, Loc::new(l..r, Arc::clone(src))),
    <l:@L> STRING <r:@R> => Node::with_source_loc(PrimitiveType::String, Loc::new(l..r, Arc::clone(src))),
    <l:@L> BOOL <r:@R> => Node::with_source_loc(PrimitiveType::Bool, Loc::new(l..r, Arc::clone(src))),
}

Comma<E>: Vec<E> = {
    <e:E?> => e.into_iter().collect(),
    <mut es:(<E> ",")+> <e:E> => {
        es.push(e);
        es
    },
}

// IDENT := ['_''a'-'z''A'-'Z']['_''a'-'z''A'-'Z''0'-'9']*
Ident: Node<Id> = {
    <l:@L> NAMESPACE <r:@R>
        => Node::with_source_loc("namespace".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> ENTITY <r:@R>
        => Node::with_source_loc("entity".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> IN <r:@R>
        => Node::with_source_loc("in".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> SET <r:@R>
        => Node::with_source_loc("set".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> APPLIESTO <r:@R>
        => Node::with_source_loc("appliesTo".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> PRINCIPAL <r:@R>
        => Node::with_source_loc("principal".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> ACTION <r:@R>
        => Node::with_source_loc("action".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> RESOURCE <r:@R>
        => Node::with_source_loc("resource".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> CONTEXT <r:@R>
        => Node::with_source_loc("context".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> ATTRIBUTES <r:@R>
        => Node::with_source_loc("attributes".parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
    <l:@L> <i:IDENTIFIER> <r:@R>
        => Node::with_source_loc(i.parse().unwrap(), Loc::new(l..r, Arc::clone(src))),
}

STR: Node<SmolStr> = {
    <l:@L> <s:STRINGLIT> <r:@R>
        =>? to_unescaped_string(&s[1..(s.len() - 1)]).map_or_else(|e| Err(ParseError::User {
            error: Node::with_source_loc(UserError::StringEscape(e), Loc::new(l..r, Arc::clone(src))),
        }), |v| Ok(Node::with_source_loc(v, Loc::new(l..r, Arc::clone(src))))),
}

// Name := IDENT | STR
Name: Node<SmolStr> = {
   <id: Ident> => id.map(Id::to_smolstr),
   <s: STR> => s,
}

// Path := IDENT {'::' IDENT}
#[inline]
PathInline: Path = {
    <l:@L> <i:Ident> <r:@R>
        => Path::single(i.node, Loc::new(l..r, Arc::clone(src))),
    <l:@L> <is:(<Ident> "::")+> <i:Ident> <r:@R>
        => Path::new(i.node, is.into_iter().map(|n| n.node), Loc::new(l..r, Arc::clone(src))),
}

// Idents := IDENT {',' IDENT}
Idents: Vec<Node<Id>> = {
    <i:Ident> => vec![i],
    <mut is:(<Ident> ",")+> <i:Ident> => {
        is.push(i);
        is
    },
}

// Names := Name {',' Name}
Names: Vec<Node<SmolStr>> = {
    <n:Name> => vec![n],
    <mut ns:(<Name> ",")+> <n:Name> => {
        ns.push(n);
        ns
    },
}

// SetType := 'Set' '<' Type '>'
// RecType := '{' [AttrDecls] '}'
// Type := PRIMTYPE | Path | SetType | RecType
Type: Node<SType> = {
    <p:PrimType> 
        => p.map(SType::Prim),
    <p:Path>
        => { let loc = p.loc().clone(); Node::with_source_loc(SType::Ident(p), loc) },
    <l:@L> SET "<" <t:Type> ">" <r:@R>
        => Node::with_source_loc(SType::Set(Box::new(t)), Loc::new(l..r, Arc::clone(src))),
    <l:@L> "{" <ds:AttrDecls?> "}" <r:@R>
        => Node::with_source_loc(SType::Record(ds.unwrap_or_default()), Loc::new(l..r, Arc::clone(src))),
}

// AttrDecls := Name ['?'] ':' Type [',' | ',' AttrDecls]
AttrDecls: Vec<Node<AttrDecl>> = {
    <l:@L> <name: Name> <required:"?"?> ":" <ty:Type> ","? <r:@R>
        => vec![Node::with_source_loc(AttrDecl { name, required: required.is_none(), ty}, Loc::new(l..r, Arc::clone(src)))],
    <l:@L> <name: Name> <required:"?"?> ":" <ty:Type> "," <r:@R> <mut ds: AttrDecls>
        => {ds.insert(0, Node::with_source_loc(AttrDecl { name, required: required.is_none(), ty}, Loc::new(l..r, Arc::clone(src)))); ds},
}

PrincipalOrResource: Node<PR> = {
    <l:@L> PRINCIPAL <r:@R> => Node::with_source_loc(PR::Principal, Loc::new(l..r, Arc::clone(src))),
    <l:@L> RESOURCE <r:@R> => Node::with_source_loc(PR::Resource, Loc::new(l..r, Arc::clone(src))),
}

// AppDecls := ('principal' | 'resource') ':' EntOrTyps [',' | ',' AppDecls]
//          | 'context' ':' RecType [',' | ',' AppDecls]
AppDecls: NonEmpty<Node<AppDecl>> = {
    <l:@L> <pr: PrincipalOrResource> ":" <ets:EntTypes> ","? <r:@R>
        =>? 
            NonEmpty::collect(ets.into_iter()).ok_or(ParseError::User {
                error: Node::with_source_loc(UserError::EmptyList, Loc::new(l..r, Arc::clone(src)))})
                .map(|ets| nonempty![Node::with_source_loc(AppDecl::PR(PRAppDecl { kind:pr, entity_tys: ets}), Loc::new(l..r, Arc::clone(src)))]),
    <l:@L> <pr: PrincipalOrResource> ":" <ets:EntTypes> "," <r:@R> <mut ds: AppDecls>
        =>? 
            NonEmpty::collect(ets.into_iter()).ok_or(ParseError::User {
                error: Node::with_source_loc(UserError::EmptyList, Loc::new(l..r, Arc::clone(src)))}).map(|ets| {ds.insert(0, Node::with_source_loc(AppDecl::PR(PRAppDecl { kind:pr, entity_tys: ets}), Loc::new(l..r, Arc::clone(src)))); ds}),
    <l:@L> CONTEXT ":" "{" <attrs:AttrDecls?> "}" ","? <r:@R>
        => nonempty![Node::with_source_loc(AppDecl::Context(attrs.unwrap_or_default()), Loc::new(l..r, Arc::clone(src)))],
    <l:@L> CONTEXT ":" "{" <attrs:AttrDecls?> "}" "," <r:@R> <mut ds: AppDecls>
        => {ds.insert(0, Node::with_source_loc(AppDecl::Context(attrs.unwrap_or_default()), Loc::new(l..r, Arc::clone(src)))); ds},
}

// EntType   := Path
// EntTypes  := Path {',' Path}
// EntOrTyps := EntType | '[' [EntTypes] ']'
EntTypes: Vec<Path> = {
    <et: Path>
        => vec![et],
    "[" <ets: Comma<Path>> "]"
        => ets,
}

// RefOrRefs: Vec<Ref> = {
//     <n:Ref> => vec![n],
//     "[" <ns:Comma<Ref>> "]" => ns,
// }

NameOrNames: Vec<Node<SmolStr>> = {
    <n : Name> => vec![n],
    "[" <ns:Comma<Name>> "]" => ns,
}

Path: Path = PathInline;


// // Ref := Path '::' STR | Name
// Ref: Ref = {
//     <n:Name> => Ref { ty: None, id: n},
//     // We would encounter a conflict if `Path` is used here.
//     <p:PathInline> "::" <s:STR> => Ref { ty: Some(p.0.node), id: s},
// }

// Decl := Entity | Action | TypeDecl
// Entity := 'entity' Idents ['in' EntOrTyps] [['='] '{' [AttrDecls] '}'] ';'
// AppliesTo := 'appliesTo' '{' AppDecls '}'
// Action attributes declare Cedar values instead of types.
// We temporarily make it empty until we come up a grammar for Cedar values.
// ActAttrs  := 'attributes' '{' '}'
// Action := 'action' Names ['in' (Name | '[' [Names] ']')] [AppliesTo] [ActAttrs]';'
// TypeDecl := 'type' IDENT '=' Type ';'
Decl: Node<Declaration> = {
    <l:@L> ENTITY <ets: Idents> <ps:(IN <EntTypes>)?> <ds:("="? "{" <AttrDecls?> "}")?> ";" <r:@R>
        => Node::with_source_loc(Declaration::Entity(EntityDecl { names: ets, member_of_types: ps.unwrap_or_default(), attrs: ds.map(|ds| ds.unwrap_or_default()).unwrap_or_default()}), Loc::new(l..r, Arc::clone(src))),
    <l:@L> ACTION <ns:Names> <ps:(IN <NameOrNames>)?> <ads:(APPLIESTO "{" <AppDecls> "}")?> <attrs:(ATTRIBUTES "{" "}")?>";" <r:@R>
        => Node::with_source_loc(Declaration::Action(ActionDecl { names: ns, parents: ps, app_decls: ads}), Loc::new(l..r, Arc::clone(src))),
    <l:@L> TYPE <i:Ident> "=" <t:Type> ";" <r:@R>
        => Node::with_source_loc(Declaration::Type(i, t), Loc::new(l..r, Arc::clone(src))),
}

// "named" space
// Namespace := 'namespace' Path '{' {Decl} '}'
Namespace: Node<Namespace> = {
    <l:@L> NAMESPACE <p: Path> "{" <decls: Decl*> "}" <r:@R>
        => Node::with_source_loc(Namespace { name: Some(p), decls}, Loc::new(l..r, Arc::clone(src))),
     <l:@L> <decl: Decl> <r:@R> => Node::with_source_loc(Namespace {name: None, decls: vec![decl]}, Loc::new(l..r, Arc::clone(src))),
}

// Schema := {Namespace}
pub Schema: ASchema = {
    <ns: Namespace*> => ns,
}
