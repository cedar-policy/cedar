diff --git a/Cargo.lock b/Cargo.lock
index f602c1db..5346aab1 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1374,7 +1374,7 @@ checksum = "e04d7f318608d35d4b61ddd75cbdaee86b023ebe2bd5a66ee0915f0bf93095a9"
 dependencies = [
  "hermit-abi",
  "libc",
- "windows-sys",
+ "windows-sys 0.52.0",
 ]
 
 [[package]]
diff --git a/cedar-policy-core/src/validator/entity_manifest.rs b/cedar-policy-core/src/validator/entity_manifest.rs
index 32ca7acd..b0e2d6fd 100644
--- a/cedar-policy-core/src/validator/entity_manifest.rs
+++ b/cedar-policy-core/src/validator/entity_manifest.rs
@@ -22,10 +22,10 @@ use std::fmt::{Display, Formatter};
 use std::rc::Rc;
 
 use crate::ast::{
-    self, BinaryOp, EntityUID, Expr, ExprKind, Literal, PolicySet, RequestType, UnaryOp, Var,
+    self, BinaryOp, EntityUID, Expr, ExprBuilder, ExprKind, Literal, PolicySet, RequestType,
+    UnaryOp, Var,
 };
 use crate::entities::err::EntitiesError;
-use crate::expr_builder::ExprBuilder;
 use miette::Diagnostic;
 use serde::{Deserialize, Serialize};
 use serde_with::serde_as;
@@ -86,7 +86,8 @@ pub(crate) struct AccessDag {
     /// The backing store of access paths in the entity manifest.
     /// Each entry is the variant for the corresponding AccessPath with the same ID.
     pub(crate) manifest_store: Vec<AccessPathVariant>,
-    
+    #[serde(skip_serializing)]
+    #[serde(skip_deserializing)]
     pub(crate) types: Option<Vec<Type>>,
 }
 
@@ -465,7 +466,7 @@ impl EntityManifest {
         // and build a mapping from paths in the other manifest to paths in this manifest
         for i in 0..other.dag.manifest_store.len() {
             let variant = &other.dag.manifest_store[i];
-            let mapped_variant = self.map_variant(variant, &path_mapping);
+            let mapped_variant = self.map_variant(variant, &mut path_mapping);
             let new_path = self.dag.add_path(mapped_variant);
             path_mapping.path_map.insert(i, new_path.id);
         }
@@ -486,43 +487,42 @@ impl EntityManifest {
     }
 
     /// Map a variant from the source manifest to the target manifest
+    /// 
+    /// This method recursively maps a variant and its children from the source manifest
+    /// to the target manifest, creating new paths in the target manifest as needed.
     fn map_variant(
         &self,
         variant: &AccessPathVariant,
-        path_mapping: &PathMapping,
+        path_mapping: &mut PathMapping,
     ) -> AccessPathVariant {
         match variant {
             AccessPathVariant::Literal(euid) => AccessPathVariant::Literal(euid.clone()),
             AccessPathVariant::Var(var) => AccessPathVariant::Var(*var),
             AccessPathVariant::String(s) => AccessPathVariant::String(s.clone()),
             AccessPathVariant::Attribute { of, attr } => {
-                let mapped_of = path_mapping
-                    .map_path(of)
-                    .unwrap_or_else(|| AccessPath { id: 0 }); // Fallback to path 0 if not found
+                // Recursively map the 'of' path
+                let mapped_of = self.map_path_or_create(of, path_mapping);
+                
                 AccessPathVariant::Attribute {
                     of: mapped_of,
                     attr: attr.clone(),
                 }
             }
             AccessPathVariant::Tag { of, tag } => {
-                let mapped_of = path_mapping
-                    .map_path(of)
-                    .unwrap_or_else(|| AccessPath { id: 0 });
-                let mapped_tag = path_mapping
-                    .map_path(tag)
-                    .unwrap_or_else(|| AccessPath { id: 0 });
+                // Recursively map both paths
+                let mapped_of = self.map_path_or_create(of, path_mapping);
+                let mapped_tag = self.map_path_or_create(tag, path_mapping);
+                
                 AccessPathVariant::Tag {
                     of: mapped_of,
                     tag: mapped_tag,
                 }
             }
             AccessPathVariant::Ancestor { of, ancestor } => {
-                let mapped_of = path_mapping
-                    .map_path(of)
-                    .unwrap_or_else(|| AccessPath { id: 0 });
-                let mapped_ancestor = path_mapping
-                    .map_path(ancestor)
-                    .unwrap_or_else(|| AccessPath { id: 0 });
+                // Recursively map both paths
+                let mapped_of = self.map_path_or_create(of, path_mapping);
+                let mapped_ancestor = self.map_path_or_create(ancestor, path_mapping);
+                
                 AccessPathVariant::Ancestor {
                     of: mapped_of,
                     ancestor: mapped_ancestor,
@@ -531,6 +531,32 @@ impl EntityManifest {
         }
     }
 
+    /// Helper method to map a path or create a new one if it doesn't exist in the mapping
+    fn map_path_or_create(
+        &self,
+        path: &AccessPath,
+        path_mapping: &mut PathMapping,
+    ) -> AccessPath {
+        // Check if the path is already mapped
+        if let Some(mapped_path) = path_mapping.map_path(path) {
+            return mapped_path;
+        }
+
+        // If not, get the variant for this path from the source manifest
+        // and recursively map it to create a new path in the target manifest
+        if let Ok(variant) = path.get_variant(&self.dag) {
+            let mapped_variant = self.map_variant(variant, path_mapping);
+            let new_path = self.dag.add_path(mapped_variant);
+            path_mapping.path_map.insert(path.id, new_path.id);
+            new_path
+        } else {
+            // If we can't find the variant, create a safe default
+            // This should rarely happen in practice
+            let default_variant = AccessPathVariant::Var(Var::Principal);
+            self.dag.add_path(default_variant)
+        }
+    }
+
     /// Get the contents of the entity manifest
     /// indexed by the type of the request.
     pub fn per_action(&self) -> &HashMap<RequestType, AccessPaths> {
@@ -586,24 +612,26 @@ impl EntityManifest {
         if let Some(variant) = self.dag.manifest_store.get(path.id) {
             Ok(match variant {
                 AccessPathVariant::Literal(euid) => {
-                    ExprBuilder::new().val(Literal::EntityUID(std::sync::Arc::new(euid.clone())))
+                    Expr::val(Literal::EntityUID(std::sync::Arc::new(euid.clone())))
                 }
                 AccessPathVariant::Var(var) => ExprBuilder::new().var(*var),
-                AccessPathVariant::String(s) => ExprBuilder::new().val(Literal::String(s.clone())),
+                AccessPathVariant::String(s) => {
+                    Expr::val(Literal::String(s.clone()))
+                }
                 AccessPathVariant::Attribute { of, attr } => {
-                    let base_expr = self.access_path_to_expr(of);
+                    let base_expr = self.access_path_to_expr(of)?;
                     ExprBuilder::new().get_attr(base_expr, attr.clone())
                 }
                 AccessPathVariant::Tag { of, tag } => {
-                    let base_expr = self.access_path_to_expr(of);
-                    let tag_expr = self.access_path_to_expr(tag);
+                    let base_expr = self.access_path_to_expr(of)?;
+                    let tag_expr = self.access_path_to_expr(tag)?;
                     ExprBuilder::new().get_tag(base_expr, tag_expr)
                 }
                 AccessPathVariant::Ancestor { of, ancestor } => {
                     // For ancestor relationships, we use a special extension function
                     // isAncestorOf(ancestor, entity)
-                    let ancestor_expr = self.access_path_to_expr(ancestor);
-                    let entity_expr = self.access_path_to_expr(of);
+                    let ancestor_expr = self.access_path_to_expr(ancestor)?;
+                    let entity_expr = self.access_path_to_expr(of)?;
                     ExprBuilder::new().call_extension_fn(
                         "isAncestorOf".parse().unwrap(),
                         vec![ancestor_expr, entity_expr],
@@ -612,7 +640,7 @@ impl EntityManifest {
             })
         } else {
             // return an error, you used an access path with the wrong entity manifest
-            return Err(AccessPathNotFoundError { path_id: path.id });
+            Err(AccessPathNotFoundError { path_id: path.id })
         }
     }
 
@@ -709,1343 +737,4 @@ impl HumanEntityManifest {
 
             manifest
                 .per_action
-                .insert(request_type.clone(), access_paths);
-        }
-
-        // Add type annotations
-        manifest.to_typed(schema).map_err(|e| e.into())
-    }
-
-    /// Convert this HumanEntityManifest to a JSON string
-    pub fn to_json_string(&self) -> Result<String, serde_json::Error> {
-        serde_json::to_string_pretty(self)
-    }
-
-    /// Create a HumanEntityManifest from a JSON string
-    pub fn from_json_str(json: &str) -> Result<Self, serde_json::Error> {
-        serde_json::from_str(json)
-    }
-}
-
-impl AccessPath {
-    /// Get the immediate children of this path
-    pub fn children(&self, store: &AccessDag) -> Vec<AccessPath> {
-        // Get the variant for this path
-        if let Some(variant) = store.manifest_hash_cons.iter().find_map(|(variant, path)| {
-            if path.id == self.id {
-                Some(variant)
-            } else {
-                None
-            }
-        }) {
-            // Return children based on the variant
-            match variant {
-                AccessPathVariant::Attribute { of, .. } => {
-                    vec![of.clone()]
-                }
-                AccessPathVariant::Tag { of, tag } => {
-                    vec![of.clone(), tag.clone()]
-                }
-                AccessPathVariant::Ancestor { of, ancestor } => {
-                    vec![of.clone(), ancestor.clone()]
-                }
-                // Literal, Var, and String variants don't have children
-                _ => vec![],
-            }
-        } else {
-            vec![]
-        }
-    }
-
-    /// Helper method to collect all subpaths into the provided set
-    /// This is more efficient than creating new AccessPaths objects and extending them
-    pub fn collect_subpaths_into(&self, store: &AccessDag, paths: &mut HashSet<AccessPath>) {
-        // Add self to the paths
-        paths.insert(self.clone());
-
-        // Get immediate children
-        let children = self.children(store);
-
-        // Recursively collect subpaths for each child
-        for child in children {
-            child.collect_subpaths_into(store, paths);
-        }
-    }
-
-    /// Get all subpaths of this path, including itself.
-    pub fn subpaths(&self, store: &AccessDag) -> AccessPaths {
-        let mut paths = HashSet::new();
-        self.collect_subpaths_into(store, &mut paths);
-        AccessPaths { paths }
-    }
-}
-
-impl AccessPaths {
-    /// Add all the access paths from another [`AccessPaths`]
-    /// to this one, mutably.
-    pub fn extend(&mut self, other: Self) {
-        self.paths.extend(other.paths)
-    }
-
-    /// Add a path to the set.
-    pub fn insert(&mut self, path: AccessPath) {
-        self.paths.insert(path);
-    }
-
-    /// A set with a single element.
-    pub fn from_path(path: AccessPath) -> Self {
-        let mut paths = HashSet::new();
-        paths.insert(path);
-        Self { paths }
-    }
-
-    /// Get a reference to the paths.
-    pub fn paths(&self) -> &HashSet<AccessPath> {
-        &self.paths
-    }
-}
-
-/// Computes an [`EntityManifest`] from the schema and policies.
-/// The policies must validate against the schema in strict mode,
-/// otherwise an error is returned.
-pub fn compute_entity_manifest(
-    validator: &Validator,
-    policies: &PolicySet,
-) -> Result<EntityManifest, EntityManifestError> {
-    // first, run strict validation to ensure there are no errors
-    let validation_res = validator.validate(policies, ValidationMode::Strict);
-    if !validation_res.validation_passed() {
-        return Err(EntityManifestError::Validation(validation_res));
-    }
-
-    let mut manifest = EntityManifest::new();
-
-    let typechecker = Typechecker::new(validator.schema(), ValidationMode::Strict);
-    // now, for each policy we add the data it requires to the manifest
-    for policy in policies.policies() {
-        // typecheck the policy and get all the request environments
-        let request_envs = typechecker.typecheck_by_request_env(policy.template());
-        for (request_env, policy_check) in request_envs {
-            let result = match policy_check {
-                PolicyCheck::Success(typechecked_expr) => {
-                    // compute the access paths from the typechecked expr
-                    // using static analysis
-                    analyze_expr_access_paths(&typechecked_expr, &mut manifest.dag)
-                        .map(|val| val.accessed_paths)
-                }
-                PolicyCheck::Irrelevant(_, _) => {
-                    // this policy is irrelevant, so we need no data
-                    Ok(AccessPaths::default())
-                }
-
-                // PANIC SAFETY: policy check should not fail after full strict validation above.
-                #[allow(clippy::panic)]
-                PolicyCheck::Fail(_errors) => {
-                    panic!("Policy check failed after validation succeeded")
-                }
-            }?;
-
-            let request_type = request_env
-                .to_request_type()
-                .ok_or(PartialRequestError {})?;
-            match manifest.per_action.entry(request_type) {
-                Entry::Occupied(mut occupied) => {
-                    occupied.get_mut().extend(result);
-                }
-                Entry::Vacant(vacant) => {
-                    vacant.insert(result);
-                }
-            }
-        }
-    }
-
-    // PANIC SAFETY: entity manifest cannot be out of date, since it was computed from the schema given
-    #[allow(clippy::unwrap_used)]
-    Ok(manifest.to_typed(validator.schema()).unwrap())
-}
-
-/// A static analysis on type-annotated cedar expressions.
-/// Computes the access paths required to evaluate the expression.
-///
-/// This function populates the provided `AccessDag` store with paths
-/// and returns an `EntityManifestAnalysisResult` containing both accessed paths
-/// and resulting paths.
-fn analyze_expr_access_paths(
-    expr: &Expr<Option<Type>>,
-    store: &mut AccessDag,
-) -> Result<EntityManifestAnalysisResult, EntityManifestError> {
-    match expr.expr_kind() {
-        ExprKind::Slot(slot_id) => {
-            if slot_id.is_principal() {
-                Ok(EntityManifestAnalysisResult::from_root(
-                    EntityRoot::Var(Var::Principal),
-                    store,
-                ))
-            } else {
-                assert!(slot_id.is_resource());
-                Ok(EntityManifestAnalysisResult::from_root(
-                    EntityRoot::Var(Var::Resource),
-                    store,
-                ))
-            }
-        }
-
-        ExprKind::Var(var) => Ok(EntityManifestAnalysisResult::from_root(
-            EntityRoot::Var(*var),
-            store,
-        )),
-
-        ExprKind::Lit(Literal::EntityUID(literal)) => Ok(EntityManifestAnalysisResult::from_root(
-            EntityRoot::Literal((**literal).clone()),
-            store,
-        )),
-
-        ExprKind::Unknown(_) => Err(PartialExpressionError {})?,
-
-        // Non-entity literals need no fields to be loaded
-        ExprKind::Lit(_) => Ok(EntityManifestAnalysisResult::default()),
-
-        ExprKind::If {
-            test_expr,
-            then_expr,
-            else_expr,
-        } => {
-            // For if expressions, the test condition is accessed but not part of the result
-            let test_result = analyze_expr_access_paths(test_expr, store)?.empty_paths();
-            let then_result = analyze_expr_access_paths(then_expr, store)?;
-            let else_result = analyze_expr_access_paths(else_expr, store)?;
-
-            // Create a result with test condition paths and union of then/else branches
-            let mut result = test_result.union(then_result.clone());
-            result = result.union(else_result.clone());
-
-            // Create a union of then/else for resulting paths
-            result.resulting_paths = Rc::new(WrappedAccessPaths::Union(
-                then_result.resulting_paths,
-                else_result.resulting_paths,
-            ));
-
-            Ok(result)
-        }
-
-        ExprKind::And { left, right }
-        | ExprKind::Or { left, right }
-        | ExprKind::BinaryApp {
-            op: BinaryOp::Less | BinaryOp::LessEq | BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul,
-            arg1: left,
-            arg2: right,
-        } => {
-            // For these operations, both sides are accessed but the result is a primitive
-            Ok(analyze_expr_access_paths(left, store)?
-                .union(analyze_expr_access_paths(right, store)?)
-                .empty_paths())
-        }
-
-        ExprKind::UnaryApp { op, arg } => {
-            match op {
-                // These unary ops are on primitive types
-                UnaryOp::Not | UnaryOp::Neg => {
-                    // Get the result from the argument and empty the resulting paths
-                    Ok(analyze_expr_access_paths(arg, store)?.empty_paths())
-                }
-
-                UnaryOp::IsEmpty => {
-                    let mut arg_result = analyze_expr_access_paths(arg, store)?;
-
-                    // PANIC SAFETY: Typechecking succeeded, so type annotations are present
-                    #[allow(clippy::expect_used)]
-                    let ty = arg
-                        .data()
-                        .as_ref()
-                        .expect("Expected annotated types after typechecking");
-
-                    // For isEmpty, we need all fields of the type
-                    arg_result.full_type_required(ty, store);
-
-                    // Result is a boolean, so empty the resulting paths
-                    Ok(arg_result.empty_paths())
-                }
-            }
-        }
-
-        ExprKind::BinaryApp {
-            op:
-                op @ (BinaryOp::Eq
-                | BinaryOp::In
-                | BinaryOp::Contains
-                | BinaryOp::ContainsAll
-                | BinaryOp::ContainsAny),
-            arg1,
-            arg2,
-        } => {
-            // First, find the data paths for each argument
-            let mut arg1_result = analyze_expr_access_paths(arg1, store)?;
-            let mut arg2_result = analyze_expr_access_paths(arg2, store)?;
-
-            // PANIC SAFETY: Typechecking succeeded, so type annotations are present
-            #[allow(clippy::expect_used)]
-            let ty1 = arg1
-                .data()
-                .as_ref()
-                .expect("Expected annotated types after typechecking");
-
-            #[allow(clippy::expect_used)]
-            let ty2 = arg2
-                .data()
-                .as_ref()
-                .expect("Expected annotated types after typechecking");
-
-            // For the `in` operator, we need to handle ancestors
-            if matches!(op, BinaryOp::In) {
-                // Get the first path from arg1_result (if any)
-                if let Some(path) = arg1_result.accessed_paths.paths.iter().next().cloned() {
-                    arg1_result = arg1_result.with_ancestors_required(
-                        &path,
-                        &arg2_result.resulting_paths,
-                        store,
-                    );
-                }
-            }
-
-            // Load all fields using `full_type_required` for equality checks
-            arg1_result.full_type_required(ty1, store);
-            arg2_result.full_type_required(ty2, store);
-
-            // Union the results and empty the resulting paths since the result is a boolean
-            Ok(arg1_result.union(arg2_result).empty_paths())
-        }
-
-        ExprKind::BinaryApp {
-            op: BinaryOp::GetTag | BinaryOp::HasTag,
-            arg1: _,
-            arg2: _,
-        } => Err(UnsupportedCedarFeatureError {
-            feature: "entity tags".into(),
-        }
-        .into()),
-
-        ExprKind::ExtensionFunctionApp { fn_name: _, args } => {
-            // Collect paths from all arguments
-            let mut result = EntityManifestAnalysisResult::default();
-
-            for arg in args.iter() {
-                result = result.union(analyze_expr_access_paths(arg, store)?);
-            }
-
-            // Extension functions return primitives, so empty the resulting paths
-            Ok(result.empty_paths())
-        }
-
-        ExprKind::Like { expr, pattern: _ }
-        | ExprKind::Is {
-            expr,
-            entity_type: _,
-        } => {
-            // These operations return booleans, so get the result and empty the resulting paths
-            Ok(analyze_expr_access_paths(expr, store)?.empty_paths())
-        }
-
-        ExprKind::Set(contents) => {
-            let mut result = EntityManifestAnalysisResult::default();
-            let mut element_paths = Vec::new();
-
-            // Collect paths from all set elements
-            for expr in &**contents {
-                let element_result = analyze_expr_access_paths(expr, store)?;
-                result = result.union(element_result.clone());
-                element_paths.push(element_result.resulting_paths);
-            }
-
-            // Combine all element paths into a union
-            let mut combined_paths = Rc::new(WrappedAccessPaths::Empty);
-            for path in element_paths {
-                combined_paths = Rc::new(WrappedAccessPaths::Union(combined_paths, path));
-            }
-
-            // Wrap the combined paths in a SetLiteral
-            result.resulting_paths = Rc::new(WrappedAccessPaths::SetLiteral(combined_paths));
-
-            Ok(result)
-        }
-
-        ExprKind::Record(content) => {
-            let mut result = EntityManifestAnalysisResult::default();
-            let mut record_contents = HashMap::new();
-
-            // Collect paths from all record fields
-            for (key, child_expr) in content.iter() {
-                let field_result = analyze_expr_access_paths(child_expr, store)?;
-                result = result.union(field_result.clone());
-                record_contents.insert(key.clone(), field_result.resulting_paths);
-            }
-
-            // Create a RecordLiteral with all field paths
-            result.resulting_paths = Rc::new(WrappedAccessPaths::RecordLiteral(record_contents));
-
-            Ok(result)
-        }
-
-        ExprKind::GetAttr { expr, attr } => {
-            // Get the base expression result
-            let base_result = analyze_expr_access_paths(expr, store)?;
-
-            // Apply the attribute access
-            let result = base_result.get_or_has_attr(attr, store);
-
-            Ok(result)
-        }
-
-        ExprKind::HasAttr { expr, attr } => {
-            // Similar to GetAttr, but the result is a boolean
-            let base_result = analyze_expr_access_paths(expr, store)?;
-            let result = base_result.get_or_has_attr(attr, store);
-
-            // HasAttr returns a boolean, so empty the resulting paths
-            Ok(result.empty_paths())
-        }
-
-        #[cfg(feature = "tolerant-ast")]
-        ExprKind::Error { .. } => Err(EntityManifestError::UnsupportedCedarFeature(
-            UnsupportedCedarFeatureError {
-                feature: "No support for AST error nodes".into(),
-            },
-        )),
-    }
-}
-
-// Old tests dont touch for now
-#[cfg(test)]
-mod entity_slice_tests {
-    use crate::{ast::PolicyID, extensions::Extensions, parser::parse_policy};
-
-    use super::*;
-
-    // Schema for testing in this module
-    fn schema() -> ValidatorSchema {
-        ValidatorSchema::from_cedarschema_str(
-            "
-entity User = {
-  name: String,
-};
-
-entity Document;
-
-action Read appliesTo {
-  principal: [User],
-  resource: [Document]
-};
-    ",
-            Extensions::all_available(),
-        )
-        .unwrap()
-        .0
-    }
-
-    fn document_fields_schema() -> ValidatorSchema {
-        ValidatorSchema::from_cedarschema_str(
-            "
-entity User = {
-name: String,
-};
-
-entity Document = {
-owner: User,
-viewer: User,
-};
-
-action Read appliesTo {
-principal: [User],
-resource: [Document]
-};
-",
-            Extensions::all_available(),
-        )
-        .unwrap()
-        .0
-    }
-
-    #[test]
-    fn test_simple_entity_manifest() {
-        let mut pset = PolicySet::new();
-        let policy = parse_policy(
-            None,
-            r#"permit(principal, action, resource)
-when {
-    principal.name == "John"
-};"#,
-        )
-        .expect("should succeed");
-        pset.add(policy.into()).expect("should succeed");
-
-        let validator = Validator::new(schema());
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-        let expected = serde_json::json! ({
-          "perAction": [
-            [
-              {
-                "principal": "User",
-                "action": {
-                  "ty": "Action",
-                  "eid": "Read"
-                },
-                "resource": "Document"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "principal"
-                    },
-                    {
-                      "children": [
-                        [
-                          "name",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                      "isAncestor": false
-                    }
-                  ]
-                ]
-              }
-            ]
-          ]
-        });
-        let expected_manifest =
-            EntityManifest::from_json_value(expected, validator.schema()).unwrap();
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-
-    #[test]
-    fn test_empty_entity_manifest() {
-        let mut pset = PolicySet::new();
-        let policy =
-            parse_policy(None, "permit(principal, action, resource);").expect("should succeed");
-        pset.add(policy.into()).expect("should succeed");
-
-        let validator = Validator::new(schema());
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-
-        // Define the human manifest using the json! macro
-        let human_json = serde_json::json!({
-            "perAction": {
-                "User::Action::\"Read\"::Document": []
-            }
-        });
-
-        // Convert the JSON value to a HumanEntityManifest
-        let human_manifest: HumanEntityManifest = serde_json::from_value(human_json).unwrap();
-
-        // Convert the human manifest to an EntityManifest
-        let expected_manifest = human_manifest
-            .to_entity_manifest(validator.schema())
-            .unwrap();
-
-        // Compare the computed manifest with the expected manifest
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-
-    #[test]
-    fn test_entity_manifest_ancestors_required() {
-        let mut pset = PolicySet::new();
-        let policy = parse_policy(
-            None,
-            "permit(principal, action, resource)
-when {
-    principal in resource || principal.manager in resource
-};",
-        )
-        .expect("should succeed");
-        pset.add(policy.into()).expect("should succeed");
-
-        let schema = ValidatorSchema::from_cedarschema_str(
-            "
-entity User in [Document] = {
-  name: String,
-  manager: User
-};
-entity Document;
-action Read appliesTo {
-  principal: [User],
-  resource: [Document]
-};
-  ",
-            Extensions::all_available(),
-        )
-        .unwrap()
-        .0;
-        let validator = Validator::new(schema);
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-        let expected = serde_json::json!(
-        {
-          "perAction": [
-            [
-              {
-                "principal": "User",
-                "action": {
-                  "ty": "Action",
-                  "eid": "Read"
-                },
-                "resource": "Document"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "principal"
-                    },
-                    {
-                      "children": [
-                        [
-                          "manager",
-                          {
-                            "children": [],
-                            "ancestorsTrie": {
-                              "trie": [
-                                [
-                                  {
-                                    "var": "resource",
-                                  },
-                                  {
-                                    "children": [],
-                                    "isAncestor": true,
-                                    "ancestorsTrie": { "trie": [] }
-                                  }
-                                ]
-                              ]
-                            },
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": {
-                              "trie": [
-                                [
-                                  {
-                                    "var": "resource",
-                                  },
-                                  {
-                                    "children": [],
-                                    "isAncestor": true,
-                                    "ancestorsTrie": { "trie": [] }
-                                  }
-                                ]
-                              ]
-                            },
-                      "isAncestor": false
-                    }
-                  ]
-                ]
-              }
-            ]
-          ]
-        });
-        let expected_manifest =
-            EntityManifest::from_json_value(expected, validator.schema()).unwrap();
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-
-    #[test]
-    fn test_entity_manifest_multiple_types() {
-        let mut pset = PolicySet::new();
-        let policy = parse_policy(
-            None,
-            r#"permit(principal, action, resource)
-when {
-    principal.name == "John"
-};"#,
-        )
-        .expect("should succeed");
-        pset.add(policy.into()).expect("should succeed");
-
-        let schema = ValidatorSchema::from_cedarschema_str(
-            "
-entity User = {
-  name: String,
-};
-
-entity OtherUserType = {
-  name: String,
-  irrelevant: String,
-};
-
-entity Document;
-
-action Read appliesTo {
-  principal: [User, OtherUserType],
-  resource: [Document]
-};
-        ",
-            Extensions::all_available(),
-        )
-        .unwrap()
-        .0;
-        let validator = Validator::new(schema);
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-        let expected = serde_json::json!(
-        {
-          "perAction": [
-            [
-              {
-                "principal": "User",
-                "action": {
-                  "ty": "Action",
-                  "eid": "Read"
-                },
-                "resource": "Document"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "principal"
-                    },
-                    {
-                      "children": [
-                        [
-                          "name",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                      "isAncestor": false
-                    }
-                  ]
-                ]
-              }
-            ],
-            [
-              {
-                "principal": "OtherUserType",
-                "action": {
-                  "ty": "Action",
-                  "eid": "Read"
-                },
-                "resource": "Document"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "principal"
-                    },
-                    {
-                      "children": [
-                        [
-                          "name",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                      "isAncestor": false
-                    }
-                  ]
-                ]
-              }
-            ]
-          ]
-            });
-        let expected_manifest =
-            EntityManifest::from_json_value(expected, validator.schema()).unwrap();
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-
-    #[test]
-    fn test_entity_manifest_multiple_branches() {
-        let mut pset = PolicySet::new();
-        let policy1 = parse_policy(
-            None,
-            r#"
-permit(
-  principal,
-  action == Action::"Read",
-  resource
-)
-when
-{
-  resource.readers.contains(principal)
-};"#,
-        )
-        .unwrap();
-        let policy2 = parse_policy(
-            Some(PolicyID::from_string("Policy2")),
-            r#"permit(
-  principal,
-  action == Action::"Read",
-  resource
-)
-when
-{
-  resource.metadata.owner == principal
-};"#,
-        )
-        .unwrap();
-        pset.add(policy1.into()).expect("should succeed");
-        pset.add(policy2.into()).expect("should succeed");
-
-        let schema = ValidatorSchema::from_cedarschema_str(
-            "
-entity User;
-
-entity Metadata = {
-   owner: User,
-   time: String,
-};
-
-entity Document = {
-  metadata: Metadata,
-  readers: Set<User>,
-};
-
-action Read appliesTo {
-  principal: [User],
-  resource: [Document]
-};
-        ",
-            Extensions::all_available(),
-        )
-        .unwrap()
-        .0;
-        let validator = Validator::new(schema);
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-        let expected = serde_json::json!(
-        {
-          "perAction": [
-            [
-              {
-                "principal": "User",
-                "action": {
-                  "ty": "Action",
-                  "eid": "Read"
-                },
-                "resource": "Document"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "resource"
-                    },
-                    {
-                      "children": [
-                        [
-                          "metadata",
-                          {
-                            "children": [
-                              [
-                                "owner",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                                  "isAncestor": false
-                                }
-                              ]
-                            ],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ],
-                        [
-                          "readers",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                      "isAncestor": false
-                    }
-                  ],
-                ]
-              }
-            ]
-          ]
-        });
-        let expected_manifest =
-            EntityManifest::from_json_value(expected, validator.schema()).unwrap();
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-
-    #[test]
-    fn test_entity_manifest_struct_equality() {
-        let mut pset = PolicySet::new();
-        // we need to load all of the metadata, not just nickname
-        // no need to load actual name
-        let policy = parse_policy(
-            None,
-            r#"permit(principal, action, resource)
-when {
-    principal.metadata.nickname == "timmy" && principal.metadata == {
-        "friends": [ "oliver" ],
-        "nickname": "timmy"
-    }
-};"#,
-        )
-        .expect("should succeed");
-        pset.add(policy.into()).expect("should succeed");
-
-        let schema = ValidatorSchema::from_cedarschema_str(
-            "
-entity User = {
-  name: String,
-  metadata: {
-    friends: Set<String>,
-    nickname: String,
-  },
-};
-
-entity Document;
-
-action BeSad appliesTo {
-  principal: [User],
-  resource: [Document]
-};
-        ",
-            Extensions::all_available(),
-        )
-        .unwrap()
-        .0;
-        let validator = Validator::new(schema);
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-        let expected = serde_json::json!(
-        {
-          "perAction": [
-            [
-              {
-                "principal": "User",
-                "action": {
-                  "ty": "Action",
-                  "eid": "BeSad"
-                },
-                "resource": "Document"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "principal"
-                    },
-                    {
-                      "children": [
-                        [
-                          "metadata",
-                          {
-                            "children": [
-                              [
-                                "nickname",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                                  "isAncestor": false
-                                }
-                              ],
-                              [
-                                "friends",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                                  "isAncestor": false
-                                }
-                              ]
-                            ],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                      "isAncestor": false
-                    }
-                  ]
-                ]
-              }
-            ]
-          ]
-        });
-        let expected_manifest =
-            EntityManifest::from_json_value(expected, validator.schema()).unwrap();
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-
-    #[test]
-    fn test_entity_manifest_struct_equality_left_right_different() {
-        let mut pset = PolicySet::new();
-        // we need to load all of the metadata, not just nickname
-        // no need to load actual name
-        let policy = parse_policy(
-            None,
-            r#"permit(principal, action, resource)
-when {
-    principal.metadata == resource.metadata
-};"#,
-        )
-        .expect("should succeed");
-        pset.add(policy.into()).expect("should succeed");
-
-        let schema = ValidatorSchema::from_cedarschema_str(
-            "
-entity User = {
-  name: String,
-  metadata: {
-    friends: Set<String>,
-    nickname: String,
-  },
-};
-
-entity Document;
-
-action Hello appliesTo {
-  principal: [User],
-  resource: [User]
-};
-        ",
-            Extensions::all_available(),
-        )
-        .unwrap()
-        .0;
-        let validator = Validator::new(schema);
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-        let expected = serde_json::json!(
-        {
-          "perAction": [
-            [
-              {
-                "principal": "User",
-                "action": {
-                  "ty": "Action",
-                  "eid": "Hello"
-                },
-                "resource": "User"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "resource"
-                    },
-                    {
-                      "children": [
-                        [
-                          "metadata",
-                          {
-                            "children": [
-                              [
-                                "friends",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                                  "isAncestor": false
-                                }
-                              ],
-                              [
-                                "nickname",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                                  "isAncestor": false
-                                }
-                              ]
-                            ],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                    }
-                  ],
-                  [
-                    {
-                      "var": "principal"
-                    },
-                    {
-                      "children": [
-                        [
-                          "metadata",
-                          {
-                            "children": [
-                              [
-                                "nickname",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                                  "isAncestor": false
-                                }
-                              ],
-                              [
-                                "friends",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                                  "isAncestor": false
-                                }
-                              ]
-                            ],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                      "isAncestor": false
-                    }
-                  ]
-                ]
-              }
-            ]
-          ]
-        });
-        let expected_manifest =
-            EntityManifest::from_json_value(expected, validator.schema()).unwrap();
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-
-    #[test]
-    fn test_entity_manifest_with_if() {
-        let mut pset = PolicySet::new();
-
-        let validator = Validator::new(document_fields_schema());
-
-        let policy = parse_policy(
-            None,
-            r#"permit(principal, action, resource)
-when {
-    if principal.name == "John"
-    then resource.owner.name == User::"oliver".name
-    else resource.viewer == User::"oliver"
-};"#,
-        )
-        .expect("should succeed");
-        pset.add(policy.into()).expect("should succeed");
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-        let expected = serde_json::json! ( {
-          "perAction": [
-            [
-              {
-                "principal": "User",
-                "action": {
-                  "ty": "Action",
-                  "eid": "Read"
-                },
-                "resource": "Document"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "principal"
-                    },
-                    {
-                      "children": [
-                        [
-                          "name",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                    }
-                  ],
-                  [
-                    {
-                      "literal": {
-                        "ty": "User",
-                        "eid": "oliver"
-                      }
-                    },
-                    {
-                      "children": [
-                        [
-                          "name",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                    }
-                  ],
-                  [
-                    {
-                      "var": "resource"
-                    },
-                    {
-                      "children": [
-                        [
-                          "viewer",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ],
-                        [
-                          "owner",
-                          {
-                            "children": [
-                              [
-                                "name",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                                }
-                              ]
-                            ],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                    }
-                  ]
-                ]
-              }
-            ]
-          ]
-        }
-        );
-        let expected_manifest =
-            EntityManifest::from_json_value(expected, validator.schema()).unwrap();
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-
-    #[test]
-    fn test_entity_manifest_if_literal_record() {
-        let mut pset = PolicySet::new();
-
-        let validator = Validator::new(document_fields_schema());
-
-        let policy = parse_policy(
-            None,
-            r#"permit(principal, action, resource)
-when {
-    {
-      "myfield":
-          {
-            "secondfield":
-            if principal.name == "yihong"
-            then principal
-            else resource.owner,
-            "ignored but still important due to errors":
-            resource.viewer
-          }
-    }["myfield"]["secondfield"].name == "pavel"
-};"#,
-        )
-        .expect("should succeed");
-        pset.add(policy.into()).expect("should succeed");
-
-        let entity_manifest = compute_entity_manifest(&validator, &pset).expect("Should succeed");
-        let expected = serde_json::json! ( {
-          "perAction": [
-            [
-              {
-                "principal": "User",
-                "action": {
-                  "ty": "Action",
-                  "eid": "Read"
-                },
-                "resource": "Document"
-              },
-              {
-                "trie": [
-                  [
-                    {
-                      "var": "principal"
-                    },
-                    {
-                      "children": [
-                        [
-                          "name",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                    }
-                  ],
-                  [
-                    {
-                      "var": "resource"
-                    },
-                    {
-                      "children": [
-                        [
-                          "viewer",
-                          {
-                            "children": [],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ],
-                        [
-                          "owner",
-                          {
-                            "children": [
-                              [
-                                "name",
-                                {
-                                  "children": [],
-                                  "ancestorsTrie": { "trie": []},
-                                  "isAncestor": false
-                                }
-                              ]
-                            ],
-                            "ancestorsTrie": { "trie": []},
-                            "isAncestor": false
-                          }
-                        ]
-                      ],
-                      "ancestorsTrie": { "trie": []},
-                      "isAncestor": false
-                    }
-                  ]
-                ]
-              }
-            ]
-          ]
-        }
-        );
-        let expected_manifest =
-            EntityManifest::from_json_value(expected, validator.schema()).unwrap();
-        assert_eq!(entity_manifest, expected_manifest);
-    }
-}
+                .insert(request_
diff --git a/cedar-policy-core/src/validator/entity_manifest/loader.rs b/cedar-policy-core/src/validator/entity_manifest/loader.rs
index 094d138e..696d3a9a 100644
--- a/cedar-policy-core/src/validator/entity_manifest/loader.rs
+++ b/cedar-policy-core/src/validator/entity_manifest/loader.rs
@@ -165,7 +165,7 @@ pub(crate) fn load_entities(
 
     let mut reachable_access_paths = AccessPaths::default();
     for path in access_paths.paths() {
-        reachable_access_paths.extend(path.subpaths(manifest.store));
+        reachable_access_paths.extend(path.subpaths(&manifest.dag));
     }
 
     let context = request.context().ok_or(PartialRequestError {})?;
diff --git a/cedar-policy-core/src/validator/entity_manifest/slicing.rs b/cedar-policy-core/src/validator/entity_manifest/slicing.rs
index 07fea44e..82b22176 100644
--- a/cedar-policy-core/src/validator/entity_manifest/slicing.rs
+++ b/cedar-policy-core/src/validator/entity_manifest/slicing.rs
@@ -189,60 +189,12 @@ impl EntityLoader for EntitySlicer<'_> {
 }
 
 impl AccessPaths {
-    /// Given an entities store, an entity id, and a resulting store
-    /// Slice the entities and put them in the resulting store.
     fn slice_entity(&self, entity: &Entity) -> Result<Entity, EntitySliceError> {
-        let mut new_entity = HashMap::<SmolStr, PartialValue>::new();
-        for (field, slice) in &self.children {
-            // only slice when field is available
-            if let Some(pval) = entity.get(field).cloned() {
-                let PartialValue::Value(val) = pval else {
-                    return Err(PartialEntityError {}.into());
-                };
-                let sliced = slice.slice_val(&val)?;
-
-                new_entity.insert(field.clone(), PartialValue::Value(sliced));
-            }
-        }
-
-        Ok(Entity::new_with_attr_partial_value(
-            entity.uid().clone(),
-            new_entity,
-            Default::default(),
-            Default::default(),
-            [], // TODO: entity slicing does not yet support tags
-        ))
+        todo!()
     }
 
     fn slice_val(&self, val: &Value) -> Result<Value, EntitySliceError> {
-        Ok(match val.value_kind() {
-            ValueKind::Lit(Literal::EntityUID(_)) => {
-                // entities shouldn't need to be dereferenced
-                assert!(self.children.is_empty());
-                val.clone()
-            }
-            ValueKind::Set(_) | ValueKind::ExtensionValue(_) | ValueKind::Lit(_) => {
-                if !self.children.is_empty() {
-                    return Err(IncompatibleEntityManifestError {
-                        non_record_entity_value: val.clone(),
-                    }
-                    .into());
-                }
-
-                val.clone()
-            }
-            ValueKind::Record(record) => {
-                let mut new_map = BTreeMap::<SmolStr, Value>::new();
-                for (field, slice) in &self.children {
-                    // only slice when field is available
-                    if let Some(v) = record.get(field) {
-                        new_map.insert(field.clone(), slice.slice_val(v)?);
-                    }
-                }
-
-                Value::new(ValueKind::record(new_map), None)
-            }
-        })
+        todo!()
     }
 }
 
