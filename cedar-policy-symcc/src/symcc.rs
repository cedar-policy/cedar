/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! This module is as straightforward a translation as possible of
//! <https://github.com/cedar-policy/cedar-spec/blob/main/cedar-lean/Cedar/SymCC.lean>.

mod authorizer;
mod bitvec;
mod compiler;
mod concretize;
mod decoder;
mod encoder;
mod enforcer;
mod entity_tag;
mod env;
mod ext;
mod extension_types;
mod extfun;
mod factory;
mod function;
mod interpretation;
mod op;
pub mod result;
mod smtlib_script;
pub mod solver;
mod tags;
mod term;
mod term_type;
mod type_abbrevs;
mod verifier;

use cedar_policy::Schema;
use decoder::{parse_sexpr, DecodeError, IdMaps};
use env::to_validator_request_env;
// public exports
pub use env::{Environment, SymEnv};
pub use interpretation::Interpretation;
pub use smtlib_script::SmtLibScript;

use cedar_policy_core::ast::{ExprBuilder, Policy, PolicySet};
use cedar_policy_core::validator::{
    typecheck::Typechecker, types::RequestEnv, ValidationError, ValidationMode,
};
use solver::{Decision, Solver};
use thiserror::Error;
use verifier::Asserts;

use encoder::Encoder;
pub use verifier::{
    verify_always_allows, verify_always_denies, verify_disjoint, verify_equivalent, verify_implies,
    verify_never_errors,
};

use crate::symcc::concretize::ConcretizeError;
pub use crate::symcc::concretize::Env;

#[allow(clippy::enum_variant_names)]
#[derive(Debug, Error)]
pub enum Error {
    #[error("Action not found in Schema: {action}")]
    ActionNotInSchema { action: String },
    #[error(transparent)]
    SymCC(#[from] result::Error),
    #[error("Failed to construct encoder: {err}")]
    EncoderConstruction { err: anyhow::Error },
    #[error("Failed to encode terms: {err}")]
    Encoding { err: anyhow::Error },
    #[error(transparent)]
    Solver(#[from] solver::Error),
    #[error("Solver returned unknown")]
    SolverUnknown,
    /// Policy is not well-typed.
    #[error("Policy is not well typed.")]
    PolicyNotWellTyped { errs: Vec<ValidationError> },
    #[error("Failed to decode model: {0}")]
    DecodeModel(#[from] DecodeError),
    #[error("Failed to concretize interpretation: {0}")]
    ConcretizeError(#[from] ConcretizeError),
}
pub type Result<T> = std::result::Result<T, Error>;

/// Corresponds to the `SolverM` monad in Lean
#[derive(Debug, Clone)]
pub struct SymCompiler<S> {
    solver: S,
}

impl<S> SymCompiler<S> {
    pub fn new(solver: S) -> Self {
        Self { solver }
    }

    pub fn solver(&self) -> &S {
        &self.solver
    }

    pub fn solver_mut(&mut self) -> &mut S {
        &mut self.solver
    }
}

impl<S: Solver> SymCompiler<S> {
    /// Given a verification condition generator `vc`,
    /// calls the SMT solver on an SMTLib encoding of the conditions generated by `vc`
    /// and returns `true` if the result is unsatisfiable. The function `vc` is
    /// expected to produce a list of terms type `Bool` that are well-formed
    /// with respect to the `symenv`.
    pub async fn check_unsat(
        &mut self,
        vc: impl FnOnce(&SymEnv) -> std::result::Result<Asserts, result::Error>,
        symenv: &SymEnv,
    ) -> Result<bool> {
        let asserts = vc(symenv)?;
        if asserts.iter().any(|assert| *assert == false.into()) {
            // some assert has been compiled to constant-false by symcc.
            // skip encoding and calling the solver.
            Ok(true)
        } else if asserts.iter().all(|assert| *assert == true.into()) {
            // all asserts have been compiled to constant-true by symcc.
            // skip encoding and calling the solver.
            Ok(false)
        } else {
            self.solver
                .smtlib_input()
                .reset()
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            self.solver
                .smtlib_input()
                .set_logic("ALL")
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            let mut encoder = Encoder::new(symenv, self.solver.smtlib_input())
                .map_err(|err| Error::EncoderConstruction { err })?;
            encoder
                .encode(asserts)
                .await
                .map_err(|err| Error::Encoding { err })?;
            match self.solver.check_sat().await? {
                Decision::Unsat => Ok(true),
                Decision::Sat => Ok(false),
                Decision::Unknown => Err(Error::SolverUnknown),
            }
        }
    }

    /// Checks satisfiability, and then returns the model (as a pair of [`Request`] and [`Entities`]);
    /// For soundness, `policies` must include all policies involved in the verification condition.
    pub async fn check_sat(
        &mut self,
        vc: impl FnOnce(&SymEnv) -> std::result::Result<Asserts, result::Error>,
        symenv: &SymEnv,
        policies: impl Iterator<Item = &Policy>,
    ) -> Result<Option<Env>> {
        let asserts = vc(symenv)?;
        if asserts.iter().any(|assert| *assert == false.into()) {
            // some assert has been reduced to constant-false by the symcc process.
            // skip encoding and calling the solver.
            Ok(None)
        } else if asserts.iter().all(|assert| *assert == true.into()) {
            let interp = Interpretation::default();
            let exprs = policies.map(|p| p.condition()).collect::<Vec<_>>();
            Ok(Some(symenv.interpret(&interp).concretize(exprs.iter())?))
        } else {
            self.solver
                .smtlib_input()
                .reset()
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            self.solver
                .smtlib_input()
                .set_logic("ALL")
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            self.solver
                .smtlib_input()
                .set_option("produce-models", "true")
                .await
                .map_err(|err| Error::Encoding { err: err.into() })?;
            let mut encoder = Encoder::new(symenv, self.solver.smtlib_input())
                .map_err(|err| Error::EncoderConstruction { err })?;
            encoder
                .encode(asserts)
                .await
                .map_err(|err| Error::Encoding { err })?;
            let id_maps = IdMaps::from_encoder(&encoder);
            match self.solver.check_sat().await? {
                Decision::Unsat => Ok(None),
                Decision::Sat => {
                    let Some(model_str) = self.solver.get_model().await? else {
                        return Ok(None);
                    };

                    let model = parse_sexpr(model_str.as_bytes())?;
                    let exprs = policies.map(|p| p.condition()).collect::<Vec<_>>();
                    let interp = model.decode_model(&id_maps)?;
                    let interp = interp.repair_as_counterexample(exprs.iter(), symenv);

                    Ok(Some(symenv.interpret(&interp).concretize(exprs.iter())?))
                }
                Decision::Unknown => Err(Error::SolverUnknown),
            }
        }
    }
}

/// The Cedar symbolic compiler assumes that it receives well-typed policies.  This
/// function enforces this requirement by calling Cedar's typechecker. Specifically,
/// given a policy `p` and type environment `Γ`, this function calls the Cedar
/// typechecker to obtain a policy `p'` that is semantically equivalent to `p` and
/// well-typed with respect to `Γ`.
///
/// All `check` functions defined in this file _must_ be called on the _output_ of
/// this function (or `well_typed_policies`) to ensure that symbolic compilation
/// succeeds. Applying the symbolic compiler directly to a policy `p` may result in
/// type errors---that is, the compiler rejecting the policy because it does not
/// satisfy the `WellTyped` constraints that are assumed by the compiler, and
/// enforced by the typechecker through policy transformation.
///
/// Note that unlike the corresponding Lean implementation which returns `Option` instead of `Result`.
/// We return a `Result` here to surface any type checking errors. In theory it should be impossible
/// to get an error since the policies are validated before calling SymCC.
pub fn well_typed_policy(
    policy: &Policy,
    env: &cedar_policy::RequestEnv,
    schema: &Schema,
) -> Result<Policy> {
    let env =
        to_validator_request_env(env, schema.as_ref()).ok_or_else(|| Error::ActionNotInSchema {
            action: env.action().to_string(),
        })?;
    well_typed_policy_inner(policy, &env, schema)
}

fn well_typed_policy_inner(
    policy: &Policy,
    env: &RequestEnv<'_>,
    schema: &Schema,
) -> Result<Policy> {
    let validator_schema = schema.as_ref();
    let type_checker = Typechecker::new(validator_schema, ValidationMode::Strict);
    let policy_check = type_checker.typecheck_by_single_request_env(policy.template(), env);

    match policy_check {
        cedar_policy_core::validator::typecheck::PolicyCheck::Success(expr) => {
            Ok(Policy::from_when_clause(
                policy.effect(),
                expr.into_expr::<ExprBuilder<()>>(),
                policy.id().clone(),
                policy.loc().cloned(),
            ))
        }
        cedar_policy_core::validator::typecheck::PolicyCheck::Irrelevant(errs, expr) =>
        // A policy could be irrelevant just for this environment, so unless there were errors we don't want to fail.
        // Note that if the policy was irrelevant for all environments schema validation would have caught this
        // before SymCC. The Lean implementation needs to be updated to match this behavior.
        {
            if errs.is_empty() {
                Ok(Policy::from_when_clause(
                    policy.effect(),
                    expr.into_expr::<ExprBuilder<()>>(),
                    policy.id().clone(),
                    policy.loc().cloned(),
                ))
            } else {
                Err(Error::PolicyNotWellTyped { errs })
            }
        }
        cedar_policy_core::validator::typecheck::PolicyCheck::Fail(errs) => {
            Err(Error::PolicyNotWellTyped { errs })
        }
    }
}

pub fn well_typed_policies(
    policies: &PolicySet,
    env: &cedar_policy::RequestEnv,
    schema: &Schema,
) -> Result<PolicySet> {
    let env =
        to_validator_request_env(env, schema.as_ref()).ok_or_else(|| Error::ActionNotInSchema {
            action: env.action().to_string(),
        })?;
    let typed_policies: Result<Vec<Policy>> = policies
        .static_policies()
        .map(|p| well_typed_policy_inner(p, &env, schema))
        .collect();
    match typed_policies {
        Ok(ps) => {
            let mut res = PolicySet::new();
            // PANIC SAFETY
            #[allow(
                clippy::unwrap_used,
                reason = "adding well-typed policy should not error"
            )]
            ps.into_iter().for_each(|p| res.add(p).unwrap());
            Ok(res)
        }
        Err(err) => Err(err),
    }
}
