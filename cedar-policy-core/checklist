build.rs:    // PANIC SAFETY: panicking inside our build script on a build dependency error is acceptable X
src/fuzzy.rs:    // PANIC SAFETY: See above.X
src/fuzzy.rs:    // PANIC SAFETY: Similar to above, but fixing the column index instead. X
src/fuzzy.rs:    // PANIC SAFETY: See above. X
src/fuzzy.rs:    // PANIC SAFETY: Accesses at one less than length in both dimensions. The length in both dimensions is non-zero. X
src/extensions/ipaddr.rs:// PANIC SAFETY All the names are valid namesX
src/extensions/ipaddr.rs:            // PANIC SAFETY `i` is guaranteed to be < `s.len()`, so this won't panicX
src/extensions/ipaddr.rs:            // PANIC SAFETY Conditional above performs a typecheck ~
src/extensions/ipaddr.rs:// PANIC SAFETY: Unit Test Code X
src/extensions/partial_evaluation.rs:    // PANIC SAFETY: This name is fully static, and is a valid extension name X
src/extensions/partial_evaluation.rs:// PANIC SAFETY: all uses of `unwrap` here on parsing extension names are correct names X (added test) 
src/extensions/decimal.rs:// PANIC SAFETY All `Name`s in here are valid `Name`s X
src/extensions/decimal.rs:    // PANIC SAFETY all of the names here are valid names X
src/extensions/decimal.rs:        // PANIC SAFETY: This regex does parse X
src/extensions/decimal.rs:            // PANIC SAFETY Conditional above performs a typecheck ~
src/extensions/decimal.rs:// PANIC SAFETY: Unit Test Code X
src/est.rs:                // PANIC SAFETY errs should be non empty if is_when is None X
src/est.rs:                // PANIC SAFETY checked above that `conditions` has at least 1 element ~
src/est.rs:// PANIC SAFETY: Unit Test Code X
src/authorizer.rs:                        // PANIC SAFETY: every policy in the diagnostics had to come from the policy set X
src/authorizer.rs:                // PANIC SAFETY This `unwrap` is safe as `idset` is non-empty X
src/authorizer.rs:                // PANIC SAFETY Since all of the ids in the original policy set were unique by construction, a subset will still be unique X
src/authorizer.rs:                    // PANIC SAFETY all policy IDs in the original policy are unique by construction X
src/authorizer.rs:        // PANIC SAFETY p1 and p2s effect cannot be equal by invariant X
src/authorizer.rs:// PANIC SAFETY: Unit Test Code
src/est/expr.rs:                // PANIC SAFETY: can't have duplicate keys here because the input was already a HashMap X
src/est/expr.rs:                        // PANIC SAFETY checked that `call.len() == 1` X
src/est/expr.rs:// PANIC SAFETY: this is unit test code X
src/est/expr.rs:// PANIC SAFETY: Unit Test Code X
src/est/expr.rs:        // PANIC SAFETY: safe due to INVARIANT on `ExtFuncCall` ~
src/parser.rs:        // PANIC SAFETY Shouldn't be `none` since `parse_policies()` and `to_policyset()` didn't return `Err` X
src/parser.rs:        // PANIC SAFETY Indexing is safe because of how `SourceInfo` is constructed  X
src/parser.rs:        // PANIC SAFETY Shouldn't be `None` since `parse_policies()` and `to_policyset()` didn't return `Err` X
src/parser.rs:    // PANIC SAFETY Shouldn't be `none` since `parse_policy()` didn't return `Err` X
src/parser.rs:// PANIC SAFETY: Unit Test Code X
src/evaluator/err.rs:        // PANIC SAFETY, `expected` is non-empty by invariant ~ 
src/evaluator/err.rs:        // PANIC SAFETY. `len` is 1 in this branch ~
src/transitive_closure.rs:        // PANIC SAFETY All nodes in `ancestors` came from `nodes` X
src/transitive_closure.rs:// PANIC SAFETY test cases X
src/transitive_closure.rs:// PANIC SAFETY: Unit Test Code X
src/evaluator.rs:// PANIC SAFETY `Name`s in here are valid `Name`s  X
src/evaluator.rs:                        // PANIC SAFETY: can't have a duplicate key here because `names` is the set of keys of the input `BTreeMap` X
src/evaluator.rs:            // PANIC SAFETY Unreachable via invariant on restricted expressions X
src/evaluator.rs:                // PANIC SAFETY: Input to `parse` is fully static and a valid extension function name X
src/evaluator.rs:                            // PANIC SAFETY `op` is checked to be one of the above ~ 
src/evaluator.rs:                                    // PANIC SAFETY `op` is checked to be one of these two above ~
src/evaluator.rs:                                    // PANIC SAFETY `op` is checked to be one of these two above ~
src/evaluator.rs:                        // PANIC SAFETY: can't have a duplicate key here because `names` is the set of keys of the input `BTreeMap` X
src/evaluator.rs:                // PANIC SAFETY Entity type name is fully static and a valid unqualified `Name` REMOVED
src/evaluator.rs:// PANIC SAFETY: Unit Test Code X
src/ast/policy_set.rs:        // PANIC SAFETY: every linked policy should have a template X
src/ast/policy_set.rs:                // PANIC SAFETY: every linked policy should have a template X
src/ast/policy_set.rs:// PANIC SAFETY tests X
src/ast/policy_set.rs:// PANIC SAFETY tests X
src/ast/request.rs:        // PANIC SAFETY: empty set of keys cannot contain a duplicate key X
src/ast/request.rs:    // PANIC SAFETY: This is safe due to the invariant on `self.context`, `self.context` must always be a record X
src/ast/request.rs:        // PANIC SAFETY invariant on `self.context` ensures that it is a record
src/ast/expr.rs:            // PANIC SAFETY: cannot have duplicate key because the input was already a BTreeMap
src/ast/expr.rs:                // PANIC SAFETY: cannot have a duplicate key because the input was already a BTreeMap
src/ast/expr.rs:// PANIC SAFETY Tested by `test::all_vars_are_ids`. Never panics.
src/ast/expr.rs:        // PANIC SAFETY: `Var` is a simple enum and all vars are formatted as valid `Id`. Tested by `test::all_vars_are_ids`
src/ast/value.rs:                            // PANIC SAFETY: This is unreachable as every item in `literals` matches Value::Lit
src/ast/value.rs:// PANIC SAFETY: Unit Test Code
src/ast/restricted_expr.rs:            // PANIC SAFETY: We're in debug mode and panicking intentionally
src/ast/restricted_expr.rs:            // PANIC SAFETY: cannot have duplicate key because the input was already a BTreeMap
src/ast/restricted_expr.rs:            // PANIC SAFETY: We're in debug mode and panicking intentionally
src/ast/pattern.rs:            // PANIC SAFETY `j` is checked to be less than length
src/ast/pattern.rs:        // PANIC SAFETY `j` is checked to be less than length
src/ast/policy.rs:        // PANIC SAFETY 0,0 case is not an error
src/ast/policy.rs:// PANIC SAFETY: Unit Test Code
src/ast/policy.rs:// PANIC SAFETY: Unit Test Code
src/entities.rs:    // PANIC SAFETY: This function is intended to panic, and says so in the documentation
src/entities.rs:    // PANIC SAFETY: This function is intended to panic, and says so in the documentation
src/entities.rs:// PANIC SAFETY: Unit Test Code
src/entities.rs:// PANIC SAFETY unit tests
src/entities.rs:// PANIC SAFETY: Unit Test Code
src/entities.rs:// PANIC SAFETY unit tests
src/entities.rs:// PANIC SAFETY: Unit Test Code
src/entities.rs:// PANIC SAFETY unit tests
src/entities/json/schema_types.rs:        // PANIC SAFETY. Unreachable by invariant on restricted expressions
src/entities/json/entities.rs:// PANIC SAFETY unit test code
src/entities/json/value.rs:                // PANIC SAFETY. We've checked that `args` is of length 1, fine to index at 0
src/parser/cst_to_ast.rs:                    // PANIC SAFETY Checked the match above via the call to `partition`
src/parser/cst_to_ast.rs:                // PANIC SAFETY If nonconstantints is empty then constantints must have at least one value
src/parser/cst_to_ast.rs:                // PANIC SAFETY Checked above that `nonconstantints` has at least one element
src/parser/cst_to_ast.rs:// PANIC SAFETY: Unit Test Code
src/parser/text_to_cst.rs:    //PANIC SAFETY: lalrpop uses unwraps, and we are trusting lalrpop to generate correct code
src/parser/text_to_cst.rs:    //PANIC SAFETY: lalrpop uses slicing, and we are trusting lalrpop to generate correct code
src/parser/text_to_cst.rs:    //PANIC SAFETY: lalrpop uses unreachable, and we are trusting lalrpop to generate correct code
src/parser/text_to_cst.rs:    //PANIC SAFETY: lalrpop uses panic, and we are trusting lalrpop to generate correct code
src/parser/unescape.rs:        // PANIC SAFETY By invariant, all passed in ranges must be in range
src/parser/unescape.rs:    // PANIC SAFETY By invariant, the range will always be within the bounds of `input`
src/parser/err.rs:    // PANIC SAFETY Shouldn't be `Err` since we're writing strings to a string
